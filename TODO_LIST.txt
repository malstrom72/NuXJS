tools/initPPEG.pika:47:	swap(@::ppeg.$compileTo, @target);	// FIX : ugly non-reentrant solution here!
    	::pps = syntax;
    	::ppi = ::ppm = 0;

tools/NuXJSREPL.cpp:268:		if (f == 0) { // FIX : sub to make is not a function error or something?
    			ScriptException::throwError(heap, TYPE_ERROR, String::concatenate(heap, *argv[0].toString(heap), String(" is not a function")));
    		}
tools/NuXJSREPL.cpp:569:                        source = String(heap.roots(), String(heap.roots(), String("print("), String(heap.roots(), source.begin() + 1, source.end())), String(")")); // FIX : operator +
                        }
                        if (interactive) {

tools/NuXJSREPL.cpp:585:                doQuit = true; // FIX : we shouldn't use the same loop for interactive and non-interactive
                }
    

tools/NuXJSREPL.cpp:603:						// ss << ", column: " << columnNumber; // FIX : keep or not? if so, need to update all tests:
                            ws = ss.str();
                        }

tools/NuXJSREPL.cpp:610:// FIX :						std::wcout << std::wstring(std::max<const Char*>(stopPoint - 8, source.begin()), std::min<const Char*>(stopPoint + 8, source.end())) << std::endl;
                        throw;
                    }

tools/testdash.html:79:		[ "todo", "TODO" ],
    	];
    

tests/conforming/prototypes.io:48:> /* FIX : reenable
    >     function Damaged() { }
    >     Damaged.prototype = 12345;

tests/conforming/stdlib1.io:210:>     // FIX : test that all functions in all standard library objects are not constructable and that they don't have prototype fields
    > //  var globalObjects = [ "Object", "Boolean", "Number", "String", "Function", "Error", "Math" ]; <- rest of errors
    >

tests/conforming/stdlib1.io:315:>     // FIX : test errors
    >
    >     // FIX : test that all function's have names that matches their property names in their "owner objects"

tests/conforming/stdlib1.io:317:>     // FIX : test that all function's have names that matches their property names in their "owner objects"
    >
    >         var global = this;

tests/migrated/goodOldTests_eval.io:337:> // o.eval("print(this.isGlobal)"); // FIX : jsc doesn't like this
    > // o.test1(); // FIX : jsc doesn't like this
    > // o.test2();

tests/migrated/goodOldTests_eval.io:338:> // o.test1(); // FIX : jsc doesn't like this
    > // o.test2();
    -

tests/migrated/goodOldTests_specialNumbers.io:1:> // FIX : infinity etc
    -
    > o = new (function(){});

tests/migrated/goodOldTests_functions.io:67:> // FIX : js doesn't like -> (function() { print(g.length); if (false) function g(a,b) { }; if (false) function g(a,b,c,d) { } })(); // 4
    > print("del: " + delete g);
    < del: true

tests/migrated/goodOldTests_arrays.io:63:> /* FIX : should throw
    > newedArray = new Array(-1);
    > print(newedArray.length);

tests/migrated/goodOldTests_arrays.io:73:> /* FIX : should throw
    > newedArray = new Array(50.5);
    > print(newedArray.length);

tests/migrated/goodOldTests_objects.io:46:> // FIX : enable once we have toString in object.prototype
    > // print(objectFromCustomConstructor in objectFromCustomConstructor);
    > print("objectFromCustomConstructor" in this);

tests/migrated/goodOldTests_objects.io:54:> /* FIX :
    > Object.prototype.patch = "patched";
    > print(emptyObject.patch);

tests/migrated/goodOldTests_moreNumbers.io:13:> // print(1.0E-3 == 0.001) // FIX : accuracy problem
    > print(1.0E+3 == 1000.0)
    > print(0.000000000001 == 0.000000000001)

tests/migrated/goodOldTests_moreNumbers.io:19:> // print(x == 0.003e3) // FIX : accuracy problem
    > print(!(x == 2.9))
    > print(!(x != 3))

src/NuXJS.h:404:typedef Byte Flags; // FIX : turn into enum
    const Flags EXISTS_FLAG = 1; // FIX : turn these into enum, that's ok
    const Flags READ_ONLY_FLAG = 2;

src/NuXJS.h:405:const Flags EXISTS_FLAG = 1; // FIX : turn these into enum, that's ok
    const Flags READ_ONLY_FLAG = 2;
    const Flags DONT_ENUM_FLAG = 4;

src/NuXJS.h:706:		// FIX : toString too?
    		virtual Flags getOwnProperty(Runtime& rt, const Value& key, Value* v) const;
    		virtual bool setOwnProperty(Runtime& rt, const Value& key, const Value& v, Flags flags = STANDARD_FLAGS);

src/NuXJS.h:724:			const_cast<JSArray*>(this)->denseVector.shrink(); // FIX : split into two different gc-things? it really *is* different to just mark stuff and actively shrink / compress stuff
    			gcMark(heap, denseVector.begin(), denseVector.end());
    			super::gcMarkReferences(heap);

src/NuXJS.h:744:// FIX : maybe split into seperate FunctionCode for function's (most fields only apply to functions)
    class Code : public Object {
    	friend class FunctionScope;

src/NuXJS.h:747:	friend class Compiler; // FIX : maybe not one day?
    
    	public:

src/NuXJS.h:815:// FIX : overkill?
    template<class F> struct FunctorAdapter : public Function {
    	typedef Function super;

src/NuXJS.h:1257:// FIX : why template?
    template<class F> struct AccessorBase::VarFunctorAdapter : public ExtensibleFunction {
    	typedef ExtensibleFunction super;

src/NuXJS.h:1283:// FIX : vvv I think there should be a getLength() in Object*
    inline UInt32 AccessorBase::size() const {
    	const JSArray* a = get().asArray();

src/NuXJS.h:1356:		enum Opcode {	// FIX : sort
    			INVALID_OP = -1 // FIX : why?!
    			, CONST_OP										// operand: const_index, stack: -> constant

src/NuXJS.h:1357:			INVALID_OP = -1 // FIX : why?!
    			, CONST_OP										// operand: const_index, stack: -> constant
    			, READ_LOCAL_OP									// operand: local_index, stack: -> value

src/NuXJS.h:1385:			// FIX : push back is a really bad name, it's really pop back and then push sort of
    			, PUSH_BACK_OP									// operand: count, stack: ..., back -> back
    			, REPUSH_OP										// operand: offset, stack: ..., value, ... -> ..., value, ..., value

src/NuXJS.h:1399:			// FIX : should we have an optional pop argument (push back) to RETURN_OP?
    			, RETURN_OP
    			// FIX : maybe we should also have a RETURN_VOID_OP?

src/NuXJS.h:1401:			// FIX : maybe we should also have a RETURN_VOID_OP?
    			, THIS_OP, VOID_OP								// stack: -> value
    			, DELETE_OP										// stack: object, name -> boolean

src/NuXJS.h:1491:		void invokeFunction(Function* f, Int32 popCount, Int32 argc, Object* thisObject = 0); // FIX : rename, unnecessary with the same name as the public method
    		void newOperation(const Int32 argc);
    		void reset();

src/NuXJS.h:1535:		const Char* compileFunction(const Char* b, const Char* e, const String* functionName, const String* selfName = 0); // FIX : messy, why do we have compileFor if we separate this anyhow? Maybe subclass Compiler instead?
    		void compile(const String& source);
    		void getStopPosition(size_t& offset, int& lineNumber, int& columnNumber) const;

src/NuXJS.h:1644:		int withScopeCounter; // FIX : if we have a Context object instead as "this" we could create a new one with a simple flag for this instead of yucky counter
    		int nestCounter;
    

src/stdlib.js:130:// TODO : what a waste of cycles, could be a simple OBJ_TO_STRING, problem with ''+s is that it uses OBJ_TO_NUMBER which only affects the priority of toString vs valueOf... so subtle!
    function str(o) { return '' + (isPrimitive(o) ? o : support.toPrimitiveString(o)) }
    

src/stdlib.js:254:	apply: unconstructable(function apply(thisArg, argArray) { // FIX : <- 100% native version in the future I think
    		var theClass;
    		if (argArray == null) argArray = [ ];

src/stdlib.js:262:	call: unconstructable(function call(thisArg) { // FIX : <- 100% native version in the future I think
    		return $callWithArgs(this, thisArg, arguments, 1);
    	}),

src/stdlib.js:265:	toString: unconstructable(function toString() { // FIX : <- generic, make a factory function
    		checkClass(this, "Function", "toString");
    		return $getInternalProperty(this, "value");

src/stdlib.js:970:	// TODO: this isn't as generic as in the ES5 spec, e.g. not converting this to object, not going via the objects reassignable `toISOString`.
    	toJSON: unconstructable(function toJSON() { return isoDate(this); })
    });

src/stdlib.js:1013:// FIX : all charCodeAt etc need to be stowed away so that we won't destroy regexp if changing global objects. This is true for all the code in here actually.
    function compileRegExp(s, caseInsensitive, multiLine) {
    	var p = 0, functions = '', functionCounter = 0, captureCounter = 0, closureVars = '', maxBackReference = 0;

src/stdlib.js:1019:	function areClass(s, mask) { // FIX : only used once
    		for (var i = s.length - 1; i >= 0; --i) if ((CC[s[i]] & mask) === 0) return false;
    		return true;

src/stdlib.js:1036:				n = n * 10 + ($charCodeAt(s, p) - 48); // FIX : +s[p] faster?
    				++p;
    			} while (isClass(s[p], DECIMAL_CHAR))

src/stdlib.js:1065:					throw syntaxError("Min greater than max in regular expression quantifier"); // FIX
    				}
    				++p;

src/stdlib.js:1081:		// TODO : shorter escapes for \n etc
    		return (c <= '~' ? "\\x" : "\\u") + leftPad(numberToRadix($charCodeAt(c, 0), 16), (c <= '~' ? 2 : 4));
    	}

src/stdlib.js:1187:		// TODO : sometimes functions are identical (e.g. class-tests), reuse here or in '[' parsing directly?
    		functions += "\tfunction " + name + "(p) { " + definition + " }\n";
    	}

src/stdlib.js:1192:		// TODO : eliminate unnecessary b=p+0,e=p+Infinity and stuff
    		var functionName = 'q' + (++functionCounter)
    				, head = (stepSize ? "var h=" + stepSize + "," : "var ")

src/stdlib.js:1261:			} else { // TODO: make subs of these
    				var c, condition, tail, useCall, inner;
    				switch (c = s[p]) {

src/stdlib.js:1326:				// TODO: $match should take two additional optional params: start, end in match-string, thus eliminating need for substring here
    							quantity = parseQuantifier();
    							var stepSize = 'c' + (n + 1) + "-c" + n

src/stdlib.js:1374:						var innerCapturesStart = captureCounter // FIX : these two are only used for negative lookAhead, use for open/close captures too?
    								, disjunction = compileDisjunction(0, (lookAhead ? void 0 : junctionName))
    								, innerCapturesEnd = captureCounter;

src/stdlib.js:1502:	// TODO : short-cut most of this through cache instead of only the func def.
    	// TODO : limit number of entries in cache
    	pattern = (pattern === void 0 ? '' : str(pattern));

src/stdlib.js:1503:	// TODO : limit number of entries in cache
    	pattern = (pattern === void 0 ? '' : str(pattern));
    	flags = (flags === void 0 ? '' : str(flags));

src/stdlib.js:1650:// TODO : use StringBuilder?
    defineProperties(JSON, { dontEnum: true }, {
    	stringify: unconstructable(function stringify(val, replacer, space) {

src/NuXJS.cpp:88:// FIX : if c++11 use std::isnan and std::isfinite
    bool isNaN(double d) { return d != d; }
    bool isFinite(double d) { return !isNaN(d) && fabs(d) != std::numeric_limits<double>::infinity(); }

src/NuXJS.cpp:202:// FIX : shouldn't need this, used in quick-hash-finders and they should be optimized somehow i think
    static int strncmp(const Char* a, const char* b, size_t n) {
    	size_t i = 0;

src/NuXJS.cpp:336:			integers[i + QUICK_CONSTANTS_INTEGERS_RANGE] = String(intToString(buffer, i), buffer + 32); // FIX : newHashedString
    			integers[i + QUICK_CONSTANTS_INTEGERS_RANGE].createBloomCode();
    		}

src/NuXJS.cpp:1589:Object* JSArray::getPrototype(Runtime& rt) const { // FIX : have a sep. ArrayPrototype object like we have for Function?
    	Object* arrayPrototype = rt.getPrototypeObject(Runtime::ARRAY_PROTOTYPE);
    	return (this == arrayPrototype ? rt.getObjectPrototype() : arrayPrototype);


src/NuXJS.cpp:1992:		// FIX : make sub that lookup's the bucket, also use in getProperty
    		if (dynamicVars != 0 || name->isEqualTo(ARGUMENTS_STRING)) {
    			Table& props = *getDynamicVars(rt);

src/NuXJS.cpp:2005:	parentScope->writeVar(rt, name, v); // FIX : recursion
    }
    

src/NuXJS.cpp:2027:	return parentScope->deleteVar(rt, name); // FIX : recursion
    }
    

src/NuXJS.cpp:2343:	if (firstCatcher == 0) { // FIX: what exception to throw here?
    		reset();
    		throw ScriptException(heap, exception);

src/NuXJS.cpp:2367:// FIX : should we continue this non-throwing approach or simply use toFunction everywhere? If keeping, we should share error creation with toFunction()
    Function* Processor::asFunction(const Value& v) {
    	Function* const f = v.asFunction();

src/NuXJS.cpp:2383:	if (f != 0) { // FIX : sub
    		Value v(UNDEFINED_VALUE);
    		f->getProperty(rt, &PROTOTYPE_STRING, &v);

src/NuXJS.cpp:2478:				// FIX : doesn't feel totally efficient this...
    				if (sp[-1].isObject() != sp[0].isObject()) {
    					if (sp[-1].isObject()) {

src/NuXJS.cpp:2519:				scope->makeClosure(); // FIX : only to prevent popping it since it is shared by two frames, feels wrong
    				pushFrame(code, scope, thisObject);
    				ip += im;

src/NuXJS.cpp:2942:// FIX : share code somehow
    	const Processor::OpcodeInfo& opcodeInfo = Processor::getOpcodeInfo(opcode);
    	const Int32 operand = 0;

src/NuXJS.cpp:2999:static const Char LINE_TERMINATORS[] = { '\n', 0x2028, 0x2029, '\r' }; // FIX : '\r' must be last for line count to work, but I think we should change line counting algo in the future, a single '\r' without '\n' should count too really
    
    static bool isLineTerminator(Char c) {

src/NuXJS.cpp:3205:		default: error(REFERENCE_ERROR, "Illegal l-value"); // FIX : ECMA like the word "reference"
    		case ExpressionResult::LOCAL: emit(Processor::WRITE_LOCAL_OP, xr.v.toInt()); break;
    		case ExpressionResult::NAMED: emitWithConstant(Processor::WRITE_NAMED_OP, xr.v); break;

src/NuXJS.cpp:3297:Compiler::ExpressionResult Compiler::arrayInitialiser() { // FIX : share stuff with functionCall and arrayInitialiser
    	emit(Processor::NEW_ARRAY_OP);
    

src/NuXJS.cpp:3340:Compiler::ExpressionResult Compiler::objectInitialiser() { // FIX : share stuff with functionCall and arrayInitialiser
    	emit(Processor::NEW_OBJECT_OP);
    

src/NuXJS.cpp:3422:			emit(Processor::NEW_RESULT_OP); // FIX : make a chain for script constructors and require returning object for native constructors instead?
                assert(!op.primitiveOutput);
                xr = ExpressionResult::PUSHED;

src/NuXJS.cpp:3647:	catch (const Exception&) { // FIX : a bit Q & D ish
    		p = funcCompiler.p;
    		throw;

src/NuXJS.cpp:3790:// FIX : ok, this is serious mess
    Compiler::ExpressionResult Compiler::declareIdentifier(const String* name, bool func) {
    	ExpressionResult lxr(ExpressionResult::NAMED, name);

src/NuXJS.cpp:3929:// FIX : sort all statement funcs
    
    void Compiler::varStatement() {

src/NuXJS.cpp:4180:/* FIX : I thought we could drop if we keep the reserve-one-element-for-return-on-stack-solution, but rethrower needs a place to safe-keep its throw value and this is here*/
    	if (compilingFor != FOR_EVAL) { // space holder for return value so that we can break out of finallys (with the same stack pop count) regardless if try scope returns a value or not
    		emit(Processor::VOID_OP, 0);

src/NuXJS.cpp:4214:		bool didExist = false; // FIX : can use NON_EXISTENT type if we choose to keep it
    		Table::Bucket* indexBucket = nameIndexes.lookup(exceptionVarName);
    		if (indexBucket != 0) {

src/NuXJS.cpp:4273:/* FIX : I thought we could drop if we keep the reserve-one-element-for-return-on-stack-solution */
    	if (compilingFor != FOR_EVAL) { // pop return space holder
    		emit(Processor::POP_OP, 1);

src/NuXJS.cpp:4435:	// FIX : not 100% necessary now because we should always start with undefined on top of stack
    	if (compilingFor == FOR_EVAL) {
    		emit(Processor::POP_OP, 1);	// FIX : only if we reserve one element for return like we do now

src/NuXJS.cpp:4437:		emit(Processor::POP_OP, 1);	// FIX : only if we reserve one element for return like we do now
    		emit(Processor::VOID_OP);
    	}

src/NuXJS.cpp:4442: 	// FIX : sometimes necessary even if we start with undefined on top of stack, because try/catch rethrower might need to safe-keep its exception there
    	if (compilingFor != FOR_EVAL) {
    		// FIX : if RETURN_OP took a push back count we could just do void_op here, or even have another RETURN_VOID_OP

src/NuXJS.cpp:4444:		// FIX : if RETURN_OP took a push back count we could just do void_op here, or even have another RETURN_VOID_OP
    		emit(Processor::POP_OP, 1);	// FIX : only if we reserve one element for return like we do now
    		emit(Processor::VOID_OP);

src/NuXJS.cpp:4445:		emit(Processor::POP_OP, 1);	// FIX : only if we reserve one element for return like we do now
    		emit(Processor::VOID_OP);
    	}

src/NuXJS.cpp:4461:	assert(compilingFor == FOR_FUNCTION);  // FIX : messy, why do we have compilerFor if we separate this anyhow? Maybe subclass Compiler instead?
    	assert(functionName != 0);
    	p = b;

src/NuXJS.cpp:4486:	compile(p, e); // FIX: ugly as it sets p and e again, although it doesn't hurt
    	expectToken("}", false);
    	code->name = functionName;

src/NuXJS.cpp:4499:		error(SYNTAX_ERROR, "Syntax error"); // FIX : better error?
    	}
    }

src/NuXJS.cpp:4548:	// FIX : deep or not?!
    	const Flags flags = rt.getGlobalObject()->getOwnProperty(rt, name, &v);
    	if (flags == NONEXISTENT || !initValue.isUndefined()) {

src/NuXJS.cpp:4619:	if (flags != NONEXISTENT) { // FIX : getName?
    		completeObject->setOwnProperty(rt, &NAME_STRING, v, flags);
    	}

src/NuXJS.cpp:4623:	if (flags != NONEXISTENT) { // FIX : in the future I think we should have a getLength
    		completeObject->setOwnProperty(rt, &LENGTH_STRING, v, flags);
    	}

src/NuXJS.cpp:4742:				if (arrayObject->getProperty(rt, &LENGTH_STRING, &v) != NONEXISTENT) { // FIX : in the future I think we should have a virtual getLength
    					Int32 offset = (argc > 3 ? argv[3].toInt() : 0);
    					UInt32 length = static_cast<UInt32>(std::max(v.toInt() - offset, 0));

src/NuXJS.cpp:4752:			// FIX : we copy all arguments once to argv, and then chain will copy them again to a scope object, couldn't we short-cut that somehow?
    			// FIX : since only arrays and arguments are really valid here, perhaps even have a new virtual in object for implementing efficient apply with these?
    			return callFunction->invoke(rt, processor, args.size(), args.begin(), newThis);

src/NuXJS.cpp:4753:			// FIX : since only arrays and arguments are really valid here, perhaps even have a new virtual in object for implementing efficient apply with these?
    			return callFunction->invoke(rt, processor, args.size(), args.begin(), newThis);
    		}

src/NuXJS.cpp:5005:		ScriptException::throwError(heap, RANGE_ERROR, &STACK_OVERFLOW_STRING); // FIX : other string?
    	}
    	struct NestCounter {

src/NuXJS.cpp:5089:	// FIX : static strings?
    	supportObject->setOwnProperty(*this, String::allocate(heap, "prototypes"), prototypesObject);
    	for (size_t i = 0; i < sizeof (SUPPORT_FUNCTIONS) / sizeof (*SUPPORT_FUNCTIONS); ++i) {

docs/notes/Todo.md:1:TODO

docs/ECMA Violations.md:7:	or CR. Also <NBSP> (\u00A0) and <ZWNBSP> ZERO WIDTH NO-BREAK SPACE (\uFEFF) are not considered white space. FIX :

docs/ECMA Violations.md:13:	FIX : why not?

docs/notes/Done.md:125:	* FIX : The SourceCharacter immediately following a NumericLiteral must not be an IdentifierStart or DecimalDigit.    For example:     3in     is an error and not the two input elements 3 and in.

docs/notes/Changes For ES5.md:4:		if ((o = convertToObject(vsp[0], false)) == 0) { // FIX : so common!
