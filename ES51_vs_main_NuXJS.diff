diff --git a/src/NuXJS.cpp b/src/NuXJS.cpp
index 091635a..f028616 100644
--- a/src/NuXJS.cpp
+++ b/src/NuXJS.cpp
@@ -21,20 +21,20 @@
 	IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 **/
 
-#ifdef __GNUC__
-#ifndef __clang__
+			#ifdef __GNUC__
+			#ifndef __clang__
 #pragma GCC push_options
 #pragma GCC optimize ("no-finite-math-only")
 // older gcc might need this too:
 // #pragma GCC optimize ("float-store")
-#endif
-#endif
+			#endif
+			#endif
 
-#ifdef _MSC_VER
+			#ifdef _MSC_VER
 #pragma float_control(precise, on, push)  
 #endif
 
-#ifdef __FAST_MATH__
+			#ifdef __FAST_MATH__
 #error This code requires IEEE compliant floating point handling. Avoid -Ofast / -ffast-math etc (at least for this source file).
 #endif
 
@@ -42,14 +42,14 @@
 #include "assert.h"
 #include <cmath>
 #include "NuXJS.h"
-#ifdef _MSC_VER
+			#ifdef _MSC_VER
 #include <float.h>
 #endif
 
 // Since these can be called during static initialization we allow heap == 0 to use standard new/delete.
 void* operator new(size_t size, NuXJS::Heap* heap) {
 	return (heap != 0 ? heap->allocate(size) : ::operator new(size));
-}
+	}
 
 void* operator new[](size_t size, NuXJS::Heap* heap) {
 	return (heap != 0 ? heap->allocate(size) : ::operator new[](size));
@@ -79,7 +79,7 @@ namespace NuXJS {
 
 // MSVC (at least 2010) doesn't do fmod correctly with infinite divisor
 static double NaN() { return std::numeric_limits<double>::quiet_NaN(); }
-#ifdef _MSC_VER
+			#ifdef _MSC_VER
 bool isNaN(double d) { return (_isnan(d) != 0); }
 bool isFinite(double d) { return (_finite(d) != 0); }
 
@@ -106,7 +106,7 @@ bool isFinite(double d) { return (_finite(d) != 0); }
 			!_f		_f		_f		_f		!_f		!_f
 */
 static double modulo(double x, double y) { return (!_finite(y) && !_isnan(y) && _finite(x) ? x : fmod(x, y)); }
-#else
+	#else
 static double modulo(double x, double y) { return fmod(x, y); }
 // FIX : if c++11 use std::isnan and std::isfinite
 bool isNaN(double d) { return d != d; }
@@ -167,11 +167,11 @@ const UInt16 IDENTIFIER_PART_OFFSETS[256] = {
 
 static inline bool testUnicodeChar(Char c, const UInt16* offsets) {
 	return (UNICODE_MASKS[offsets[c >> 8] + ((c & 255) >> 5)] & (1 << (c & 31))) != 0;
-}
+	}
 
 /* --- String constants --- */
 
-const String BOOLEAN_STRING("boolean"), FUNCTION_STRING("function"), NUMBER_STRING("number"), OBJECT_STRING("object")
+		const String BOOLEAN_STRING("boolean"), FUNCTION_STRING("function"), NUMBER_STRING("number"), OBJECT_STRING("object")
 		, STRING_STRING("string");
 
 const String EMPTY_STRING, LENGTH_STRING("length"), NULL_STRING("null"), UNDEFINED_STRING("undefined");
@@ -180,6 +180,10 @@ const String A_RGUMENTS_STRING("Arguments"), A_RRAY_STRING("Array"), B_OOLEAN_ST
 				, E_RROR_STRING("Error"), F_UNCTION_STRING("Function"), N_UMBER_STRING("Number"), O_BJECT_STRING("Object")
 				, S_TRING_STRING("String");
 
+			#if (NUXJS_ES5)
+const String GET_STRING("get"), SET_STRING("set");
+#endif
+
 static const String ANONYMOUS_STRING("anonymous"), ARGUMENTS_STRING("arguments")
 		, BRACKET_OBJECT_STRING("[object "), CALLEE_STRING("callee")
 		, CANNOT_CONVERT_TO_OBJECT_STRING("Cannot convert undefined or null to object")
@@ -1277,6 +1281,9 @@ const String* Object::getClassName() const { return &O_BJECT_STRING; }
 Object* Object::getPrototype(Runtime& rt) const { return rt.getObjectPrototype(); }
 Value Object::getInternalValue(Heap&) const { return UNDEFINED_VALUE; }
 Flags Object::getOwnProperty(Runtime&, const Value&, Value*) const { return NONEXISTENT; }
+#if (NUXJS_ES5)
+bool Object::setOwnProperty(Runtime& rt, const String* key, const Value& v, Flags flags) { return setOwnProperty(rt, Value(key), v, flags); }
+#endif
 bool Object::setOwnProperty(Runtime&, const Value&, const Value&, Flags) { return false; }
 bool Object::deleteOwnProperty(Runtime&, const Value&) { return false; }
 Enumerator* Object::getOwnPropertyEnumerator(Runtime&) const { return &EMPTY_ENUMERATOR; }
@@ -1316,6 +1323,33 @@ Flags Object::getProperty(Runtime& rt, const Value& key, Value* v) const {
 	return NONEXISTENT;
 }
 
+#if (NUXJS_ES5)
+Flags Object::getProperty(Runtime& rt, Processor& processor, const Value& key, Value* v) const {
+const Object* o = this;
+do {
+Value current;
+Flags flags = o->getOwnProperty(rt, key, &current);
+if (flags != NONEXISTENT) {
+if ((flags & ACCESSOR_FLAG) != 0) {
+Accessor* acc = static_cast<Accessor*>(current.asObject());
+Function* getter = (acc != 0 ? acc->getter : 0);
+if (getter != 0) {
+processor.invokeFunction(getter, 0, static_cast<const Value*>(0), const_cast<Object*>(this));
+} else {
+*v = UNDEFINED_VALUE;
+}
+} else {
+*v = current;
+}
+return flags;
+}
+o = o->getPrototype(rt);
+} while (o != 0);
+return NONEXISTENT;
+}
+#endif
+
+
 bool Object::setProperty(Runtime& rt, const Value& key, const Value& v) {
 	if (updateOwnProperty(rt, key, v)) {
 		return true;
@@ -1330,6 +1364,25 @@ bool Object::setProperty(Runtime& rt, const Value& key, const Value& v) {
 	return setOwnProperty(rt, key, v);
 }
 
+#if (NUXJS_ES5)
+bool Object::setProperty(Runtime& rt, Processor& processor, const Value& key, const Value& v) {
+Value current;
+Flags flags = getProperty(rt, key, &current);
+if (flags != NONEXISTENT && (flags & ACCESSOR_FLAG) != 0) {
+Accessor* acc = static_cast<Accessor*>(current.asObject());
+Function* setter = (acc != 0 ? acc->setter : 0);
+if (setter != 0) {
+Value arg(v);
+processor.invokeFunction(setter, 1, &arg, const_cast<Object*>(this));
+return true;
+}
+return false;
+}
+setProperty(rt, key, v);
+return false;
+}
+#endif
+
 Enumerator* Object::getPropertyEnumerator(Runtime& rt) const {
 	Heap& heap = rt.getHeap();
 	Enumerator* enumerator = getOwnPropertyEnumerator(rt);
@@ -1347,7 +1400,7 @@ UInt32 Table::calcMaxLoad(UInt32 bucketCount) { return (bucketCount - (bucketCou
 Table::Table(Heap* heap) : buckets(1U << TABLE_BUILT_IN_N, heap), loadCount(0) { }
 UInt32 Table::getLoadCount() const { return loadCount; }
 Table::Bucket* Table::getFirst() const { return getNext(buckets.begin() - 1); }
-const Table::Bucket* Table::lookup(const String* key) const { return const_cast<Table*>(this)->lookup(key); }	// OK because lookup does not modify, only exposes non-const pointer
+	const Table::Bucket* Table::lookup(const String* key) const { return const_cast<Table*>(this)->lookup(key); }	// OK because lookup does not modify, only exposes non-const pointer
 
 Table::Bucket* Table::getNext(Bucket* bucket) const {
 	assert(bucket != 0);
@@ -1479,8 +1532,33 @@ JSObject::JSObject(GCList& gcList, Object* prototype)
 Object* JSObject::getPrototype(Runtime&) const { return prototype; }
 
 bool JSObject::setOwnProperty(Runtime& rt, const Value& key, const Value& v, Flags flags) {
+#if (NUXJS_ES5)
+	return setOwnProperty(rt, key.toString(rt.getHeap()), v, flags);
+	#else
 	return update(insert(key.toString(rt.getHeap())), v, flags);
+#endif
+}
+
+#if (NUXJS_ES5)
+bool JSObject::setOwnProperty(Runtime& rt, const String* key, const Value& v, Flags flags) {
+		Table::Bucket* bucket = insert(key);
+#if (NUXJS_ES5)
+		if ((flags & ACCESSOR_FLAG) != 0 && bucket->valueExists() && (bucket->getFlags() & ACCESSOR_FLAG) != 0) {
+				Accessor* acc = static_cast<Accessor*>(bucket->getValue().getObject());
+				Accessor* nv = static_cast<Accessor*>(v.getObject());
+				if (nv->getter != 0) {
+						acc->getter = nv->getter;
+				}
+				if (nv->setter != 0) {
+						acc->setter = nv->setter;
+				}
+				return true;
+		}
+#endif
+		return update(bucket, v, flags);
 }
+#endif
+
 
 bool JSObject::updateOwnProperty(Runtime& rt, const Value& key, const Value& v) {
 	Table::Bucket* bucket = lookup(key.toString(rt.getHeap()));
@@ -1495,7 +1573,6 @@ Flags JSObject::getOwnProperty(Runtime& rt, const Value& key, Value* v) const {
 	}
 	return NONEXISTENT;
 }
-
 bool JSObject::deleteOwnProperty(Runtime& rt, const Value& key) {
 	Table::Bucket* bucket = lookup(key.toString(rt.getHeap()));
 	return (bucket == 0 || erase(bucket));
@@ -1554,6 +1631,9 @@ Code::Code(GCList& gcList, Constants* sharedConstants)
 		, constants(sharedConstants ? sharedConstants : new(gcList.getHeap()) Constants(gcList.getHeap().managed()))
 		, nameIndexes(&gcList.getHeap()), varNames(&gcList.getHeap()), argumentNames(&gcList.getHeap()), name(0)
 		, selfName(0), source(0), bloomSet(0), maxStackDepth(0)
+#if (NUXJS_ES5)
+		, strict(false)
+#endif
 {
 	assert(constants != 0);
 }
@@ -1599,13 +1679,19 @@ bool Function::hasInstance(Runtime& rt, Object* object) const {
 		return false;
 }
 
+#if (NUXJS_ES5)
+Function* Function::getConstructTarget() {
+	return this;
+}
+#endif
+
 /* --- JSArray --- */
 
 JSArray::JSArray(GCList& gcList) : super(gcList), length(0), denseVector(&gcList.getHeap()) { }
 JSArray::JSArray(GCList& gcList, UInt32 initialLength)
 		: super(gcList), length(initialLength), denseVector(initialLength, &gcList.getHeap()) {
 	std::fill(denseVector.begin(), denseVector.end(), UNDEFINED_VALUE);
-}
+	}
 JSArray::JSArray(GCList& gcList, UInt32 initialLength, const Value* initialElements) : super(gcList)
 		, length(initialLength), denseVector(initialElements, initialElements + initialLength, &gcList.getHeap()) { }
 
@@ -1697,6 +1783,12 @@ bool JSArray::setElement(Runtime& rt, UInt32 index, const Value& v) {
 	return super::setOwnProperty(rt, index, v, STANDARD_FLAGS);
 }
 
+#if (NUXJS_ES5)
+bool JSArray::setOwnProperty(Runtime& rt, const String* key, const Value& v, Flags flags) {
+	return setOwnProperty(rt, Value(key), v, flags);
+}
+#endif
+
 bool JSArray::setOwnProperty(Runtime& rt, const Value& key, const Value& v, Flags flags) {
 	UInt32 index;
 	if (key.toArrayIndex(index) && index != 0xFFFFFFFFU) {
@@ -1754,6 +1846,12 @@ template<class SUPER> bool LazyJSObject<SUPER>::setOwnProperty(Runtime& rt, cons
 	return getCompleteObject(rt)->setOwnProperty(rt, key, v, flags);
 }
 
+#if (NUXJS_ES5)
+template<class SUPER> bool LazyJSObject<SUPER>::setOwnProperty(Runtime& rt, const String* key, const Value& v, Flags flags) {
+	return getCompleteObject(rt)->setOwnProperty(rt, key, v, flags);
+}
+#endif
+
 template<class SUPER> bool LazyJSObject<SUPER>::deleteOwnProperty(Runtime& rt, const Value& key) {
 	return getCompleteObject(rt)->deleteOwnProperty(rt, key);
 }
@@ -1828,6 +1926,14 @@ void Error::updateReflection(Runtime& rt) {
 	message = (getProperty(rt, &MESSAGE_STRING, &v) != NONEXISTENT ? v.toString(rt.getHeap()) : 0);
 }
 
+#if (NUXJS_ES5)
+bool Error::setOwnProperty(Runtime& rt, const String* key, const Value& v, Flags flags) {
+	const bool result = super::setOwnProperty(rt, key, v, flags);
+	updateReflection(rt);
+	return result;
+}
+#endif
+
 bool Error::setOwnProperty(Runtime& rt, const Value& key, const Value& v, Flags flags) {
 	const bool result = super::setOwnProperty(rt, key, v, flags);
 	updateReflection(rt);
@@ -1850,7 +1956,11 @@ void Error::constructCompleteObject(Runtime& rt) const {
 
 Arguments::Arguments(GCList& gcList, const FunctionScope* scope, UInt32 argumentsCount) : super(gcList)
 	, scope(scope), function(scope->function), argumentsCount(argumentsCount)
-	   , deletedArguments(argumentsCount, &gcList.getHeap()), values(0, &gcList.getHeap()) {
+	, deletedArguments(argumentsCount, &gcList.getHeap()), values(0, &gcList.getHeap())
+#if (NUXJS_ES5)
+	, owner(const_cast<FunctionScope*>(scope))
+#endif
+{
 	std::fill(deletedArguments.begin(), deletedArguments.end(), false);
 }
 
@@ -1884,6 +1994,12 @@ Flags Arguments::getOwnProperty(Runtime& rt, const Value& key, Value* v) const {
 	return (p == 0 ? super::getOwnProperty(rt, key, v) : ((void)(*v = *p), (DONT_ENUM_FLAG | EXISTS_FLAG)));
 }
 
+#if (NUXJS_ES5)
+bool Arguments::setOwnProperty(Runtime& rt, const String* key, const Value& v, Flags flags) {
+	return setOwnProperty(rt, Value(key), v, flags);
+}
+#endif
+
 bool Arguments::setOwnProperty(Runtime& rt, const Value& key, const Value& v, Flags flags) {
 	Value* p = findProperty(key);
 	if (p != 0 && (flags & (READ_ONLY_FLAG | DONT_ENUM_FLAG | DONT_DELETE_FLAG)) != 0) {
@@ -1909,11 +2025,19 @@ void Arguments::constructCompleteObject(Runtime& rt) const {
 	completeObject->setOwnProperty(rt, &CALLEE_STRING, function, DONT_ENUM_FLAG);
 }
 
+#if (NUXJS_ES5)
+Arguments::~Arguments() {
+	if (owner != 0) {
+		owner->arguments = 0;
+	}
+}
+	#else
 Arguments::~Arguments() {
 	if (scope != 0) {
 		scope->arguments = 0;
 	}
 }
+#endif
 
 /* --- Scope --- */
 
@@ -1961,13 +2085,28 @@ FunctionScope::FunctionScope(GCList& gcList, JSFunction* function, UInt32 argc,
 	if (code->getArgumentsCount() > argc) {
 		std::fill(e, locals.end(), UNDEFINED_VALUE);
 	}
+			#if (NUXJS_ES5)
+	if (code->strict) {
+		Heap& heap = gcList.getHeap();
+		arguments = new(heap) Arguments(heap.managed(), this, passedArgumentsCount);
+		arguments->detach();
+	}
+#endif
+
 }
 
 JSObject* FunctionScope::getDynamicVars(Runtime& rt) const {
 	if (dynamicVars == 0) {
 		Heap& heap = rt.getHeap();
 		dynamicVars = new(heap) JSObject(heap.managed(), 0);
+		if (arguments == 0) {
 			arguments = new(heap) Arguments(heap.managed(), this, passedArgumentsCount);
+		#if (NUXJS_ES5)
+			if (function->code->strict) {
+				arguments->detach();
+			}
+		#endif
+		}
 		dynamicVars->setOwnProperty(rt, &ARGUMENTS_STRING, arguments, DONT_DELETE_FLAG);
 	}
 	return dynamicVars;
@@ -2062,6 +2201,9 @@ void FunctionScope::declareVar(Runtime& rt, const String* name, const Value& ini
 
 FunctionScope::~FunctionScope() {
 	if (arguments != 0) {
+			#if (NUXJS_ES5)
+		arguments->owner = 0;
+			#endif
 		arguments->detach();
 		arguments = 0;
 	}
@@ -2095,10 +2237,15 @@ static struct EvalFunction : public Function {
 
 		Heap& heap = rt.getHeap();
 		const String* expression = argv[0].toString(heap);
+			#if (NUXJS_ES5)
+		const bool strict = direct && processor.isCurrentStrict();
+		processor.enterEvalCode(rt.compileEvalCode(expression, strict), direct);
+	#else
 		processor.enterEvalCode(rt.compileEvalCode(expression), direct);
+			#endif
 		return UNDEFINED_VALUE;
-	}
-	bool direct;
+}
+bool direct;
 } EVAL_FUNCTION(false), DIRECT_EVAL_FUNCTION(true);
 
 /* --- Processor --- */
@@ -2119,6 +2266,10 @@ const Processor::OpcodeInfo Processor::opcodeInfo[Processor::OP_COUNT] = {
 	{ SET_PROPERTY_OP			 , "SET_PROPERTY"			 , -2	  , 0 },
 	{ SET_PROPERTY_POP_OP		 , "SET_PROPERTY_POP"		 , -3	  , 0 },
 	{ ADD_PROPERTY_OP						 , "ADD_PROPERTY"						 , -1	  , 0 },
+#if (NUXJS_ES5)
+	{ ADD_GETTER_OP					   , "ADD_GETTER"						  , -1	   , 0 },
+	{ ADD_SETTER_OP					   , "ADD_SETTER"						  , -1	   , 0 },
+#endif
 	{ PUSH_ELEMENTS_OP			 , "PUSH_ELEMENTS_OP"		 , 0	  , OpcodeInfo::POP_OPERAND },
 	{ OBJ_TO_PRIMITIVE_OP		 , "OBJ_TO_PRIMITIVE"		 , 0	  , 0 },
 	{ OBJ_TO_NUMBER_OP			 , "OBJ_TO_NUMBER"			 , 0	  , 0 },
@@ -2200,13 +2351,62 @@ const Processor::OpcodeInfo& Processor::getOpcodeInfo(const Opcode opcode) {
 	This is the direct scope of an eval(), it only bridges all virtuals to the parent FunctionScope, but has a different
 	code pointer (for constants etc) and it declares deletable vars.
 */
+#if (NUXJS_ES5)
 struct Processor::EvalScope : public Scope {
-	typedef Scope super;
-	EvalScope(GCList& gcList, Scope* parentScope) : super(gcList, parentScope) { }
-	virtual void declareVar(Runtime& rt, const String* name, const Value& initValue, bool) {
-		parentScope->declareVar(rt, name, initValue, false);
-	}
+typedef Scope super;
+EvalScope(GCList& gcList, Scope* parentScope, bool isolated) : super(gcList, parentScope), vars(0), isolated(isolated) { }
+virtual Flags readVar(Runtime& rt, const String* name, Value* v) const {
+if (isolated && vars != 0) {
+const Flags flags = vars->getOwnProperty(rt, name, v);
+if (flags != NONEXISTENT) {
+return flags;
+}
+}
+return parentScope->readVar(rt, name, v);
+}
+virtual void writeVar(Runtime& rt, const String* name, const Value& value) {
+if (isolated && vars != 0) {
+Value tmp;
+if (vars->getOwnProperty(rt, name, &tmp) != NONEXISTENT) {
+vars->setOwnProperty(rt, name, value);
+return;
+}
+}
+parentScope->writeVar(rt, name, value);
+}
+virtual bool deleteVar(Runtime& rt, const String* name) {
+if (isolated && vars != 0 && vars->deleteOwnProperty(rt, name)) {
+return true;
+}
+return parentScope->deleteVar(rt, name);
+}
+virtual void declareVar(Runtime& rt, const String* name, const Value& initValue, bool dontDelete) {
+if (isolated) {
+if (vars == 0) {
+Heap& heap = rt.getHeap();
+vars = new(heap) JSObject(heap.managed(), 0);
+}
+vars->setOwnProperty(rt, name, initValue.isUndefined() ? UNDEFINED_VALUE : initValue, dontDelete ? DONT_DELETE_FLAG : 0);
+} else {
+parentScope->declareVar(rt, name, initValue, false);
+}
+}
+JSObject* vars;
+bool isolated;
+virtual void gcMarkReferences(Heap& heap) const {
+gcMark(heap, vars);
+super::gcMarkReferences(heap);
+}
+};
+#else
+struct Processor::EvalScope : public Scope {
+typedef Scope super;
+EvalScope(GCList& gcList, Scope* parentScope) : super(gcList, parentScope) { }
+virtual void declareVar(Runtime& rt, const String* name, const Value& initValue, bool) {
+parentScope->declareVar(rt, name, initValue, false);
+}
 };
+#endif
 	
 /*
 	The CatchScope is necessary because within a catch block there is a single extra variable that is local to the catch
@@ -2313,7 +2513,12 @@ void Processor::enter(const Code* code, Scope* scope, Object* thisObject) {
 	if (sp + code->getMaxStackDepth() > stack.end()) {
 		ScriptException::throwError(heap, RANGE_ERROR, &STACK_OVERFLOW_STRING); // Notice: we can't use virtual throw here, cause we need to abort any sp changes etc that could happen if we continued execution beyond this point.
 	} else {
+#if (NUXJS_ES5)
+		Object* obj = (thisObject == 0 && !code->isStrict() ? rt.getGlobalObject() : thisObject);
+		pushFrame(code, scope, obj);
+#else
 		pushFrame(code, scope, (thisObject == 0 ? rt.getGlobalObject() : thisObject));
+#endif
 		ip = code->getCodeWords();
 	}
 }
@@ -2326,6 +2531,16 @@ void Processor::enterGlobalCode(const Code* code) {
 	enter(code, rt.getGlobalScope(), rt.getGlobalObject());
 }
 
+#if (NUXJS_ES5)
+void Processor::enterEvalCode(const Code* code, bool direct) {
+		bool isolate = direct && code->isStrict();
+		if (direct && currentFrame != 0) {
+			enter(code, new(heap) Processor::EvalScope(heap.managed(), currentFrame->scope, isolate), currentFrame->thisObject);
+		} else {
+			enter(code, new(heap) Processor::EvalScope(heap.managed(), rt.getGlobalScope(), isolate), rt.getGlobalObject());
+		}
+}
+#else
 void Processor::enterEvalCode(const Code* code, bool local) {
 		if (local && currentFrame != 0) {
 			enter(code, new(heap) Processor::EvalScope(heap.managed(), currentFrame->scope), currentFrame->thisObject);
@@ -2333,6 +2548,8 @@ void Processor::enterEvalCode(const Code* code, bool local) {
 			enter(code, new(heap) Processor::EvalScope(heap.managed(), rt.getGlobalScope()), rt.getGlobalObject());
 		}
 }
+#endif
+
 
 void Processor::enterFunctionCode(JSFunction* func, UInt32 argc, const Value* argv, Object* thisObject) {
 	enter(func->code, new(heap) FunctionScope(heap.managed(), func, argc, argv), thisObject);
@@ -2407,7 +2624,12 @@ void Processor::newOperation(const Int32 argc) {
 	Function* f = asFunction(sp[-argc]);
 	if (f != 0) { // FIX : sub
 		Value v(UNDEFINED_VALUE);
+#if (NUXJS_ES5)
+		Function* target = f->getConstructTarget();
+		target->getProperty(rt, &PROTOTYPE_STRING, &v);
+#else
 		f->getProperty(rt, &PROTOTYPE_STRING, &v);
+#endif
 		Object* prototype = v.asObject();
 		Int32 counter = 0;
 		for (Object* p = prototype; p != 0; p = p->getPrototype(rt)) {
@@ -2451,41 +2673,98 @@ void Processor::innerRun() {
 				}
 			}
 			break;
-			case WRITE_NAMED_OP:		scope->writeVar(rt, constants[im].getString(), sp[0]); break;
-			case WRITE_NAMED_POP_OP:	scope->writeVar(rt, constants[im].getString(), sp[0]); pop(1); break;
-
-			case GET_PROPERTY_OP: {
-				const Object* o = convertToObject(sp[-1], false);
-				if (o == 0) {
+			case WRITE_NAMED_OP: {
+				const String* name = constants[im].getString();
+			#if (NUXJS_ES5)
+				if (code->isStrict()) {
+					Value dummy;
+					if (scope->readVar(rt, name, &dummy) == NONEXISTENT) {
+						error(REFERENCE_ERROR, new(heap) String(heap.managed(), *name, IS_NOT_DEFINED_STRING));
 						return;
 					}
-				if (o->getProperty(rt, sp[0], sp - 1) == NONEXISTENT) {
-					sp[-1] = UNDEFINED_VALUE;
 				}
-				pop(1);
-				break;
+			#endif
+				scope->writeVar(rt, name, sp[0]);
 			}
-			
-			case SET_PROPERTY_OP: {
-				Object* o = convertToObject(sp[-2], false);
-				if (o == 0) {
+			break;
+			case WRITE_NAMED_POP_OP: {
+				const String* name = constants[im].getString();
+			#if (NUXJS_ES5)
+				if (code->isStrict()) {
+					Value dummy;
+					if (scope->readVar(rt, name, &dummy) == NONEXISTENT) {
+						error(REFERENCE_ERROR, new(heap) String(heap.managed(), *name, IS_NOT_DEFINED_STRING));
 						return;
 					}
-				o->setProperty(rt, sp[-1], sp[0]);
-				sp[-2] = sp[0];
-				pop(2);
-				break;
 				}
-			
-			case SET_PROPERTY_POP_OP: {
-				Object* o = convertToObject(sp[-2], false);
-				if (o == 0) {
-					return;
+			#endif
+				scope->writeVar(rt, name, sp[0]);
+				pop(1);
 			}
-				o->setProperty(rt, sp[-1], sp[0]);
-				pop(3);
 			break;
-			}
+case GET_PROPERTY_OP: {
+const Object* o = convertToObject(sp[-1], false);
+if (o == 0) {
+return;
+}
+#if (NUXJS_ES5)
+Flags f = o->getProperty(rt, *this, sp[0], sp - 1);
+#else
+Flags f = o->getProperty(rt, sp[0], sp - 1);
+#endif
+if (f == NONEXISTENT) {
+sp[-1] = UNDEFINED_VALUE;
+pop(1);
+break;
+}
+pop(1);
+if ((f & ACCESSOR_FLAG) != 0) {
+return;
+}
+break;
+}
+
+			
+case SET_PROPERTY_OP: {
+Object* o = convertToObject(sp[-2], false);
+if (o == 0) {
+return;
+}
+Value v = sp[0];
+#if (NUXJS_ES5)
+bool acc = o->setProperty(rt, *this, sp[-1], sp[0]);
+sp[-2] = v;
+pop(2);
+if (acc) {
+return;
+}
+#else
+o->setProperty(rt, sp[-1], sp[0]);
+sp[-2] = v;
+pop(2);
+#endif
+break;
+}
+
+
+case SET_PROPERTY_POP_OP: {
+Object* o = convertToObject(sp[-2], false);
+if (o == 0) {
+return;
+}
+#if (NUXJS_ES5)
+bool acc = o->setProperty(rt, *this, sp[-1], sp[0]);
+pop(3);
+if (acc) {
+return;
+}
+#else
+o->setProperty(rt, sp[-1], sp[0]);
+pop(3);
+#endif
+break;
+}
+
 
 			case OBJ_TO_PRIMITIVE_OP:
 			case OBJ_TO_NUMBER_OP:
@@ -2596,7 +2875,7 @@ void Processor::innerRun() {
 			case NEW_ARRAY_OP: push(new(heap) JSArray(heap.managed())); break;
 			case NEW_REG_EXP_OP: invokeFunction(rt.createRegExpFunction, 1, 2); return;
 			case RETURN_OP: ip = currentFrame->returnIP; popFrame(); return;
-			case THIS_OP: push(thisObject); break;
+case THIS_OP: push(thisObject != 0 ? Value(thisObject) : UNDEFINED_VALUE); break;
 			case VOID_OP: push(UNDEFINED_VALUE); break;
 			
 			case GEN_FUNC_OP: {
@@ -2615,6 +2894,22 @@ void Processor::innerRun() {
 				pop(1);
 				break;
 			}
+#if (NUXJS_ES5)
+			case ADD_GETTER_OP: {
+				Object* o = sp[-1].getObject();
+				Accessor* acc = new(heap) Accessor(heap.managed(), sp[0].asFunction(), 0);
+				o->setOwnProperty(rt, constants[im], acc, ACCESSOR_FLAG);
+				pop(1);
+				break;
+			}
+			case ADD_SETTER_OP: {
+				Object* o = sp[-1].getObject();
+				Accessor* acc = new(heap) Accessor(heap.managed(), 0, sp[0].asFunction());
+				o->setOwnProperty(rt, constants[im], acc, ACCESSOR_FLAG);
+				pop(1);
+				break;
+			}
+#endif
 
 			case PUSH_ELEMENTS_OP: {
 				Object* o = sp[-im].getObject();
@@ -3123,7 +3418,13 @@ const String* Compiler::identifier(bool required, bool allowKeywords) {
 		if (!allowKeywords && findReservedKeyword(parsed.size(), parsed.begin()) >= 0) {
 				error(SYNTAX_ERROR, "Illegal use of keyword");
 		}
-	return newHashedString(heap, parsed.begin(), parsed.end());
+			   const String* name = newHashedString(heap, parsed.begin(), parsed.end());
+	   #if (NUXJS_ES5)
+			   if (!allowKeywords && code->isStrict() && name->isEqualTo(EVAL_STRING)) {
+							   error(SYNTAX_ERROR, "Illegal use of eval or arguments in strict code");
+			   }
+	   #endif
+			   return name;
 }
 
 static UInt32 unescapedMaxLength(const Char* p, const Char* e) {
@@ -3367,17 +3668,40 @@ Compiler::ExpressionResult Compiler::objectInitialiser() { // FIX : share stuff
 	
 	white();
 	while (!token("}", false)) {
+		bool handled = false;
 		const Char* b = p;
 		Value key = stringOrNumberConstant();
 		if (p == b) {
-			key = identifier(false, true);
-			if (key.equalsString(EMPTY_STRING)) {
+			const String* id = identifier(false, true);
+			if (id->isEqualTo(EMPTY_STRING)) {
 			error(SYNTAX_ERROR, "Expected property name");
 			}
+			white();
+#if (NUXJS_ES5)
+				if ((id->isEqualTo(GET_STRING) || id->isEqualTo(SET_STRING)) && *p != ':') {
+				bool isGetter = id->isEqualTo(GET_STRING);
+				const Char* b2 = p;
+				Value accKey = stringOrNumberConstant();
+				if (p == b2) {
+				accKey = identifier(true, true);
+				}
+				white();
+				const String* funcName = accKey.toString(heap);
+				functionDefinition(funcName, funcName);
+				emitWithConstant(isGetter ? Processor::ADD_GETTER_OP : Processor::ADD_SETTER_OP, accKey);
+				handled = true;
+		} else {
+				key = id;
+		}
+#else
+				key = id;
+#endif
 			}
+		if (!handled) {
 				expectToken(":", true);
 				rvalueExpression(COMMA_PREC);
 				emitWithConstant(Processor::ADD_PROPERTY_OP, key);
+		}
 			if (token("}", true)) {
 				break;
 			}
@@ -3459,8 +3783,23 @@ bool Compiler::preOperate(ExpressionResult& xr, Precedence precedence) {
 				case ExpressionResult::PUSHED_PRIMITIVE: emit(Processor::POP_OP, 1); /* fall through */
 				case ExpressionResult::NONE:
 				case ExpressionResult::CONSTANT: xr = ExpressionResult(ExpressionResult::CONSTANT, true); break;
-				case ExpressionResult::LOCAL: xr = ExpressionResult(ExpressionResult::CONSTANT, false); break;
-				case ExpressionResult::NAMED: emitWithConstant(Processor::DELETE_NAMED_OP, xr.v); xr = ExpressionResult(ExpressionResult::PUSHED_PRIMITIVE); break;
+				case ExpressionResult::LOCAL:
+				#if (NUXJS_ES5)
+					if (code->isStrict()) {
+						error(SYNTAX_ERROR, "Deleting identifier in strict code");
+					}
+				#endif
+					xr = ExpressionResult(ExpressionResult::CONSTANT, false);
+					break;
+				case ExpressionResult::NAMED:
+				#if (NUXJS_ES5)
+					if (code->isStrict()) {
+						error(SYNTAX_ERROR, "Deleting identifier in strict code");
+					}
+				#endif
+					emitWithConstant(Processor::DELETE_NAMED_OP, xr.v);
+					xr = ExpressionResult(ExpressionResult::PUSHED_PRIMITIVE);
+					break;
 				case ExpressionResult::PROPERTY: emit(Processor::DELETE_OP); xr = ExpressionResult(ExpressionResult::PUSHED_PRIMITIVE); break;
 				default: assert(0);
 			}
@@ -3665,6 +4004,9 @@ bool Compiler::postOperate(ExpressionResult& xr, Precedence precedence) {
 void Compiler::functionDefinition(const String* functionName, const String* selfName) {
 	assert(functionName != 0);
 	Code* func = new(heap) Code(heap.managed(), code->constants);
+#if (NUXJS_ES5)
+	func->strict = code->strict;
+#endif
 	Compiler funcCompiler(heap.roots(), func, Compiler::FOR_FUNCTION, nestCounter);
 	try {
 		p = funcCompiler.compileFunction(p, e, functionName, selfName);
@@ -3819,6 +4161,11 @@ void Compiler::rvalueGroup() {
 
 // FIX : ok, this is serious mess
 Compiler::ExpressionResult Compiler::declareIdentifier(const String* name, bool func) {
+			#if (NUXJS_ES5)
+	if (code->isStrict() && (name->isEqualTo(EVAL_STRING) || name->isEqualTo(ARGUMENTS_STRING))) {
+		error(SYNTAX_ERROR, "Illegal use of eval or arguments in strict code");
+	}
+#endif
 	ExpressionResult lxr(ExpressionResult::NAMED, name);
 	if (compilingFor != FOR_FUNCTION) {
 		CodeSection* previousSection = changeSection(&setupSection);
@@ -3974,6 +4321,11 @@ void Compiler::functionStatement() {
 }
 
 void Compiler::withStatement(SemanticScope* currentScope) {
+			#if (NUXJS_ES5)
+	if (code->isStrict()) {
+		error(SYNTAX_ERROR, "\"with\" is not allowed in strict code");
+	}
+#endif
 	rvalueGroup();
 	emit(Processor::WITH_SCOPE_OP);
 	{
@@ -4461,6 +4813,36 @@ const Char* Compiler::compile(const Char* b, const Char* e) {
 	p = b;
 	this->e = e;
 	acceptInOperator = true;
+	   #if (NUXJS_ES5)
+	   const Char* directiveStart = p;
+	   white();
+	   bool foundStrict = false;
+	   while (p < e && (*p == '"' || *p == '\'')) {
+			   Char q = *p++;
+			   const Char* litStart = p;
+			   while (p < e && *p != q) {
+					   ++p;
+			   }
+			   if (p >= e) {
+					   break;
+			   }
+			   if (!foundStrict && p - litStart == 10 && strncmp(litStart, "use strict", 10) == 0) {
+					   foundStrict = true;
+			   }
+			   ++p;
+			   white();
+			   if (p < e && *p == ';') {
+					   ++p;
+					   white();
+					   continue;
+			   }
+			   break;
+	   }
+	   if (foundStrict) {
+			   code->setStrict(true);
+	   }
+	   p = directiveStart;
+	   #endif
 	
 	// FIX : not 100% necessary now because we should always start with undefined on top of stack
 	if (compilingFor == FOR_EVAL) {
@@ -4496,6 +4878,9 @@ const Char* Compiler::compileFunction(const Char* b, const Char* e, const String
 	white();
 	Table& nameIndexes = code->nameIndexes;
 	   Vector<const String*>& argumentNames = code->argumentNames;
+	   #if (NUXJS_ES5)
+	   bool hasDuplicateParameters = false;
+	   #endif
 	   while (!token(")", false)) {
 		if (eof()) {
 			error(SYNTAX_ERROR, argumentNames.size() == 0 ? "Expected ')'" : "Expected ',' or ')'");
@@ -4507,6 +4892,19 @@ const Char* Compiler::compileFunction(const Char* b, const Char* e, const String
 			white();
 		}
 			const String* name = identifier(true, false);
+		#if (NUXJS_ES5)
+			if (code->isStrict() && (name->isEqualTo(EVAL_STRING) || name->isEqualTo(ARGUMENTS_STRING))) {
+				error(SYNTAX_ERROR, "Illegal use of eval or arguments in strict code");
+			}
+		#endif
+			   #if (NUXJS_ES5)
+			   for (size_t i = 0; i < argumentNames.size(); ++i) {
+					   if (argumentNames[i]->isEqualTo(*name)) {
+							   hasDuplicateParameters = true;
+							   break;
+					   }
+			   }
+			   #endif
 			   nameIndexes.update(nameIndexes.insert(name), static_cast<Int32>(argumentNames.size()));
 			   argumentNames.push(name);
 			   code->bloomSet |= name->createBloomCode();
@@ -4515,6 +4913,11 @@ const Char* Compiler::compileFunction(const Char* b, const Char* e, const String
 	expectToken("{", true);
 	compile(p, e); // FIX: ugly as it sets p and e again, although it doesn't hurt
 	expectToken("}", false);
+	   #if (NUXJS_ES5)
+	   if (code->strict && hasDuplicateParameters) {
+			   error(SYNTAX_ERROR, "Duplicate parameter name not allowed in strict code");
+	   }
+	   #endif
 	code->name = functionName;
 	code->selfName = selfName;
 	code->source = String::concatenate(heap, String(heap.roots(), FUNCTION_SPACE, *functionName), String(heap.roots(), b, p));
@@ -4655,6 +5058,104 @@ void SeparateConstructorFunction::constructCompleteObject(Runtime& rt) const {
 		}
 }
 
+#if (NUXJS_ES5)
+struct BoundFunction : public ExtensibleFunction {
+		typedef ExtensibleFunction super;
+
+		BoundFunction(GCList& gc,
+						Function* target,
+						const Value& boundThis,
+						UInt32 boundArgc,
+						const Value* boundArgv);
+
+		virtual Value invoke(Runtime& rt, Processor& proc,
+						UInt32 argc, const Value* argv, Object* thisObj);
+
+		virtual Value construct(Runtime& rt, Processor& proc,
+				UInt32 argc, const Value* argv, Object* thisObj);
+
+		virtual bool hasInstance(Runtime& rt, Object* object) const;
+		virtual Function* getConstructTarget();
+
+protected:
+		virtual void constructCompleteObject(Runtime& rt) const;
+		virtual void gcMarkReferences(Heap& heap) const;
+
+private:
+		Function* const target;
+		Value		   boundThis;
+		UInt32		   boundArgc;
+		Value*		   boundArgv;	 /// GC-managed array of pre-bound args
+};
+
+BoundFunction::BoundFunction(GCList& gc,
+				Function* target,
+				const Value& boundThis,
+				UInt32 boundArgc,
+				const Value* boundArgv)
+		: super(gc), target(target), boundThis(boundThis), boundArgc(boundArgc), boundArgv(0) {
+		if (boundArgc > 0) {
+				Heap& heap = gc.getHeap();
+				Value* argvCopy = new(&heap) Value[boundArgc];
+				std::copy(boundArgv, boundArgv + boundArgc, argvCopy);
+				this->boundArgv = argvCopy;
+		}
+}
+
+Value BoundFunction::invoke(Runtime& rt, Processor& proc,
+UInt32 argc, const Value* argv, Object* thisObj) {
+VarList args(rt, boundArgc + argc);
+if (boundArgc > 0) {
+std::copy(boundArgv, boundArgv + boundArgc, args.begin());
+}
+std::copy(argv, argv + argc, args.begin() + boundArgc);
+Object* thisObject = boundThis.toObjectOrNull(rt.getHeap(), false);
+return target->invoke(rt, proc, boundArgc + argc, args.begin(), thisObject);
+}
+
+Value BoundFunction::construct(Runtime& rt, Processor& proc,
+UInt32 argc, const Value* argv, Object* thisObj) {
+VarList args(rt, boundArgc + argc);
+if (boundArgc > 0) {
+std::copy(boundArgv, boundArgv + boundArgc, args.begin());
+}
+std::copy(argv, argv + argc, args.begin() + boundArgc);
+return target->construct(rt, proc, boundArgc + argc, args.begin(), thisObj);
+}
+
+bool BoundFunction::hasInstance(Runtime& rt, Object* object) const {
+		return target->hasInstance(rt, object);
+}
+
+Function* BoundFunction::getConstructTarget() {
+		return target->getConstructTarget();
+}
+
+void BoundFunction::constructCompleteObject(Runtime& rt) const {
+		Value v;
+		Flags flags = target->getProperty(rt, &NAME_STRING, &v);
+		if (flags != NONEXISTENT) {
+				completeObject->setOwnProperty(rt, &NAME_STRING, v, flags);
+		}
+		flags = target->getProperty(rt, &LENGTH_STRING, &v);
+		double l = 0;
+		if (flags != NONEXISTENT) {
+				l = v.toDouble() - boundArgc;
+				if (l < 0) l = 0;
+		}
+		completeObject->setOwnProperty(rt, &LENGTH_STRING, Value(l), HIDDEN_CONST_FLAGS);
+}
+
+void BoundFunction::gcMarkReferences(Heap& heap) const {
+gcMark(heap, target);
+gcMark(heap, boundThis);
+if (boundArgc > 0) {
+gcMark(heap, boundArgv, boundArgv + boundArgc);
+}
+super::gcMarkReferences(heap);
+}
+#endif
+
 template<class F> struct UnaryMathFunction : public Function {
 	UnaryMathFunction(F& f) : f(f) { }
 	virtual Value invoke(Runtime&, Processor&, UInt32 argc, const Value* argv, Object*) {
@@ -4729,22 +5230,46 @@ struct Support {
 		return UNDEFINED_VALUE;
 	}
 
-	static Value defineProperty(Runtime& rt, Processor&, UInt32 argc, const Value* argv, Object*) {
+static Value defineProperty(Runtime &rt, Processor &, UInt32 argc, const Value *argv, Object *) {
 		bool success = false;
 		if (argc >= 2) {
-			Object* o = argv[0].asObject();
+			Object *o = argv[0].asObject();
 			if (o != 0) {
-				success = o->setOwnProperty(rt, argv[1], (argc >= 3 ? argv[2] : UNDEFINED_VALUE)
-						, (argc >= 4 && argv[3].toBool() ? READ_ONLY_FLAG : 0)
-						| (argc >= 5 && argv[4].toBool() ? DONT_ENUM_FLAG : 0)
-						| (argc >= 6 && argv[5].toBool() ? DONT_DELETE_FLAG : 0)
-						| EXISTS_FLAG);
+Flags flags = (argc >= 4 && argv[3].toBool() ? READ_ONLY_FLAG : 0) |
+(argc >= 5 && argv[4].toBool() ? DONT_ENUM_FLAG : 0) |
+(argc >= 6 && argv[5].toBool() ? DONT_DELETE_FLAG : 0) | EXISTS_FLAG;
+#if (NUXJS_ES5)
+if (argc >= 7) {
+Heap &heap = rt.getHeap();
+Accessor *acc = new (heap)
+Accessor(heap.managed(), argv[6].asFunction(), (argc >= 8 ? argv[7].asFunction() : 0));
+success = o->setOwnProperty(rt, argv[1], acc, flags | ACCESSOR_FLAG);
+} else {
+success = o->setOwnProperty(rt, argv[1], (argc >= 3 ? argv[2] : UNDEFINED_VALUE), flags);
+}
+#else
+success = o->setOwnProperty(rt, argv[1], (argc >= 3 ? argv[2] : UNDEFINED_VALUE), flags);
+#endif
 			}
 		}
 		return success;
+}
+
+#if (NUXJS_ES5)
+static Value bind(Runtime& rt, Processor&, UInt32 argc, const Value* argv, Object*) {
+	if (argc >= 2) {
+		Function* target = argv[0].asFunction();
+		if (target != 0) {
+			Heap& heap = rt.getHeap();
+			UInt32 boundArgc = (argc > 2 ? argc - 2 : 0);
+			return new(heap) BoundFunction(heap.managed(), target, argv[1], boundArgc, argv + 2);
+		}
 	}
+	return UNDEFINED_VALUE;
+}
+#endif
 
-	static Value compileFunction(Runtime& rt, Processor&, UInt32 argc, const Value* argv, Object*) {
+static Value compileFunction(Runtime& rt, Processor&, UInt32 argc, const Value* argv, Object*) {
 		if (argc >= 1) {
 			Heap& heap = rt.getHeap();
 			const String* source = argv[0].toString(heap);
@@ -4908,8 +5433,11 @@ static struct {
 	FunctorAdapter<NativeFunction> func;
 } SUPPORT_FUNCTIONS[] = {
 	{ "getInternalProperty", Support::getInternalProperty }, { "createWrapper", Support::createWrapper },
-	{ "defineProperty", Support::defineProperty }, { "compileFunction", Support::compileFunction },
-	{ "distinctConstructor", Support::distinctConstructor }, { "callWithArgs", Support::callWithArgs },
+	{ "defineProperty", Support::defineProperty },
+#if (NUXJS_ES5)
+	{ "bind", Support::bind },
+#endif
+	{ "compileFunction", Support::compileFunction }, { "distinctConstructor", Support::distinctConstructor }, { "callWithArgs", Support::callWithArgs },
 	{ "hasOwnProperty", Support::hasOwnProperty }, { "fromCharCode", Support::fromCharCode },
 	{ "isPropertyEnumerable", Support::isPropertyEnumerable }, { "atan2", Support::atan2 },
 	{ "pow", Support::pow }, { "parseFloat", Support::parseFloat }, { "charCodeAt", Support::charCodeAt },
@@ -5058,6 +5586,24 @@ Var Runtime::eval(const String& expression) {
 	return runUntilReturn(processor);
 }
 
+// Guarded: ES5 adds strict-flag support and conditional caching
+#if (NUXJS_ES5)
+Code* Runtime::compileEvalCode(const String* expression, bool strict) {
+	const Table::Bucket* bucket = (strict ? 0 : evalCodeCache.lookup(expression));
+		if (bucket != 0) {
+		Object* o = bucket->getValue().getObject();
+		assert(dynamic_cast<Code*>(o) != 0);
+		return reinterpret_cast<Code*>(o);
+	} else {
+		Code* code = new(heap) Code(heap.managed());
+		if (strict) { code->setStrict(true); }
+		Compiler compiler(heap.roots(), code, Compiler::FOR_EVAL);
+		compiler.compile(*expression);
+		if (!strict) { evalCodeCache.update(evalCodeCache.insert(expression), code); }
+		return code;
+	}
+	}
+#else
 Code* Runtime::compileEvalCode(const String* expression) {
 	const Table::Bucket* bucket = evalCodeCache.lookup(expression);
 		if (bucket != 0) {
@@ -5071,7 +5617,9 @@ Code* Runtime::compileEvalCode(const String* expression) {
 		evalCodeCache.update(evalCodeCache.insert(expression), code);
 		return code;
 		}
-}
+	}
+#endif
+
 
 Code* Runtime::compileGlobalCode(const String& source, const String* filename) {
 	Code* code = new(heap) Code(heap.managed());
@@ -5094,6 +5642,9 @@ void Runtime::fetchFunction(const Object* supportObject, const char* name, Funct
 }
 
 extern const char* STDLIB_JS;
+			#if (NUXJS_ES5)
+extern const char* STDLIB_ES5_JS;
+#endif
 
 double Runtime::getCurrentEpochTime() {
 	std::time_t t;
@@ -5126,6 +5677,7 @@ void Runtime::setupStandardLibrary() {
 	supportObject->setOwnProperty(*this, &UNDEFINED_STRING, UNDEFINED_VALUE);
 	supportObject->setOwnProperty(*this, &NAN_STRING, NAN_VALUE);
 	supportObject->setOwnProperty(*this, &INFINITY_STRING, INFINITY_VALUE);
+
 	supportObject->setOwnProperty(*this, &MAX_NUMBER_STRING, std::numeric_limits<double>::max());
 	supportObject->setOwnProperty(*this, &MIN_NUMBER_STRING, std::numeric_limits<double>::denorm_min());
 
@@ -5138,8 +5690,12 @@ void Runtime::setupStandardLibrary() {
 	}
 	
 	const Var func = eval(*String::allocate(heap, STDLIB_JS));
-	Value argv[1] = { protectedSupportObject };
-	call(func, 1, argv);
+	Value argv[2] = { protectedSupportObject, UNDEFINED_VALUE };
+			#if (NUXJS_ES5)
+	const Var es5(*this, String::allocate(heap, STDLIB_ES5_JS));
+	argv[1] = es5;
+#endif
+	call(func, 2, argv);
 	
 	fetchFunction(supportObject, "toPrimitive", toPrimitiveFunctions + 0);
 	fetchFunction(supportObject, "toPrimitiveNumber", toPrimitiveFunctions + 1);
@@ -5162,12 +5718,12 @@ void Runtime::resetTimeOut(Int32 timeOutSeconds) {
 
 } /* namespace NuXJS */
 
-#ifdef __GNUC__
-#ifndef __clang__
+			#ifdef __GNUC__
+			#ifndef __clang__
 #pragma GCC pop_options
 #endif
 #endif
 
-#ifdef _MSC_VER
+			#ifdef _MSC_VER
 #pragma float_control(pop)	
 #endif
diff --git a/src/NuXJS.h b/src/NuXJS.h
index 98904d6..735ff89 100644
--- a/src/NuXJS.h
+++ b/src/NuXJS.h
@@ -24,6 +24,12 @@
 #ifndef NuXJS_h
 #define NuXJS_h
 
+// ---------------------------------------------------------------------------
+// ES version toggle
+//
+// Define `NUXJS_ES5` at build time to enable ES5 features; leave undefined for ES3.
+// ---------------------------------------------------------------------------
+
 #include "assert.h"
 #include <algorithm>
 #include <string>
@@ -105,7 +111,7 @@ class GCItem {
 	private:
 		static void* operator new[](size_t, Heap* heap); // N/A
 		static void operator delete[](void*); // N/A
-};
+		};
 
 /**
 	GCList is a simple intrusive list used by the garbage collector. Lists are double linked and contain a dummy node to
@@ -447,11 +453,19 @@ const Flags READ_ONLY_FLAG = 2;
 const Flags DONT_ENUM_FLAG = 4;
 const Flags DONT_DELETE_FLAG = 8;
 const Flags INDEX_TYPE_FLAG = 16;	///< internal index type, only used as an optimization for faster name -> local index lookup
+#if (NUXJS_ES5)
+const Flags ACCESSOR_FLAG = 32;		///< property stores accessor pair
+#else
+const Flags ACCESSOR_FLAG = 0;
+#endif
 const Flags STANDARD_FLAGS = EXISTS_FLAG;	///< use with setOwnProperty()
 const Flags HIDDEN_CONST_FLAGS = READ_ONLY_FLAG | DONT_ENUM_FLAG | DONT_DELETE_FLAG | EXISTS_FLAG;
 const Flags NONEXISTENT = 0;		///< use with getOwnProperty() to check for existence, e.g. getOwnProperty(o, k, v) != NONEXISTENT
 const UInt32 TABLE_BUILT_IN_N = 3; ///< 1 << 3 == 8
 
+#if (NUXJS_ES5)
+class Accessor;
+#endif
 /**
 	Table implements a hash table for storing object properties. It provides fast lookup and is used internally by JS
 	objects.
@@ -538,13 +552,22 @@ class Object : public GCItem {
 		virtual Object* getPrototype(Runtime& rt) const;		///< Default returns the Object prototype.
 
 		virtual Flags getOwnProperty(Runtime& rt, const Value& key, Value* v) const;								///< Don't touch v if you return NONEXISTENT. Default returns NONEXISTENT.
+#if (NUXJS_ES5)
+		virtual bool setOwnProperty(Runtime& rt, const String* key, const Value& v, Flags flags = STANDARD_FLAGS);	///< Insert a new or update an existing property. Return false if not possible (e.g. read-only property already exists). Default returns false.
+#endif
 		virtual bool setOwnProperty(Runtime& rt, const Value& key, const Value& v, Flags flags = STANDARD_FLAGS);	///< Insert a new or update an existing property. Return false if not possible (e.g. read-only property already exists). Default returns false.
 		virtual bool updateOwnProperty(Runtime& rt, const Value& key, const Value& v);								///< Update existing property. Return false if it doesn't exist or can't be updated (e.g. read-only property exists). Can be overriden for optimization. (Default implementation checks existence with hasOwnProperty() first.)
 		virtual bool deleteOwnProperty(Runtime& rt, const Value& key);												///< Default returns false.
 		virtual Enumerator* getOwnPropertyEnumerator(Runtime& rt) const;											///< Default returns an empty enumerator.
 
 		Flags getProperty(Runtime& rt, const Value& key, Value* v) const;	///< Searches prototype chain.
+#if (NUXJS_ES5)
+		Flags getProperty(Runtime& rt, Processor& processor, const Value& key, Value* v) const;
+#endif
 		bool setProperty(Runtime& rt, const Value& key, const Value& v);	///< First tries updateOwnProperty(). If that fails, checks prototype chain for read-only property with the same name and returns false if found. Otherwise attempts to insert a new property with setOwnProperty() and returns its outcome.
+#if (NUXJS_ES5)
+		bool setProperty(Runtime& rt, Processor& processor, const Value& key, const Value& v);
+#endif
 		bool isOwnPropertyEnumerable(Runtime& rt, const Value& key) const;
 		bool hasOwnProperty(Runtime& rt, const Value& key) const;			///< Checks via getOwnProperty().
 		bool hasProperty(Runtime& rt, const Value& key) const;				///< Checks via getProperty().
@@ -707,6 +730,9 @@ class JSObject : public Object, public Table {
 		JSObject(GCList& gcList, Object* prototype);
 		virtual Object* getPrototype(Runtime& rt) const;
 		virtual Flags getOwnProperty(Runtime& rt, const Value& key, Value* v) const;
+#if (NUXJS_ES5)
+		virtual bool setOwnProperty(Runtime& rt, const String* key, const Value& v, Flags flags = STANDARD_FLAGS);
+#endif
 		virtual bool setOwnProperty(Runtime& rt, const Value& key, const Value& v, Flags flags = STANDARD_FLAGS);
 		virtual bool updateOwnProperty(Runtime& rt, const Value& key, const Value& v);
 		virtual bool deleteOwnProperty(Runtime& rt, const Value& key);
@@ -742,6 +768,9 @@ template<class SUPER> class LazyJSObject : public SUPER {
 		typedef SUPER super;
 		LazyJSObject(GCList& gcList) : super(gcList), completeObject(0) { }
 		virtual Flags getOwnProperty(Runtime& rt, const Value& key, Value* v) const;
+#if (NUXJS_ES5)
+		virtual bool setOwnProperty(Runtime& rt, const String* key, const Value& v, Flags flags = STANDARD_FLAGS);
+#endif
 		virtual bool setOwnProperty(Runtime& rt, const Value& key, const Value& v, Flags flags = STANDARD_FLAGS);
 		virtual bool deleteOwnProperty(Runtime& rt, const Value& key);
 		virtual Enumerator* getOwnPropertyEnumerator(Runtime& rt) const;
@@ -773,6 +802,9 @@ class JSArray : public LazyJSObject<Object> {
 		virtual Object* getPrototype(Runtime& rt) const;
 		// FIX : toString too?
 		virtual Flags getOwnProperty(Runtime& rt, const Value& key, Value* v) const;
+#if (NUXJS_ES5)
+		virtual bool setOwnProperty(Runtime& rt, const String* key, const Value& v, Flags flags = STANDARD_FLAGS);
+#endif
 		virtual bool setOwnProperty(Runtime& rt, const Value& key, const Value& v, Flags flags = STANDARD_FLAGS);
 		virtual bool updateOwnProperty(Runtime& rt, const Value& key, const Value& v);
 		virtual bool deleteOwnProperty(Runtime& rt, const Value& key);
@@ -833,6 +865,13 @@ class Code : public Object {
 		const String* getName() const { return name; }
 		const String* getSource() const { return source; }
 			   UInt32 getMaxStackDepth() const { return maxStackDepth; }
+#if (NUXJS_ES5)
+			   bool isStrict() const { return strict; }
+			   void setStrict(bool v) { strict = v; }
+#else
+			   bool isStrict() const { return false; }
+			   void setStrict(bool) { }
+#endif
 			   UInt32 calcLocalsSize(UInt32 argc) const { return getVarsCount() + std::max(getArgumentsCount(), argc); }
 
 	protected:
@@ -846,6 +885,9 @@ class Code : public Object {
 		const String* source;
 		UInt32 bloomSet;							///< Bloom bits of all local variables, arguments (+ self name and "arguments"). For faster scope resolution.
 			   UInt32 maxStackDepth;
+#if (NUXJS_ES5)
+			   bool strict;
+#endif
 
 		virtual void gcMarkReferences(Heap& heap) const {
 			gcMark(heap, constants);
@@ -873,6 +915,9 @@ class Function : public Object {
 		virtual const String* toString(Heap& heap) const;
 		virtual Value getInternalValue(Heap& heap) const;
 			   virtual Object* getPrototype(Runtime& rt) const;
+#if (NUXJS_ES5)
+		virtual Function* getConstructTarget();
+#endif
 			   virtual Value construct(Runtime& rt, Processor& processor, UInt32 argc, const Value* argv, Object* thisObject);
 			   virtual bool hasInstance(Runtime& rt, Object* object) const;
 		virtual const Code* getScriptCode() const { return 0; }
@@ -883,6 +928,22 @@ class Function : public Object {
 		Function(GCList& gcList) : super(gcList) { }
 };
 
+#if (NUXJS_ES5)
+class Accessor : public Object {
+	   public:
+			   Accessor(GCList& gcList, Function* g, Function* s)
+					   : Object(gcList), getter(g), setter(s) { }
+			   Function* getter;
+			   Function* setter;
+	   protected:
+			   virtual void gcMarkReferences(Heap& heap) const {
+					   gcMark(heap, getter);
+					   gcMark(heap, setter);
+					   super::gcMarkReferences(heap);
+			   }
+};
+#endif
+
 typedef Value (*NativeFunction)(Runtime&, Processor&, UInt32, const Value*, Object*);
 
 // FIX : overkill?
@@ -983,6 +1044,9 @@ class Error : public LazyJSObject<Object> {
 		virtual const String* toString(Heap& heap) const;
 		virtual Value getInternalValue(Heap& heap) const; // error type name
 		virtual Object* getPrototype(Runtime& rt) const;
+#if (NUXJS_ES5)
+		virtual bool setOwnProperty(Runtime& rt, const String* key, const Value& v, Flags flags = STANDARD_FLAGS);
+#endif
 		virtual bool setOwnProperty(Runtime& rt, const Value& key, const Value& v, Flags flags = STANDARD_FLAGS);
 		virtual bool deleteOwnProperty(Runtime& rt, const Value& key);
 		ErrorType getErrorType() const;
@@ -1007,12 +1071,16 @@ class FunctionScope;
 class Arguments : public LazyJSObject<Object> {
 	public:
 		typedef LazyJSObject<Object> super;
+		friend class FunctionScope;
 
 		Arguments(GCList& gcList, const FunctionScope* scope, UInt32 argumentsCount);
 		virtual const String* getClassName() const; // &A_RGUMENTS_STRING
 		virtual const String* toString(Heap& heap) const;
 		virtual Object* getPrototype(Runtime& rt) const;
 		virtual Flags getOwnProperty(Runtime& rt, const Value& key, Value* v) const;
+#if (NUXJS_ES5)
+		virtual bool setOwnProperty(Runtime& rt, const String* key, const Value& v, Flags flags = STANDARD_FLAGS);
+#endif
 		virtual bool setOwnProperty(Runtime& rt, const Value& key, const Value& v, Flags flags = STANDARD_FLAGS);
 		virtual bool deleteOwnProperty(Runtime& rt, const Value& key);
 		virtual Enumerator* getOwnPropertyEnumerator(Runtime& rt) const;
@@ -1027,6 +1095,9 @@ class Arguments : public LazyJSObject<Object> {
 		UInt32 const argumentsCount;
 		Vector<Byte> deletedArguments;
 		Vector<Value> values;	// Contains copied values after the Argument has been detached from its closure.
+#if (NUXJS_ES5)
+		FunctionScope* owner;	// Weak reference to owning FunctionScope for cleanup.
+#endif
 
 		/**
 			Notice that we do not mark the scope reference, thus creating a "weak" reference that is handled by
@@ -1133,7 +1204,11 @@ class Runtime : public GCItem {
 		JSArray* newJSArray(UInt32 initialLength = 0) const;	///< Convenience routine for `new(heap) JSArray(heap.managed(), initialLength)`
 		const String* newStringConstant(const char* s);
 
+#if (NUXJS_ES5)
+		Code* compileEvalCode(const String* expression, bool strict = false);
+#else
 		Code* compileEvalCode(const String* expression);
+#endif
 		Code* compileGlobalCode(const String& source, const String* filename = 0);
 
 		Var getGlobalsVar();							///< Convenience routine for `Var(rt, rt.getGlobalObject())`
@@ -1337,16 +1412,52 @@ class Var : public GCItem, public AccessorBase {
 class Property : public AccessorBase {
 	   friend class AccessorBase;
 
-	public:
+public:
+#if (NUXJS_ES5)
+	   template <typename T> const Property &operator=(const T &v) const {
+			   Value current;
+			   Flags flags = object->getProperty(rt, key, &current);
+			   if (flags != NONEXISTENT && (flags & ACCESSOR_FLAG) != 0) {
+					   Accessor *acc = static_cast<Accessor *>(current.asObject());
+					   Function *setter = (acc != 0 ? acc->setter : 0);
+					   if (setter != 0) {
+							   Value arg = Var(rt, v);
+							   rt.call(setter, 1, &arg, object);
+							   return *this;
+					   }
+			   }
+			   object->setProperty(rt, key, Var(rt, v));
+			   return *this;
+	   }
+#else
 	   template<typename T> const Property& operator=(const T& v) const { object->setProperty(rt, key, Var(rt, v)); return *this; }
-		template<typename T> const Property& operator+=(const T& r) const { object->setProperty(rt, key, get().add(rt.getHeap(), makeValue(r))); return *this; }
+#endif
+	   template <typename T> const Property &operator+=(const T &r) const {
+			   object->setProperty(rt, key, get().add(rt.getHeap(), makeValue(r)));
+			   return *this;
+	   }
 
-	protected:
+protected:
 	   typedef AccessorBase super;
-		Property(Runtime& rt, Object* object, const Var& key) : super(rt), object(object), key(key) { }
+	   Property(Runtime &rt, Object *object, const Var &key) : super(rt), object(object), key(key) {}
+#if (NUXJS_ES5)
+	   virtual Value get() const {
+			   Value v(UNDEFINED_VALUE);
+			   Flags flags = object->getProperty(rt, key, &v);
+			   if (flags != NONEXISTENT && (flags & ACCESSOR_FLAG) != 0) {
+					   Accessor *acc = static_cast<Accessor *>(v.asObject());
+					   Function *getter = (acc != 0 ? acc->getter : 0);
+					   return (getter != 0 ? rt.call(getter, 0, 0, object) : UNDEFINED_VALUE);
+			   }
+			   return v;
+	   }
+#else
 	   virtual Value get() const { Value v(UNDEFINED_VALUE); object->getProperty(rt, key, &v); return v; }
-		virtual Var call(int argc, const Value* argv) const { return rt.call(*this, argc, argv, object); }
-		Object* const object;
+#endif
+	   virtual Var call(int argc, const Value *argv) const {
+			   return rt.call(*this, argc, argv, object);
+	   }
+	   Object *const object;
 	   const Var key;
 };
 
@@ -1531,6 +1642,10 @@ class Processor : public GCItem {
 			, SET_PROPERTY_OP								// stack: object, name, value -> value
 			, SET_PROPERTY_POP_OP							// stack: object, name, value ->
 			, ADD_PROPERTY_OP								// operand: const_index (name), stack: object, value -> object
+#if (NUXJS_ES5)
+							, ADD_GETTER_OP						// operand: const_index(name), stack: object, function -> object
+							, ADD_SETTER_OP						// operand: const_index(name), stack: object, function -> object
+#endif
 			, PUSH_ELEMENTS_OP								// operand: count, stack: object, count * elements ... -> object
 			, OBJ_TO_PRIMITIVE_OP							// stack: value -> primitive_value (no preference)	// these three must be in this exact order
 			, OBJ_TO_NUMBER_OP								// stack: value -> primitive_value (number preferred)
@@ -1599,13 +1714,20 @@ class Processor : public GCItem {
 	public:
 		Processor(Runtime& rt);
 		void invokeFunction(Function* f, Int32 argc, const Value* argv, Object* thisObject = 0);
-		void enterGlobalCode(const Code* code);
-		void enterEvalCode(const Code* code, bool local = false);
-		void enterFunctionCode(JSFunction* func, UInt32 argc, const Value* argv, Object* thisObject = 0);
+void enterGlobalCode(const Code* code);
+#if (NUXJS_ES5)
+void enterEvalCode(const Code* code, bool direct = false);
+#else
+void enterEvalCode(const Code* code, bool local = false);
+#endif
+void enterFunctionCode(JSFunction* func, UInt32 argc, const Value* argv, Object* thisObject = 0);
 		void throwVirtualException(const Value& exception);
 		void error(ErrorType errorType, const String* message = 0);
 		bool run(Int32 maxCycles);
 		Value getResult() const;	// make sure you've called run() until it returns false before calling this
+#if (NUXJS_ES5)
+	bool isCurrentStrict() const { return currentFrame != 0 && currentFrame->code->isStrict(); }
+#endif
 
 	protected:
 		struct Frame : public GCItem {
