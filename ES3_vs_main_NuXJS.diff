--- /tmp/nu_upstream.cpp	2025-09-02 11:35:55.393484687 +0000
+++ /tmp/nu_local.cpp	2025-09-02 11:35:53.785498660 +0000
@@ -1850,7 +1859,8 @@
 
 Arguments::Arguments(GCList& gcList, const FunctionScope* scope, UInt32 argumentsCount) : super(gcList)
	   , scope(scope), function(scope->function), argumentsCount(argumentsCount)
-	   , deletedArguments(argumentsCount, &gcList.getHeap()), values(0, &gcList.getHeap()) {
+	, deletedArguments(argumentsCount, &gcList.getHeap()), values(0, &gcList.getHeap())
+{
	std::fill(deletedArguments.begin(), deletedArguments.end(), false);
 }
 
@@ -2451,18 +2464,32 @@
				}
			}
			break;
-			case WRITE_NAMED_OP:		scope->writeVar(rt, constants[im].getString(), sp[0]); break;
-			case WRITE_NAMED_POP_OP:	scope->writeVar(rt, constants[im].getString(), sp[0]); pop(1); break;
-
+			case WRITE_NAMED_OP: {
+				const String* name = constants[im].getString();
+				scope->writeVar(rt, name, sp[0]);
+			}
+			break;
+			case WRITE_NAMED_POP_OP: {
+				const String* name = constants[im].getString();
+				scope->writeVar(rt, name, sp[0]);
+				pop(1);
+			}
+			break;
			case GET_PROPERTY_OP: {
				const Object* o = convertToObject(sp[-1], false);
				if (o == 0) {
					return;
				}
-				if (o->getProperty(rt, sp[0], sp - 1) == NONEXISTENT) {
+Flags f = o->getProperty(rt, sp[0], sp - 1);
+if (f == NONEXISTENT) {
					sp[-1] = UNDEFINED_VALUE;
+pop(1);
+break;
				}
				pop(1);
+if ((f & ACCESSOR_FLAG) != 0) {
+return;
+}
				break;
			}
			
@@ -2466,13 +2493,15 @@
				break;
			}
			
+			
			case SET_PROPERTY_OP: {
				Object* o = convertToObject(sp[-2], false);
				if (o == 0) {
					return;
				}
+Value v = sp[0];
				o->setProperty(rt, sp[-1], sp[0]);
-				sp[-2] = sp[0];
+sp[-2] = v;
				pop(2);
				break;
			}
@@ -2596,7 +2627,7 @@
			case NEW_ARRAY_OP: push(new(heap) JSArray(heap.managed())); break;
			case NEW_REG_EXP_OP: invokeFunction(rt.createRegExpFunction, 1, 2); return;
			case RETURN_OP: ip = currentFrame->returnIP; popFrame(); return;
-			case THIS_OP: push(thisObject); break;
+case THIS_OP: push(thisObject != 0 ? Value(thisObject) : UNDEFINED_VALUE); break;
			case VOID_OP: push(UNDEFINED_VALUE); break;
			
			case GEN_FUNC_OP: {
@@ -3123,7 +3154,8 @@
	if (!allowKeywords && findReservedKeyword(parsed.size(), parsed.begin()) >= 0) {
		error(SYNTAX_ERROR, "Illegal use of keyword");
	}
-	return newHashedString(heap, parsed.begin(), parsed.end());
+			   const String* name = newHashedString(heap, parsed.begin(), parsed.end());
+			   return name;
 }
 
 static UInt32 unescapedMaxLength(const Char* p, const Char* e) {
@@ -3367,17 +3399,22 @@
	
	white();
	while (!token("}", false)) {
+		bool handled = false;
		const Char* b = p;
		Value key = stringOrNumberConstant();
		if (p == b) {
-			key = identifier(false, true);
-			if (key.equalsString(EMPTY_STRING)) {
+			const String* id = identifier(false, true);
+			if (id->isEqualTo(EMPTY_STRING)) {
				error(SYNTAX_ERROR, "Expected property name");
			}
+			white();
+				key = id;
		}
+		if (!handled) {
		expectToken(":", true);
		rvalueExpression(COMMA_PREC);
		emitWithConstant(Processor::ADD_PROPERTY_OP, key);
+		}
		if (token("}", true)) {
			break;
		}
@@ -3459,8 +3496,13 @@
				case ExpressionResult::PUSHED_PRIMITIVE: emit(Processor::POP_OP, 1); /* fall through */
				case ExpressionResult::NONE:
				case ExpressionResult::CONSTANT: xr = ExpressionResult(ExpressionResult::CONSTANT, true); break;
-				case ExpressionResult::LOCAL: xr = ExpressionResult(ExpressionResult::CONSTANT, false); break;
-				case ExpressionResult::NAMED: emitWithConstant(Processor::DELETE_NAMED_OP, xr.v); xr = ExpressionResult(ExpressionResult::PUSHED_PRIMITIVE); break;
+				case ExpressionResult::LOCAL:
+					xr = ExpressionResult(ExpressionResult::CONSTANT, false);
+					break;
+				case ExpressionResult::NAMED:
+					emitWithConstant(Processor::DELETE_NAMED_OP, xr.v);
+					xr = ExpressionResult(ExpressionResult::PUSHED_PRIMITIVE);
+					break;
				case ExpressionResult::PROPERTY: emit(Processor::DELETE_OP); xr = ExpressionResult(ExpressionResult::PUSHED_PRIMITIVE); break;
				default: assert(0);
			}
@@ -4734,11 +4777,10 @@
		if (argc >= 2) {
			Object* o = argv[0].asObject();
			if (o != 0) {
-				success = o->setOwnProperty(rt, argv[1], (argc >= 3 ? argv[2] : UNDEFINED_VALUE)
-						, (argc >= 4 && argv[3].toBool() ? READ_ONLY_FLAG : 0)
-						| (argc >= 5 && argv[4].toBool() ? DONT_ENUM_FLAG : 0)
-						| (argc >= 6 && argv[5].toBool() ? DONT_DELETE_FLAG : 0)
-						| EXISTS_FLAG);
+Flags flags = (argc >= 4 && argv[3].toBool() ? READ_ONLY_FLAG : 0) |
+(argc >= 5 && argv[4].toBool() ? DONT_ENUM_FLAG : 0) |
+(argc >= 6 && argv[5].toBool() ? DONT_DELETE_FLAG : 0) | EXISTS_FLAG;
+success = o->setOwnProperty(rt, argv[1], (argc >= 3 ? argv[2] : UNDEFINED_VALUE), flags);
			}
		}
		return success;
@@ -4908,8 +4951,8 @@
	FunctorAdapter<NativeFunction> func;
 } SUPPORT_FUNCTIONS[] = {
	{ "getInternalProperty", Support::getInternalProperty }, { "createWrapper", Support::createWrapper },
-	{ "defineProperty", Support::defineProperty }, { "compileFunction", Support::compileFunction },
-	{ "distinctConstructor", Support::distinctConstructor }, { "callWithArgs", Support::callWithArgs },
+	{ "defineProperty", Support::defineProperty },
+	{ "compileFunction", Support::compileFunction }, { "distinctConstructor", Support::distinctConstructor }, { "callWithArgs", Support::callWithArgs },
	{ "hasOwnProperty", Support::hasOwnProperty }, { "fromCharCode", Support::fromCharCode },
	{ "isPropertyEnumerable", Support::isPropertyEnumerable }, { "atan2", Support::atan2 },
	{ "pow", Support::pow }, { "parseFloat", Support::parseFloat }, { "charCodeAt", Support::charCodeAt },
@@ -5058,6 +5101,7 @@
	return runUntilReturn(processor);
 }
 
+// Guarded: ES5 adds strict-flag support and conditional caching
 Code* Runtime::compileEvalCode(const String* expression) {
	const Table::Bucket* bucket = evalCodeCache.lookup(expression);
	if (bucket != 0) {
@@ -5138,8 +5184,8 @@
	}
	
	const Var func = eval(*String::allocate(heap, STDLIB_JS));
-	Value argv[1] = { protectedSupportObject };
-	call(func, 1, argv);
+	Value argv[2] = { protectedSupportObject, UNDEFINED_VALUE };
+	call(func, 2, argv);
	
	fetchFunction(supportObject, "toPrimitive", toPrimitiveFunctions + 0);
	fetchFunction(supportObject, "toPrimitiveNumber", toPrimitiveFunctions + 1);
