diff --git a/.gitignore b/.gitignore
index 205ca84..7456eb5 100644
--- a/.gitignore
+++ b/.gitignore
@@ -7,3 +7,4 @@
 /externals/test262-master
 /externals/._test262-master
 /temp
+/externals/PikaScriptTmp
diff --git a/AGENTS.md b/AGENTS.md
index 316504f..0226882 100644
--- a/AGENTS.md
+++ b/AGENTS.md
@@ -1,12 +1,12 @@
 # Repository Guidelines
 
-To run the test suite use the helper script with up to three minutes allowed for execution:
+To run the test suite build both ES3 and ES5 variants with up to ten minutes allowed for execution:
 
 ```bash
-timeout 180 ./build.sh
+NUXJS_TEST_ES5_VARIANTS=1 timeout 600 ./build.sh
 ```
 
-Always execute this command before committing changes to verify that the build and regression tests succeed.
+Always execute this command before committing changes to verify that both builds and the regression tests succeed.
 
 ## Repository layout
 The project uses a consistent folder structure. Build output is written to `output/` and no source files live there. Useful locations:
@@ -48,7 +48,11 @@ Key style points:
 	void blahblah(int blah);	/// brief description of `blahblah`
 - Inside comment text, wrap any variable, parameter, class or function names in back-ticks, e.g. `blah` is the temporary buffer.
 
-See `docs/NuXJS Documentation.md` for details on how `src/stdlib.js` is minified and converted to `src/stdlibJS.cpp` during the build, and `docs/Standard Library Guidelines.md` for rules when editing the standard library.
+See `docs/NuXJS Documentation.md` for details on how `src/stdlib.js` is minified and converted to `src/stdlibJS.cpp` during the build, and `docs/Standard Library Guidelines.md` for authoring and editing the standard library.
+
+When handling files with command-line tools (which may break tab characters):
+- Always run `expand -t 4` on the file before processing.
+- Always run `unexpand -t 4` on the file after processing.
 
 ## Script portability
 All user-facing `.sh` and `.cmd` files must work when launched from any directory. They should start by changing to their own folder (or the repository root) so that relative paths resolve correctly.
diff --git a/NuXJS_ES5.diff b/NuXJS_ES5.diff
new file mode 100644
index 0000000..bc7734a
--- /dev/null
+++ b/NuXJS_ES5.diff
@@ -0,0 +1,4458 @@
+diff --git a/.gitignore b/.gitignore
+index 205ca84..7456eb5 100644
+--- a/.gitignore
++++ b/.gitignore
+@@ -7,3 +7,4 @@
+ /externals/test262-master
+ /externals/._test262-master
+ /temp
++/externals/PikaScriptTmp
+diff --git a/AGENTS.md b/AGENTS.md
+index 316504f..0226882 100644
+--- a/AGENTS.md
++++ b/AGENTS.md
+@@ -1,12 +1,12 @@
+ # Repository Guidelines
+ 
+-To run the test suite use the helper script with up to three minutes allowed for execution:
++To run the test suite build both ES3 and ES5 variants with up to ten minutes allowed for execution:
+ 
+ ```bash
+-timeout 180 ./build.sh
++NUXJS_TEST_ES5_VARIANTS=1 timeout 600 ./build.sh
+ ```
+ 
+-Always execute this command before committing changes to verify that the build and regression tests succeed.
++Always execute this command before committing changes to verify that both builds and the regression tests succeed.
+ 
+ ## Repository layout
+ The project uses a consistent folder structure. Build output is written to `output/` and no source files live there. Useful locations:
+@@ -48,7 +48,11 @@ Key style points:
+ 	void blahblah(int blah);	/// brief description of `blahblah`
+ - Inside comment text, wrap any variable, parameter, class or function names in back-ticks, e.g. `blah` is the temporary buffer.
+ 
+-See `docs/NuXJS Documentation.md` for details on how `src/stdlib.js` is minified and converted to `src/stdlibJS.cpp` during the build, and `docs/Standard Library Guidelines.md` for rules when editing the standard library.
++See `docs/NuXJS Documentation.md` for details on how `src/stdlib.js` is minified and converted to `src/stdlibJS.cpp` during the build, and `docs/Standard Library Guidelines.md` for authoring and editing the standard library.
++
++When handling files with command-line tools (which may break tab characters):
++- Always run `expand -t 4` on the file before processing.
++- Always run `unexpand -t 4` on the file after processing.
+ 
+ ## Script portability
+ All user-facing `.sh` and `.cmd` files must work when launched from any directory. They should start by changing to their own folder (or the repository root) so that relative paths resolve correctly.
+diff --git a/NuXJS_ES5.diff b/NuXJS_ES5.diff
+new file mode 100644
+index 0000000..e69de29
+diff --git a/README.md b/README.md
+index c530f19..e6709b6 100644
+--- a/README.md
++++ b/README.md
+@@ -108,6 +108,29 @@ Notes:
+ 
+ - The dashboard auto-extracts `externals/test262-master.tar.gz` if `externals/test262-master/` is missing.
+ 
++## ES3 vs ES5.1 Builds
++
++This branch layers an ES5.1 feature set on top of the stable ES3 core. ES5.1 is controlled by the `NUXJS_ES5` compile‑time switch and is enabled by default.
++
++- Default (ES5.1): run `./build.sh` (or `build.cmd`). All tests, including ES5.1, are executed.
++- ES3-only variant: set `NUXJS_ES5=0` via `CPP_OPTIONS` to disable ES5.1 features and tests.
++  - macOS/Linux: `CPP_OPTIONS='-DNUXJS_ES5=0' ./build.sh`
++  - Windows (PowerShell): `$env:CPP_OPTIONS='/DNUXJS_ES5=0'; ./build.cmd`
++  - Windows (cmd): `SET CPP_OPTIONS=/DNUXJS_ES5=0 && build.cmd`
++
++### Test Both Variants (ES3 and ES5.1)
++
++- Two‑pass mode: set `NUXJS_TEST_ES5_VARIANTS=1` to build and run the full suite twice (first with ES3, then with ES5.1):
++  - `NUXJS_TEST_ES5_VARIANTS=1 ./build.sh`
++- Faster inner loop: when using two‑pass mode during development, skip the release target:
++  - macOS/Linux: `NUXJS_SKIP_RELEASE=1 NUXJS_TEST_ES5_VARIANTS=1 ./tools/buildAndTest.sh beta`
++  - Windows (cmd): `SET NUXJS_SKIP_RELEASE=1 & SET NUXJS_TEST_ES5_VARIANTS=1 & tools\buildAndTest.cmd beta`
++
++Notes:
++
++- In single‑pass builds, ES5 tests run by default. To skip them, compile with `-DNUXJS_ES5=0`.
++- See `docs/ES5.1 Roadmap.md` for current coverage, open items, and semantic notes (e.g. `Function.prototype.bind`, strict mode, accessors, and `Object.create`/`Object.defineProperties`).
++
+ ## Example
+ 
+ Here’s a minimal example of embedding NuXJS using the high-level API:
+@@ -170,14 +193,20 @@ Each section of every test file is written as a separate entry in the specified
+ ## Documentation
+ 
+ - [NuXJS Documentation](docs/NuXJS%20Documentation.md)
++- [Standard Library Guidelines](docs/Standard%20Library%20Guidelines.md)
+ - [ECMAScript Compatibility Notes](docs/notes/ECMAScript%20Compatibility%20Notes.md)
+ - [TypeScript Compatibility](docs/notes/TypeScript%20Compatibility.md)
++- [ES5.1 Implementation Roadmap](docs/ES5.1%20Roadmap.md)
+ 
+ ## AI Usage
+ 
+ AI tools (such as OpenAI Codex) have occasionally been used to assist with documentation, code comments, test
+ generation, and repetitive edits. All core source code has been written and refined by hand over many years.
+ 
++This ES5.1 branch is an experiment informed by AI-assisted development (tests, porting helpers, and doc
++scaffolding), layered on top of the long‑standing ES3 core. All non-trivial changes are code‑reviewed and
++validated by the test suite.
++
+ ## License
+ 
+ This project is released under the [BSD 2-Clause License](LICENSE).
+diff --git a/TODO_NuXJS_ES5.md b/TODO_NuXJS_ES5.md
+new file mode 100644
+index 0000000..1fa4740
+--- /dev/null
++++ b/TODO_NuXJS_ES5.md
+@@ -0,0 +1,49 @@
++- [x] const String EMPTY_STRING, LENGTH_STRING("length"), NULL_STRING("null"), UNDEFIN
++- [x] const String* Object::getClassName() const { return &O_BJECT_STRING; }
++- [x] Flags Object::getProperty(Runtime& rt, const Value& key, Value* v) const {
++- [x] o = o->getPrototype(rt);
++- [x] return false;
++- [x] bool JSObject::setOwnProperty(Runtime& rt, const Value& key, const Value& v, Fla
++- [x] bool JSObject::setOwnProperty(Runtime& rt, const String* key, const Value& v, Fl
++- [x] bool Function::hasInstance(Runtime& rt, Object* object) const {
++- [x] bool JSArray::setElement(Runtime& rt, UInt32 index, const Value& v) {
++- [x] template<class SUPER> bool LazyJSObject<SUPER>::setOwnProperty(Runtime& rt, cons
++- [x] void Error::updateReflection(Runtime& rt) {
++- [x] Flags Arguments::getOwnProperty(Runtime& rt, const Value& key, Value* v) const {
++- [x] static struct EvalFunction : public Function {
++- [x] const Processor::OpcodeInfo Processor::opcodeInfo[Processor::OP_COUNT] = {
++- [x] void Processor::newOperation(const Int32 argc) {
++- [x] const Object* o = convertToObject(sp[-1], false);
++- [x] pop(1);
++- [x] if (o == 0) {
++- [x] case THIS_OP: push(thisObject != 0 ? Value(thisObject) : UNDEFINED_VALUE); break
++- [x] case THIS_OP: push(thisObject != 0 ? Value(thisObject) : UNDEFINED_VALUE); break
++- [x] Compiler::ExpressionResult Compiler::objectInitialiser() { // FIX : share stuff
++- [x] Compiler::ExpressionResult Compiler::objectInitialiser() { // FIX : share stuff
++- [x] void SeparateConstructorFunction::constructCompleteObject(Runtime& rt) const {
++- [x] struct Support {
++- [x] struct Support {
++- [x] static struct {
++- [x] Var Runtime::eval(const String& expression) {
++- [x] Code* Runtime::compileEvalCode(const String* expression, bool strict) {
++- [x] static Value distinctConstructor(Runtime& rt, Processor&, UInt32 argc, const Value* argv, Object*) {
++- [x] const Flags READ_ONLY_FLAG = 2;
++- [ ] class Table {
++- [ ] class Object : public GCItem {
++- [ ] class JSObject : public Object, public Table {
++- [ ] template<class SUPER> class LazyJSObject : public SUPER {
++- [ ] class JSArray : public LazyJSObject<Object> {
++- [ ] class Code : public Object {
++- [ ] class Code : public Object {
++- [ ] class Function : public Object {
++- [ ] class Function : public Object {
++- [ ] class Accessor : public Object {
++- [ ] class Error : public LazyJSObject<Object> {
++- [x] class Arguments : public LazyJSObject<Object> {
++- [ ] class Runtime : public GCItem {
++- [ ] class Property : public AccessorBase {
++- [ ] class Property : public AccessorBase {
++- [ ] class Property : public AccessorBase {
++ - [x] class Processor : public GCItem {
++ - [ ] class Processor : public GCItem {
++ - [x] tools/NuXJSTest.cpp: testJSON()
+diff --git a/docs/ES5-conditionalization-plan.md b/docs/ES5-conditionalization-plan.md
+new file mode 100644
+index 0000000..93dce29
+--- /dev/null
++++ b/docs/ES5-conditionalization-plan.md
+@@ -0,0 +1,17 @@
++# ES5 conditionalization plan
++
++The following tasks track ES5-specific changes that need wrapping in `#if (NUXJS_ES5)` blocks so that the code matches upstream `main` when the flag is disabled.
++
++- [x] Global constants `GET_STRING` and `SET_STRING` in `NuXJS.cpp`.
++- [x] Object-literal accessor parsing in `Compiler::objectInitialiser`.
++- [x] `Support::defineProperty` accessor branch guarded by `NUXJS_ES5`.
++- [x] `Object` overloads using `const String*` and `Processor&` plus accessor logic inside `getProperty`/`setProperty`.
++- [x] Additional `setOwnProperty` overloads for `JSObject`, `JSArray`, `LazyJSObject`, `Error`, and `Arguments`.
++- [x] Accessor infrastructure: `ACCESSOR_FLAG` enum value, `Accessor` class definition, and related property-handling code.
++- [x] Strict-mode infrastructure: `Code::strict` field with `isStrict`/`setStrict` methods and propagation through `Runtime::compileEvalCode`, `Processor::enterEvalCode`, and `Processor::isCurrentStrict`.
++- [x] Strict-mode parser restrictions for `eval`/`arguments`, `with`, `delete`, and duplicate parameters.
++ - [x] New opcodes `ADD_GETTER_OP` and `ADD_SETTER_OP` plus extended `OpcodeInfo` flags.
++ - [x] Accessor-aware `Property` helpers (assignment operator and `get()` implementation).
++ - [x] Changes to `Arguments` and `FunctionScope` for strict-mode argument object detachment.
++ - [x] Evaluate remaining diffs to ensure no unguarded ES5 behavior remains.
++ - [x] Build scripts perform ES3 and ES5 double build and test when `NUXJS_TEST_ES5_VARIANTS=1`.
+diff --git a/docs/ES5.1 Roadmap.md b/docs/ES5.1 Roadmap.md
+new file mode 100644
+index 0000000..de4a763
+--- /dev/null
++++ b/docs/ES5.1 Roadmap.md	
+@@ -0,0 +1,120 @@
++# ES5.1 Implementation Roadmap
++
++## Overview
++NuXJS today is a portable C++03 engine that fully implements ECMAScript 3 with a few ES5 conveniences such as JSON support and indexed string access. Custom property getters and setters are not yet available and `Object.defineProperty` only handles data properties. Built‑in library objects are written directly in JavaScript and omit modern helpers like `Object.assign` or `Array.prototype.map`. The repository already contains a broad test suite, including `tests/from262` for conformance.
++
++All ES5.1 work should be driven by regression tests. Whenever a roadmap item lands, reference its verifying `.io` file in this document.
++ES5‑specific regression tests live in `tests/es5`.
++
++## Current Status
++
++- Build toggle: ES5.1 features are guarded by the `NUXJS_ES5` macro. Default is ES5.1 (`NUXJS_ES5=1`). Use
++  `CPP_OPTIONS='-DNUXJS_ES5=0' ./build.sh` for an ES3-only build. The README documents both modes and a
++  two‑pass variant with `NUXJS_TEST_ES5_VARIANTS=1`.
++ - Test suite (with ES5.1 enabled): all ES5.1 tests pass (`tests/es5/functionBind.io`).
++
++## Roadmap to ES5.1
++
++### Object model & descriptors
++	- Extend the internal property representation to track attributes (`[[Writable]]`, `[[Enumerable]]`, `[[Configurable]]`) and accessor pairs.
++       - `src/NuXJS.h` defines `Object::Table::Bucket`; expand the union to hold either a `Value` or a `{ get, set }` pair and add an `ACCESSOR_FLAG` bit.
++       - Update `Object::getProperty` and `Object::setProperty` in `src/NuXJS.cpp` so that accessor buckets surface the getter or setter function while respecting attribute bits during writes and deletes.
++               - `GET_PROPERTY_OP` in `Processor` already delegates to `Object::getProperty`; when an `ACCESSOR_FLAG` bucket is found, the getter function replaces the original value and the processor invokes it via its standard `invokeFunction` path with the object as `this`, leaving the call result on the stack.
++               - `SET_PROPERTY_OP` similarly uses `Object::setProperty`; when an accessor exists, the processor calls the setter through `invokeFunction` with the provided value and keeps the caller's value as the final result.
++- Implement full `Object.defineProperty`, `Object.defineProperties`, `Object.getOwnPropertyDescriptor`, and `Object.create` in both the C++ core and `src/stdlib.js`.
++    - `Object.defineProperty` supports data and accessor descriptors in `src/stdlib.js`.
++    - `Object.defineProperties` implemented in `src/stdlib.js` (tests/es5/objectCreateDefineProperties.io).
++    - `Object.create` (non-null prototype) implemented in `src/stdlib.js` (tests/es5/objectCreateDefineProperties.io).
++- Replace the legacy `support.defineProperty(o, name, value, readOnly, dontEnum, dontDelete)` with a `PropertyDescriptor` structure that can carry `value`, `get`, `set`, and attribute flags.
++- The runtime helper in `src/NuXJS.cpp` should validate descriptor combinations and install either a data or accessor property in the object's hash table.
++- Expose enumeration helpers like `Object.keys` and `Object.getOwnPropertyNames`.
++        - `Object.keys` implemented in `src/stdlib.js` (`tests/es5/objectKeys.io`).
++        - `Object.getOwnPropertyNames` pending; requires a runtime iterator that can expose non-enumerable properties.
++        - Add support for accessor syntax (`get`/`set` in object literals) and function prototype attributes.
++- Ensure `Object.defineProperty`, `Object.defineProperties`, `Object.create`, and `Object.keys` are not constructable. *(Implemented; `tests/stdlib/checkAllPrototypes.io`)*
++- Extend the parser to recognize `get name(){}` and `set name(v){}` tokens and emit descriptor objects for property creation.
++- Bootstrapping of built‑ins in `src/stdlib.js` can then define getters on prototypes, e.g. for `Function.prototype.name`.
++
++### Strict mode
++- Detect strict directives and propagate mode.
++    - Add a `bool strict` member to `Code` in `src/NuXJS.h`. *(Implemented; `tests/es5/strictThisBinding.io`)*
++   - In `Compiler::compile` and `compileFunction` (`src/NuXJS.cpp`), scan the directive prologue by walking the leading string literals before any other token. A literal whose contents are exactly `use strict` (10 characters, case‑sensitive) toggles `code->strict`. *(Implemented; `tests/es5/strictThisBinding.io`)*
++- Enforce identifier restrictions and parameter checks.
++   - Update `Compiler::identifier` so `eval` and `arguments` trigger a syntax error when the current scope is strict. *(Implemented; `tests/es5/strictEvalArgsBinding.io`)*
++   - During parameter list parsing, reject duplicate names in strict functions. *(Implemented; `tests/es5/strictDuplicateParam.io`)*
++- Preserve `undefined` for unbound `this` values.
++    - Modify `Processor::enter` to skip substituting the global object when `code->strict` is set. *(Implemented; `tests/es5/strictThisBinding.io`)*
++- Reject `with` statements in strict code.
++    - Have `Compiler::withStatement` test the active scope’s `strict` flag and emit a syntax error if encountered. *(Implemented; `tests/es5/strictWithStatement.io`)*
++- Propagate strict mode through `eval` and isolate its environment. *(Implemented; `tests/es5/strictEvalScope.io`)*
++    - Pass the caller’s strict flag to `CALL_EVAL_OP` and down to `Runtime::compileEvalCode` and `Processor::enterEvalCode`. *(Implemented; `tests/es5/strictEvalScope.io`)*
++    - When strict, compile eval code with a fresh variable environment. *(Implemented; `tests/es5/strictEvalScope.io`)*
++- Tighten `delete` semantics.
++    - If `delete` targets a simple identifier in strict mode, emit a syntax error instead of `DELETE_NAMED_OP`. *(Implemented; `tests/es5/strictDeleteIdentifier.io`)*
++- Disallow implicit global variable creation.
++   - When strict code assigns to an undeclared identifier, raise a `ReferenceError` rather than defining a global property. *(Implemented; `tests/es5/strictImplicitGlobal.io`)*
++- Implement strict arguments-object behavior. *(Implemented; `tests/es5/strictArgumentsObject.io`)*
++    - Introduce a non-mapped `ArgumentsObject` variant and construct it in `FunctionScope` when `code->strict`. *(Implemented; `tests/es5/strictArgumentsObject.io`)*
++    - Ensure `arguments` does not alias parameters. *(Implemented; `tests/es5/strictArgumentsObject.io`)*
++
++### Arguments object & function semantics
++- Implement ES5.1 arguments-object behavior (decoupled mapping, `Object.getOwnPropertyDescriptor` support).
++	- Introduce an `ArgumentsObject` class that can either map indices to parameters or, in strict mode, hold a copy without parameter aliases.
++	- `Object.getOwnPropertyDescriptor` on arguments must expose `length`, `callee`, and indexed properties with correct attributes.
++ - Provide `Function.prototype.bind` and ensure correct `.name`, `.length`, and `toString` outputs.
++    - Implemented via runtime `support.bind` helper producing `BoundFunction` with correct constructor behavior and partial application semantics (`tests/es5/functionBind.io`).
++     - Optional: consider `bound` function `.name` as `"bound " + target.name` (not required by ES5.1 but common).
++
++### Spec compliance fixes
++- Align ES5 semantics that differ from the current engine implementation.
++	- Permit `for...in` on `null` or `undefined` to yield an empty iteration instead of throwing.  *(see `docs/notes/ECMAScript Compatibility Notes.md`)*
++	- Make user-defined functions' `prototype` properties non-enumerable and adjust `name`/`length` attributes to match ES5.1.
++	- Update `Object.prototype.toString` so `arguments` objects report `[object Arguments]` and enumerate indexed slots during `for...in`.
++	- Add regression tests for each behaviour in `tests/es5`.
++
++### Array & string methods
++- Add ES5.1 array iteration utilities: `forEach`, `map`, `filter`, `some`, `every`, `reduce`, `reduceRight`, `indexOf`, `lastIndexOf`.
++- These are pure library additions to `src/stdlib.js`; each helper must follow the spec's callback invocation pattern and handle sparse arrays via `Object` property checks rather than simple loops.
++- `Array.prototype.indexOf` and `Array.prototype.lastIndexOf` implemented (`tests/es5/arrayIndexOf.io`).
++- `Array.prototype.forEach` implemented (`tests/es5/arrayForEach.io`).
++- `Array.prototype.map` and `Array.prototype.filter` implemented (`tests/es5/arrayMapFilter.io`).
++- `Array.prototype.some` and `Array.prototype.every` implemented (`tests/es5/arraySomeEvery.io`).
++- `Array.prototype.reduce` and `Array.prototype.reduceRight` implemented (`tests/es5/arrayReduce.io`).
++- Implement string utilities like `trim`, `trimLeft`, `trimRight`, and JSON-related `toJSON` helpers.
++- Extend the string section in `src/stdlib.js` with whitespace tables identical to the spec and expose `String.prototype.trim*` methods.
++ - `String.prototype.trim` implemented (`tests/es5/stringTrim.io`).
++ - `String.prototype.trimLeft` and `trimRight` implemented (`tests/es5/stringTrimLeftRight.io`).
++- Add `Date.prototype.toJSON` and `Number.prototype.toJSON` wrappers that call the internal `toISOString`/conversion paths.
++
++### Object immutability controls
++- Support `Object.preventExtensions`, `Object.seal`, `Object.freeze`, and related predicates (`isExtensible`, `isSealed`, `isFrozen`).
++	- Add an `extensible` flag to the base `Object` class and teach `setProperty`/`setOwnProperty` to honor it, returning false when extensions are blocked.
++	- Implement helpers in `src/stdlib.js` that iterate over `Object.getOwnPropertyNames` descriptors and toggle `[[Configurable]]`/`[[Writable]]` bits as required by `seal` and `freeze`.
++
++### Date and Number extras
++- Finish remaining ES5.1 Date features such as `toISOString`, `toJSON`, and `now`.
++ - `Date.now` implemented using `support.getCurrentTime` (`tests/es5/dateNow.io`).
++- Add a spec‑compliant `toISOString` implementation in JavaScript.
++- Add Number and Math helpers (`isNaN`, `isFinite` refinements, `parseInt`/`parseFloat` alignment).
++	- Refine `support.isNaN`/`isFinite` semantics and expose `Number.isNaN` and `Number.isFinite` shims.
++	- Ensure `parseInt` and `parseFloat` follow ES5.1 whitespace trimming rules and radix handling; update the `Math` object with any missing constants.
++
++### Parser/VM robustness
++- Update grammar to allow reserved words as property keys and recognize accessor definitions.
++	- Expand the lexical grammar in `src/Parser.cpp` to treat keywords as identifiers in object literals and hook into the new accessor creation path.
++- Revisit bytecode generation for new features and enforce ES5.1 evaluation order.
++	- The compiler in `src/NuXJS.cpp` must emit bytecode for accessors, strict arguments, and `bind` calls while guaranteeing left‑to‑right evaluation as mandated by ES5.1.
++
++### Testing & conformance
++- Expand the existing `tests/from262` set with ES5.1 cases from Test262.
++- Import the ES5.1 section of Test262 and hook them into the `tests/from262` runner so failures can be tracked.
++- Introduce regression tests for each new feature and run the full suite (`timeout 180 ./build.sh`) during development.
++ - Add coverage in `tests/es5` for accessor edge cases, strict‑mode violations, and bound function behavior before shipping any change.
++
++### Documentation & tooling
++- Revise compatibility notes and TypeScript guidance to reflect ES5.1 support.
++- Expand `docs/notes/ECMAScript Compatibility Notes.md` once features land and document any intentional deviations.
++- Update examples and `lib.NuXJS.d.ts` to expose new APIs and maintain TypeScript type safety.
++- Regenerate declaration files so that editors pick up getters/setters and newly added methods.
++- Refresh `docs/NuXJS Documentation.md` once features land.
++- The "Partial ES5 features" table currently lists the arguments object as ES3-mapped and `Object.defineProperty` as data-only; rewrite these notes after the new behavior ships.
+diff --git a/docs/Standard Library Guidelines.md b/docs/Standard Library Guidelines.md
+index ae897fa..7aa7f12 100644
+--- a/docs/Standard Library Guidelines.md	
++++ b/docs/Standard Library Guidelines.md	
+@@ -1,23 +1,174 @@
+ # Standard Library Guidelines
+ 
+-The standard library lives in `src/stdlib.js`. After editing it, run `./build.sh` to regenerate `src/stdlibJS.cpp` and execute the regression tests.
++The standard library lives in `src/stdlib.js`. After editing it, run `./build.sh` to regenerate `src/stdlibJS.cpp` and execute the regression tests. This document combines the previous authoring guide and the general style rules for the standard library.
+ 
+ ## Formatting and style
++
+ - Follow repository formatting rules: tabs for indentation, braces on the same line and a 120-character limit.
+ - Add identifiers that must survive minification to the `@preserve` block at the top of `src/stdlib.js`.
+ 
+ ## Engine interaction
++
+ - Interact with the engine only through the injected `support` object, using helpers like `defineProperty`, `callWithArgs` and `getInternalProperty`.
+ - Use `defineProperties` to apply `readOnly`, `dontEnum` and `dontDelete` attributes consistently.
+ 
++## Support helper reference
++
++The engine injects a `support` object that provides utilities and constants used by the standard library:
++
++- `prototypes.object`, `prototypes.function`, `prototypes.string`, `prototypes.boolean`,
++  `prototypes.number`, `prototypes.date`, `prototypes.array`, `prototypes.error`,
++  `prototypes.evalError`, `prototypes.rangeError`, `prototypes.referenceError`,
++  `prototypes.syntaxError`, `prototypes.typeError`, `prototypes.uriError` – built-in prototypes.
++- `eval(code)`, `evalFunction` – evaluate source code (`evalFunction` is the direct-mode `eval`).
++- `compileFunction(source, name)` – compile a function from a source string.
++- `createWrapper(className, internalValue, prototype)` – wrap a primitive or host value.
++- `distinctConstructor(callImpl[, constructImpl])` – separate call vs `new` behaviour.
++- `callWithArgs(func[, thisArg[, args[, offset]]])` – invoke using an argument array.
++- `defineProperty(o, name, value, readOnly, dontEnum, dontDelete)` – define a data property.
++- `getInternalProperty(o, "class"|"value"|"prototype")` – inspect internal slots.
++- `hasOwnProperty(o, name)`, `isPropertyEnumerable(o, name)` – property queries.
++- `toPrimitiveNumber(o)`, `toPrimitiveString(o)`, `toPrimitive(o)` – convert objects to primitives.
++- `charCodeAt(s, i)`, `fromCharCode(code)`, `substring(s, from, to)`,
++  `submatch(text, offset, match)` – string helpers.
++- `parseFloat(s)`, `isNaN(v)`, `isFinite(v)` – numeric helpers.
++- `pow(x, y)`, `random()`, `acos(x)`, `asin(x)`, `atan(x)`, `atan2(y, x)`,
++  `cos(x)`, `exp(x)`, `floor(x)`, `log(x)`, `sin(x)`, `sqrt(x)`, `tan(x)` – math routines.
++- `maxNumber`, `minNumber` – numeric limits.
++- `getCurrentTime()`, `localTimeDifference(epoch)`, `updateDateValue(o, v)` – date helpers.
++- `createRegExp(pattern, flags)` – construct `RegExp` objects.
++- `undefined`, `NaN`, `Infinity` – primitive constants.
++
+ ## Avoid global objects
++
+ - Do not rely on global constructors or methods because user code may reassign them.
+ - Use the `$`-prefixed helpers or functions on `support` instead of global versions (for example `$charCodeAt`, `$isNaN`).
+ 
+ ## Unconstructable methods
++
+ - Wrap functions that must not be invoked with `new` using `unconstructable` (an alias for `support.distinctConstructor`).
+ - This removes their `.prototype` property and throws a `TypeError` when construction is attempted.
+ 
+ ## Language constraints
++
+ - Target ECMAScript 3 semantics.
+ - Avoid engine limitations such as custom getters/setters, non-ES3 evaluation order and unsupported regular expression features.
++
++## Writing and Minifying `src/stdlib.js`
++
++This section explains how the standard library is authored in plain JavaScript and then minified and embedded into the engine. It covers the minification pipeline, naming rules and the constraints you should follow when editing or extending `src/stdlib.js`.
++
++### Overview
++
++- Source of truth: `src/stdlib.js`
++- Build step: the file is parsed and minified by PikaScript (via `PikaCmd`) using a PEG grammar in `tools/stdlibMinifier.ppeg`
++- Emission: `tools/stdlibToCpp.pika` converts the minified code into `src/stdlibJS.cpp` as a C string array that the C++ runtime loads on startup.
++- Trigger: regeneration happens automatically when `src/stdlib.js` is newer than `src/stdlibJS.cpp`.
++
++Relevant files:
++
++- `tools/buildAndTest.sh:14–22, 28–37` – runs PikaCmd and rebuilds `src/stdlibJS.cpp` on demand
++- `tools/stdlibToCpp.pika:1` – orchestrates minification and C++ emission
++- `tools/stdlibMinifier.ppeg:1` – PPEG grammar used for tokenizing and renaming
++
++### Minifier, in a nutshell
++
++The minifier is not a full JS parser. It is a small PEG grammar that:
++
++- Removes comments and collapses whitespace
++- Renames all identifiers unless explicitly preserved
++- Leaves punctuation/operators intact
++- Keeps string and numeric literals as-is
++- Drops a redundant semicolon before a closing brace (`; }` → `}`)
++
++Identifiers are matched by the simple rule `[$a-zA-Z_0-9]+` and then passed through a renamer. The renamer generates short symbols (`a`, `b`, …, `Z`, `a0`, `a1`, …) and skips any name listed as preserved.
++
++Because property names in dot form (e.g. `obj.length`) also match `identifier`, they will be renamed unless preserved. This is why the top of `src/stdlib.js` contains one or more `@preserve:` comment lines enumerating all names that must remain stable at runtime (built-ins, property keys, well-known globals, etc.).
++
++### Authoring rules for `src/stdlib.js`
++
++Follow these to keep the minifier happy and semantics correct:
++
++1. **Preserve externally visible names** – Put every property name and global symbol that must not change under one or more comment lines with the special prefix `@preserve:`. Example from the existing file:
++
++   ```
++   /*
++       @preserve: Array,Boolean,Date,E,Error,Function,Infinity,LN10,LN2,LOG10E,LOG2E,MAX_VALUE,MIN_VALUE,Math
++       @preserve: NEGATIVE_INFINITY,NaN,Number,Object,PI,POSITIVE_INFINITY,RangeError,RegExp,SQRT1_2,SQRT2,String
++       ...
++   */
++   ```
++
++   Typical entries include: method names (`apply`, `call`, `toString`, `valueOf`, …), property names (`length`, `prototype`, `constructor`, …), global values (`Infinity`, `NaN`, `undefined`), and any object keys that are looked up reflectively from C++.
++
++2. **Do not use regular expression literals** – The grammar intentionally disables `/…/flags` because it cannot reliably disambiguate division vs. regex without a full JS parser. Use the constructor instead: `RegExp(pattern, flags)` or the provided `support.createRegExp(pattern, flags)`.
++
++3. **Keep to ES3/ES5.1-era syntax** – No template strings, destructuring, default parameters, arrow functions, classes, etc. String escapes supported by the grammar: `\n`, `\r`, `\t`, `\\`, `\"`, `\'`, `\xNN`, `\uNNNN`.
++
++4. **Assume whitespace is collapsed** – Tokens are re-joined with a single space where needed. Do not rely on line-break-sensitive Automatic Semicolon Insertion tricks. Write explicit semicolons as you would in production code. The minifier removes `;` immediately before `}`; elsewhere your semicolons are kept.
++
++5. **Prefer helper shims for native-like behaviour** – Define methods via `defineProperties(object, attribs, props)` and `support.defineProperty()` to set attributes like read‑only, dont‑enum, and dont‑delete. Example patterns used throughout the library:
++   - Create “unconstructable” functions (callable but not `new`‑able): `unconstructable(function name(...) { ... })`
++   - Create distinct call vs. construct behaviour: `support.distinctConstructor(callImpl, constructImpl)`
++   - Wrap primitives into proper objects: `support.createWrapper(className, internalValue, prototype)`
++
++6. **Be explicit with property keys** – If a property name is not on the `@preserve:` list and you only need it internally, consider bracket access with a string literal (`obj["privateKey"]`) to avoid the renamer touching it.
++
++### What the minifier actually does (details)
++
++`tools/stdlibMinifier.ppeg` defines these key rules:
++
++- `root`: streams the whole file, choosing one of these at each step:
++  - `ws` (whitespace or comments) – discarded except for `@preserve:` handling
++  - `qString` / `aString` – double- or single-quoted strings, kept verbatim (with escapes)
++  - `token` – numbers or identifiers; identifiers go through the renamer
++  - a special `';' ws '}'` case that emits only `}`
++  - any single character `.` (operators and punctuation) appended as-is
++- `token`: `number` or `identifier`
++  - `number`: hex (`0x…`) or decimal with optional fraction and exponent
++  - `identifier`: `[$a-zA-Z_0-9]+` (note: this is simpler than the real ES grammar)
++- `comment`:
++  - `/* … */` and `// …` are stripped; if they contain a `@preserve:` clause then each listed identifier is marked preserved in the parser state and will never be renamed.
++- Renamer: implemented in the `{ … }` preamble block at the top of the PEG file. It generates the sequence `a, b, …, Z, a0, a1, …` while avoiding any `@preserve`d symbol.
++
++`tools/stdlibToCpp.pika` then slices the minified output into quoted C++ lines that stay under 120 columns and writes `src/stdlibJS.cpp` with:
++
++```
++namespace NuXJS {
++const char* STDLIB_JS =
++"…minified and escaped JS…"
++"…continued…"
++;
++#if (NUXJS_ES5)
++const char* STDLIB_ES5_JS =
++"…minified ES5 additions…"
++"…continued…"
++;
++#endif
++}
++```
++
++### Testing your changes
++
++1. Edit `src/stdlib.js`
++2. Run `./build.sh` (or `build.cmd` on Windows). The build checks timestamps and regenerates `src/stdlibJS.cpp` when needed using the local `externals/PikaCmd` tool.
++3. For ES5.1 work, set `CPP_OPTIONS='-DNUXJS_ES5=1'` to enable ES5.1 tests, or set `NUXJS_TEST_ES5_VARIANTS=1` to run both ES3 and ES5.1 passes:
++
++   ```bash
++   CPP_OPTIONS='-DNUXJS_ES5=1' ./build.sh
++   NUXJS_TEST_ES5_VARIANTS=1 ./build.sh
++   ```
++
++### PikaScript reference (why it matters)
++
++The minifier and emitter are written in PikaScript and PPEG (Pika PEG). If you need to tweak the pipeline, consult the upstream documentation:
++
++- PikaScript Documentation (language reference):
++  https://github.com/malstrom72/PikaScript/blob/main/docs/PikaScript%20Documentation.txt
++- PPEG Documentation (parser generator):
++  https://github.com/malstrom72/PikaScript/blob/main/docs/PPEG%20Documentation.txt
++- PikaCmd Documentation (CLI tool):
++  https://github.com/malstrom72/PikaScript/blob/main/docs/PikaCmd%20Documentation.txt
++
++You do not need a system-wide installation; our build uses the checked-in `externals/PikaCmd` tool and the local scripts under `tools/`. If you want to explore or hack on PikaScript itself, refer to the repository above instead of adding it to this tree.
++
+diff --git a/docs/getter-setter-attempt.md b/docs/getter-setter-attempt.md
+new file mode 100644
+index 0000000..bb57cce
+--- /dev/null
++++ b/docs/getter-setter-attempt.md
+@@ -0,0 +1,13 @@
++# Getter/Setter Work
++
++Initial infrastructure for ES5.1 accessor properties is in place. A new `Accessor` object stores getter and setter pairs in property buckets flagged with `ACCESSOR_FLAG`.
++
++`Object.defineProperty` now accepts descriptor objects containing `get` or `set` and forwards the functions to the runtime without invoking the blocking `Runtime::call` path.
++
++However, accessor properties remain non-functional: the example in `examples/getter_setter_example.cpp` still prints `obj.value = undefined` and leaves `obj._v` unchanged. Further work is needed to wire descriptor plumbing to property lookup and write paths.
++
++Current limitations:
++- Descriptor validation is minimal and object literal `get`/`set` syntax is still unparsed.
++- Redefinition semantics and strict mode error handling remain incomplete.
++- Runtime `support.defineProperty` receives `undefined` for the `get` and `set` slots, indicating argument propagation from the
++  JavaScript wrapper is still broken.
+diff --git a/docs/stdlib.js Authoring Guide.md b/docs/stdlib.js Authoring Guide.md
+new file mode 100644
+index 0000000..f03a3e1
+--- /dev/null
++++ b/docs/stdlib.js Authoring Guide.md	
+@@ -0,0 +1,154 @@
++# Writing and Minifying `src/stdlib.js`
++
++This guide explains how the standard library is authored in plain JavaScript and then minified and embedded into the
++engine. It covers the minification pipeline (implemented in PikaScript/PPEG), naming rules, and the constraints you
++should follow when editing or extending `src/stdlib.js`.
++
++## Overview
++
++- Source of truth: `src/stdlib.js`
++- Build step: the file is parsed and minified by PikaScript (via `PikaCmd`) using a PEG grammar in
++  `tools/stdlibMinifier.ppeg`
++- Emission: `tools/stdlibToCpp.pika` converts the minified code into `src/stdlibJS.cpp` as a C string array that the
++  C++ runtime loads on startup.
++- Trigger: regeneration happens automatically when `src/stdlib.js` is newer than `src/stdlibJS.cpp`.
++
++Relevant files:
++- `tools/buildAndTest.sh:14–22, 28–37` – runs PikaCmd and rebuilds `src/stdlibJS.cpp` on demand
++- `tools/stdlibToCpp.pika:1` – orchestrates minification and C++ emission
++- `tools/stdlibMinifier.ppeg:1` – PPEG grammar used for tokenizing and renaming
++
++## Minifier, in a nutshell
++
++The minifier is not a full JS parser. It is a small PEG grammar that:
++
++- Removes comments and collapses whitespace
++- Renames all identifiers unless explicitly preserved
++- Leaves punctuation/operators intact
++- Keeps string and numeric literals as-is
++- Drops a redundant semicolon before a closing brace (`; }` → `}`)
++
++Identifiers are matched by the simple rule `[$a-zA-Z_0-9]+` and then passed through a renamer. The renamer generates
++short symbols (`a`, `b`, …, `Z`, `a0`, `a1`, …) and skips any name listed as preserved.
++
++Because property names in dot form (e.g. `obj.length`) also match `identifier`, they will be renamed unless preserved.
++This is why the top of `src/stdlib.js` contains one or more `@preserve:` comment lines enumerating all names that must
++remain stable at runtime (built-ins, property keys, well-known globals, etc.).
++
++## Authoring rules for `src/stdlib.js`
++
++Follow these to keep the minifier happy and semantics correct:
++
++1) Preserve externally visible names
++- Put every property name and global symbol that must not change under one or more comment lines with the special
++  prefix `@preserve:`. Example from the existing file:
++
++  ```
++  /*
++      @preserve: Array,Boolean,Date,E,Error,Function,Infinity,LN10,LN2,LOG10E,LOG2E,MAX_VALUE,MIN_VALUE,Math
++      @preserve: NEGATIVE_INFINITY,NaN,Number,Object,PI,POSITIVE_INFINITY,RangeError,RegExp,SQRT1_2,SQRT2,String
++      ...
++  */
++  ```
++
++- Typical entries include: method names (`apply`, `call`, `toString`, `valueOf`, …), property names (`length`,
++  `prototype`, `constructor`, …), global values (`Infinity`, `NaN`, `undefined`), and any object keys that are looked
++  up reflectively from C++.
++
++2) Do not use regular expression literals
++- The grammar intentionally disables `/…/flags` because it cannot reliably disambiguate division vs. regex without a
++  full JS parser.
++- Use the constructor instead: `RegExp(pattern, flags)` or the provided `support.createRegExp(pattern, flags)`.
++
++3) Keep to ES3/ES5.1-era syntax
++- No template strings, destructuring, default parameters, arrow functions, classes, etc.
++- String escapes supported by the grammar: `\n`, `\r`, `\t`, `\\`, `\"`, `\'`, `\xNN`, `\uNNNN`.
++
++4) Assume whitespace is collapsed
++- Tokens are re-joined with a single space where needed. Do not rely on line-break-sensitive Automatic Semicolon
++  Insertion tricks. Write explicit semicolons as you would in production code.
++- The minifier removes `;` immediately before `}`; elsewhere your semicolons are kept.
++
++5) Prefer helper shims for native-like behaviour
++- Define methods via `defineProperties(object, attribs, props)` and `support.defineProperty()` to set attributes like
++  read‑only, dont‑enum, and dont‑delete. Example patterns used throughout the library:
++
++  - Create “unconstructable” functions (callable but not `new`‑able):
++    `unconstructable(function name(...) { ... })`
++  - Create distinct call vs. construct behaviour:
++    `support.distinctConstructor(callImpl, constructImpl)`
++  - Wrap primitives into proper objects:
++    `support.createWrapper(className, internalValue, prototype)`
++
++6) Be explicit with property keys
++- If a property name is not on the `@preserve:` list and you only need it internally, consider bracket access with a
++  string literal (`obj["privateKey"]`) to avoid the renamer touching it.
++
++## What the minifier actually does (details)
++
++`tools/stdlibMinifier.ppeg` defines these key rules:
++
++- `root`: streams the whole file, choosing one of these at each step:
++  - `ws` (whitespace or comments) – discarded except for `@preserve:` handling
++  - `qString` / `aString` – double- or single-quoted strings, kept verbatim (with escapes)
++  - `token` – numbers or identifiers; identifiers go through the renamer
++  - a special `';' ws '}'` case that emits only `}`
++  - any single character `.` (operators and punctuation) appended as-is
++
++- `token`: `number` or `identifier`
++  - `number`: hex (`0x…`) or decimal with optional fraction and exponent
++  - `identifier`: `[$a-zA-Z_0-9]+` (note: this is simpler than the real ES grammar)
++
++- `comment`:
++  - `/* … */` and `// …` are stripped; if they contain a `@preserve:` clause then each listed identifier is marked
++    preserved in the parser state and will never be renamed.
++
++- Renamer: implemented in the `{ … }` preamble block at the top of the PEG file. It generates the sequence
++  `a, b, …, Z, a0, a1, …` while avoiding any `@preserve`d symbol.
++
++`tools/stdlibToCpp.pika` then slices the minified output into quoted C++ lines that stay under 120 columns and writes
++`src/stdlibJS.cpp` with:
++
++```
++namespace NuXJS {
++const char* STDLIB_JS =
++"…minified and escaped JS…"
++"…continued…"
++;
++#if (NUXJS_ES5)
++const char* STDLIB_ES5_JS =
++"…minified ES5 additions…"
++"…continued…"
++;
++#endif
++}
++```
++
++## Testing your changes
++
++1) Edit `src/stdlib.js`
++2) Run `./build.sh` (or `build.cmd` on Windows). The build checks timestamps and regenerates `src/stdlibJS.cpp` when
++	needed using the local `externals/PikaCmd` tool.
++3) ES5.1 features and tests run by default. To build and test the ES3-only variant, set
++        `CPP_OPTIONS='-DNUXJS_ES5=0'`, or set `NUXJS_TEST_ES5_VARIANTS=1` to run both ES3 and ES5.1 passes:
++
++        ```bash
++        CPP_OPTIONS='-DNUXJS_ES5=0' ./build.sh
++        NUXJS_TEST_ES5_VARIANTS=1 ./build.sh
++        ```
++
++## PikaScript reference (why it matters)
++
++The minifier and emitter are written in PikaScript and PPEG (Pika PEG). If you need to tweak the pipeline, consult the
++upstream documentation:
++
++- PikaScript Documentation (language reference):
++  https://github.com/malstrom72/PikaScript/blob/main/docs/PikaScript%20Documentation.txt
++- PPEG Documentation (parser generator):
++  https://github.com/malstrom72/PikaScript/blob/main/docs/PPEG%20Documentation.txt
++- PikaCmd Documentation (CLI tool):
++  https://github.com/malstrom72/PikaScript/blob/main/docs/PikaCmd%20Documentation.txt
++
++You do not need a system-wide installation; our build uses the checked-in `externals/PikaCmd` tool and the local
++scripts under `tools/`. If you want to explore or hack on PikaScript itself, refer to the repository above instead of
++adding it to this tree.
+diff --git a/examples/getter_setter_example.cpp b/examples/getter_setter_example.cpp
+new file mode 100644
+index 0000000..e3a29b9
+--- /dev/null
++++ b/examples/getter_setter_example.cpp
+@@ -0,0 +1,57 @@
++/**
++	NuXJS is released under the BSD 2-Clause License.
++
++	Copyright (c) 2018-2025, Magnus Lidström
++
++	Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
++	following conditions are met:
++
++	1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following
++	disclaimer.
++
++	2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
++	disclaimer in the documentation and/or other materials provided with the distribution.
++
++	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
++	INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
++	DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
++	SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
++	SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
++	WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
++	OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
++**/
++
++#include <iostream>
++#include "../src/NuXJS.h"
++
++using namespace NuXJS;
++
++int main() {
++	Heap heap;
++	Runtime rt(heap);
++	rt.setupStandardLibrary();
++
++	Var globals = rt.getGlobalsVar();
++rt.run(
++"var obj = {\n" \
++"\t_v: 1,\n" \
++"\tget value() { return this._v; },\n" \
++"\tset value(v) { this._v = v; },\n" \
++"\tget double() { return this._v * 2; },\n" \
++"\tset double(v) { this._v = v / 2; }\n" \
++"};\n" \
++"var start = obj.value;\n" \
++"var startDouble = obj.double;\n" \
++"obj.double = 50;\n" \
++"var afterSetDouble = obj.value;\n" \
++"obj.value = 15;\n" \
++"var finalDouble = obj.double;"
++);
++	Var obj = globals["obj"];
++	std::wcout << L"start = " << globals["start"].to<int>() << std::endl;
++	std::wcout << L"startDouble = " << globals["startDouble"].to<int>() << std::endl;
++	std::wcout << L"afterSetDouble = " << globals["afterSetDouble"].to<int>() << std::endl;
++	std::wcout << L"finalDouble = " << globals["finalDouble"].to<int>() << std::endl;
++	std::wcout << L"obj._v = " << obj["_v"].to<int>() << std::endl;
++	return 0;
++}
+diff --git a/src/stdlibES5.js b/src/stdlibES5.js
+new file mode 100644
+index 0000000..0b34bec
+--- /dev/null
++++ b/src/stdlibES5.js
+@@ -0,0 +1,171 @@
++/*
++    ES5 additions to the standard library.
++    This file is "included" with an eval at the end of stdlib.js if ES5 support is enabled.
++
++    @preserve: trim,trimLeft,trimRight,forEach,map,filter,reduce,reduceRight,every,some
++    @preserve: get,set
++    @preserve: now,create,keys,bind
++	@preserve: defineProperties
++*/
++
++// Use helpers provided by the base stdlib: defProps, int, uint32, str
++
++// String.prototype.trim*
++defProps(String.prototype, { dontEnum: true }, {
++	trimLeft: function trimLeft() {
++		var s = str(this), i = 0, j = s.length, c;
++		for (; i < j; ++i) {
++			c = s.charCodeAt(i);
++			if (c !== 0x20 && (c < 0x09 || c > 0x0D) && c !== 0xA0 && c !== 0x2028 && c !== 0x2029 && c !== 0xFEFF) break;
++		}
++		return s.substring(i, j);
++	},
++	trimRight: function trimRight() {
++		var s = str(this), j = s.length, c;
++		for (; j > 0; --j) {
++			c = s.charCodeAt(j - 1);
++			if (c !== 0x20 && (c < 0x09 || c > 0x0D) && c !== 0xA0 && c !== 0x2028 && c !== 0x2029 && c !== 0xFEFF) break;
++		}
++		return s.substring(0, j);
++	},
++	trim: function trim() {
++		var s = str(this), i = 0, j = s.length, c;
++		for (; i < j; ++i) {
++			c = s.charCodeAt(i);
++			if (c !== 0x20 && (c < 0x09 || c > 0x0D) && c !== 0xA0 && c !== 0x2028 && c !== 0x2029 && c !== 0xFEFF) break;
++		}
++		for (; j > i; --j) {
++			c = s.charCodeAt(j - 1);
++			if (c !== 0x20 && (c < 0x09 || c > 0x0D) && c !== 0xA0 && c !== 0x2028 && c !== 0x2029 && c !== 0xFEFF) break;
++		}
++		return s.substring(i, j);
++	}
++});
++
++// Array.prototype iteration and search methods
++defProps(Array.prototype, { dontEnum: true }, {
++	forEach: function forEach(callbackfn) {
++		var o = Object(this), len = uint32(o.length), t = arguments[1];
++		if (typeof callbackfn !== "function") throw TypeError();
++		for (var k = 0; k < len; ++k) if (k in o) callbackfn.call(t, o[k], k, o);
++	},
++	map: function map(callbackfn) {
++		var o = Object(this), len = uint32(o.length), t = arguments[1], a = new Array(len);
++		if (typeof callbackfn !== "function") throw TypeError();
++		for (var k = 0; k < len; ++k) if (k in o) a[k] = callbackfn.call(t, o[k], k, o);
++		return a;
++	},
++	filter: function filter(callbackfn) {
++		var o = Object(this), len = uint32(o.length), t = arguments[1], a = [], to = 0;
++		if (typeof callbackfn !== "function") throw TypeError();
++		for (var k = 0; k < len; ++k) if (k in o) { var v = o[k]; if (callbackfn.call(t, v, k, o)) a[to++] = v; }
++		a.length = to;
++		return a;
++	},
++	indexOf: function indexOf(searchElement) {
++		var len = uint32(this.length), i = arguments[1];
++		if (len === 0) return -1;
++		i = int(i);
++		if (i < 0) { i += len; if (i < 0) i = 0; }
++		for (; i < len; ++i) if (i in this && this[i] === searchElement) return i;
++		return -1;
++	},
++	lastIndexOf: function lastIndexOf(searchElement) {
++		var len = uint32(this.length), i = arguments[1];
++		if (len === 0) return -1;
++		if (i === void 0) i = len - 1; else { i = int(i); if (i < 0) i += len; if (i >= len) i = len - 1; }
++		for (; i >= 0; --i) if (i in this && this[i] === searchElement) return i;
++		return -1;
++	},
++	reduce: function reduce(callbackfn) {
++		var o = Object(this), len = uint32(o.length), k = 0, acc;
++		if (typeof callbackfn !== "function") throw TypeError();
++		if (arguments.length > 1) acc = arguments[1]; else {
++			while (k < len && !(k in o)) ++k;
++			if (k >= len) throw TypeError();
++			acc = o[k++];
++		}
++		for (; k < len; ++k) if (k in o) acc = callbackfn.call(void 0, acc, o[k], k, o);
++		return acc;
++	},
++	reduceRight: function reduceRight(callbackfn) {
++		var o = Object(this), len = uint32(o.length), k = len - 1, acc;
++		if (typeof callbackfn !== "function") throw TypeError();
++		if (arguments.length > 1) acc = arguments[1]; else {
++			while (k >= 0 && !(k in o)) --k;
++			if (k < 0) throw TypeError();
++			acc = o[k--];
++		}
++		for (; k >= 0; --k) if (k in o) acc = callbackfn.call(void 0, acc, o[k], k, o);
++		return acc;
++	},
++	every: function every(callbackfn) {
++		var o = Object(this), len = uint32(o.length), t = arguments[1];
++		if (typeof callbackfn !== "function") throw TypeError();
++		for (var k = 0; k < len; ++k) if (k in o && !callbackfn.call(t, o[k], k, o)) return false;
++		return true;
++	},
++	some: function some(callbackfn) {
++		var o = Object(this), len = uint32(o.length), t = arguments[1];
++		if (typeof callbackfn !== "function") throw TypeError();
++		for (var k = 0; k < len; ++k) if (k in o && callbackfn.call(t, o[k], k, o)) return true;
++		return false;
++	}
++});
++
++// Date.now
++defProps(Date, { dontEnum: true }, {
++	now: function now() { return new Date().getTime(); }
++});
++
++// Object helpers: defineProperty (accessors), defineProperties, create, keys
++defProps(Object, { dontEnum: true }, {
++	defineProperty: unconstructable(function defineProperty(o, p, d) {
++		var k = str(p);
++		var ro = !d.writable, de = !d.enumerable, dd = !d.configurable;
++		if ("get" in d || "set" in d) {
++			if ("value" in d || "writable" in d) throw TypeError();
++			var g = d["get"]; var s = d["set"];
++			if (g !== undefined && typeof g !== "function") throw TypeError();
++			if (s !== undefined && typeof s !== "function") throw TypeError();
++			// Use host support to create accessor properties
++			support.defineProperty(o, k, undefined, ro, de, dd, g, s);
++		} else {
++			// Data descriptor
++			support.defineProperty(o, k, d.value, ro, de, dd);
++		}
++	}),
++	defineProperties: unconstructable(function defineProperties(o, props) {
++		if (o === undefined || o === null) throw TypeError();
++		var obj = Object(o);
++		for (var k in props) if (Object.prototype.hasOwnProperty.call(props, k)) Object.defineProperty(obj, k, props[k]);
++		return obj;
++	}),
++	create: unconstructable(function create(proto, properties) {
++		if (proto === null) throw TypeError();
++		var t = typeof proto;
++		if (t !== "object" && t !== "function") throw TypeError();
++		function F() {}
++		F.prototype = proto;
++		var o = new F();
++		if (properties !== void 0) Object.defineProperties(o, Object(properties));
++		return o;
++	}),
++	keys: unconstructable(function keys(o) {
++		if (o === undefined || o === null) throw TypeError();
++		var obj = Object(o), res = [], k;
++		for (k in obj) if (Object.prototype.hasOwnProperty.call(obj, k)) res[res.length] = k;
++		return res;
++	})
++});
++
++// Function.prototype.bind (minimal, declared with one formal parameter)
++defProps(Function.prototype, { dontEnum: true }, {
++	bind: function bind(thisArg) {
++		var target = this;
++		if (typeof target !== 'function') throw TypeError();
++		var args = [target, thisArg];
++		for (var i = 1; i < arguments.length; ++i) args[args.length] = arguments[i];
++		return support.bind.apply(null, args);
++	}
++});
+diff --git a/tests/es5/arrayForEach.io b/tests/es5/arrayForEach.io
+new file mode 100644
+index 0000000..194d307
+--- /dev/null
++++ b/tests/es5/arrayForEach.io
+@@ -0,0 +1,19 @@
++> total = 0;
++> [1, 2, 3].forEach(function(v){ total += v; });
++> print(total);
++< 6
++-
++> seen = [];
++> arr = [ , 5 ];
++> arr.forEach(function(v,i){ seen.push(i); });
++> print(seen.length);
++< 1
++-
++> print(seen[0]);
++< 1
++-
++> ctx = { sum: 0 };
++> [1,2].forEach(function(v){ this.sum += v; }, ctx);
++> print(ctx.sum);
++< 3
++-
+diff --git a/tests/es5/arrayIndexOf.io b/tests/es5/arrayIndexOf.io
+new file mode 100644
+index 0000000..261fda9
+--- /dev/null
++++ b/tests/es5/arrayIndexOf.io
+@@ -0,0 +1,23 @@
++> var a = [1, 2, 3, 2];
++-
++> print(a.indexOf(2));
++< 1
++-
++> print(a.indexOf(2, 2));
++< 3
++-
++> print(a.indexOf(4));
++< -1
++-
++> print(a.lastIndexOf(2));
++< 3
++-
++> print(a.lastIndexOf(2, 2));
++< 1
++-
++> print(a.lastIndexOf(2, -3));
++< 1
++-
++> print(a.lastIndexOf(2, -5));
++< -1
++-
+diff --git a/tests/es5/arrayMapFilter.io b/tests/es5/arrayMapFilter.io
+new file mode 100644
+index 0000000..47f3143
+--- /dev/null
++++ b/tests/es5/arrayMapFilter.io
+@@ -0,0 +1,28 @@
++> res = [1,2,3].map(function(v){ return v*2; });
++> print(res.join(','));
++< 2,4,6
++-
++> ctx = { add: 1 };
++> res = [1,2].map(function(v){ return v + this.add; }, ctx);
++> print(res[1]);
++< 3
++-
++> src = [ , 5 ];
++> res = src.map(function(v){ return v; });
++> print(0 in res);
++< false
++-
++> filtered = [1,2,3,4].filter(function(v){ return v % 2 === 0; });
++> print(filtered.join(','));
++< 2,4
++-
++> ctx = { max:2 };
++> filtered = [1,2,3].filter(function(v){ return v > this.max; }, ctx);
++> print(filtered[0]);
++< 3
++-
++> src = [ ,1,2 ];
++> filtered = src.filter(function(v){ return true; });
++> print(filtered.length);
++< 2
++-
+diff --git a/tests/es5/arrayReduce.io b/tests/es5/arrayReduce.io
+new file mode 100644
+index 0000000..8af505d
+--- /dev/null
++++ b/tests/es5/arrayReduce.io
+@@ -0,0 +1,23 @@
++> print([1,2,3].reduce(function(a,b){ return a + b; }));
++< 6
++-
++> print([1,2,3].reduce(function(a,b){ return a + b; }, 1));
++< 7
++-
++> print([1,2,3].reduceRight(function(a,b){ return a - b; }));
++< 0
++-
++> print([1,2,3].reduceRight(function(a,b){ return a - b; }, 10));
++< 4
++-
++> calls = 0; arr = [ , 1 ];
++> arr.reduce(function(acc, v){ calls++; return acc; }, 0);
++> print(calls);
++< 1
++-
++> try { [].reduce(function(){}); } catch(e){ print(e instanceof TypeError); }
++< true
++-
++> try { [].reduceRight(function(){}); } catch(e){ print(e instanceof TypeError); }
++< true
++-
+diff --git a/tests/es5/arraySomeEvery.io b/tests/es5/arraySomeEvery.io
+new file mode 100644
+index 0000000..17f58c1
+--- /dev/null
++++ b/tests/es5/arraySomeEvery.io
+@@ -0,0 +1,21 @@
++> print([1,2,3].some(function(v){ return v > 2; }));
++< true
++-
++> print([1,2,3].some(function(v){ return v > 5; }));
++< false
++-
++> print([1,2,3].every(function(v){ return v < 4; }));
++< true
++-
++> print([1,2,3].every(function(v){ return v < 3; }));
++< false
++-
++> ctx = { t:2 };
++> print([1,2,3].some(function(v){ return v > this.t; }, ctx));
++< true
++-
++> calls = 0; arr = [ , 1 ];
++> arr.every(function(v,i){ calls++; return true; });
++> print(calls);
++< 1
++-
+diff --git a/tests/es5/dateNow.io b/tests/es5/dateNow.io
+new file mode 100644
+index 0000000..9251ce1
+--- /dev/null
++++ b/tests/es5/dateNow.io
+@@ -0,0 +1,8 @@
++> print(typeof Date.now);
++< function
++-
++> delta = Math.abs(Date.now() - new Date().getTime());
++-
++> print(delta < 10);
++< true
++-
+diff --git a/tests/es5/functionBind.io b/tests/es5/functionBind.io
+new file mode 100644
+index 0000000..8d608a2
+--- /dev/null
++++ b/tests/es5/functionBind.io
+@@ -0,0 +1,27 @@
++> ctx = { x: 2 };
++> function f(a,b){ return this.x + a + b; }
++> g = f.bind(ctx, 1);
++> print(g(2));
++< 5
++-
++> function h(a,b,c){}
++> hb = h.bind(null, 1, 2);
++> print(hb.length);
++< 1
++-
++> function C(a){ this.y = a; }
++> C.prototype.m = function(){ return this.y * 2; };
++> B = C.bind(null, 10);
++> o = new B();
++> print(o.y);
++< 10
++>
++> print(typeof o.m === 'function');
++< true
++> print(o instanceof C);
++< true
++-
++> nb = Math.max.bind(null, 1);
++> try { new nb(); } catch(e){ print(e instanceof TypeError); }
++< true
++-
+diff --git a/tests/es5/getterSetterProperties.io b/tests/es5/getterSetterProperties.io
+new file mode 100644
+index 0000000..2aed455
+--- /dev/null
++++ b/tests/es5/getterSetterProperties.io
+@@ -0,0 +1,26 @@
++> obj = { _v: 1, get value() { return this._v; }, set value(v) { this._v = v; }, get double() { return this._v * 2; }, set double(v) { this._v = v / 2; } };
++-
++> print(obj.value);
++< 1
++-
++> print(obj.double);
++< 2
++-
++> obj.double = 50;
++-
++> print(obj.value);
++< 25
++-
++> obj.value = 15;
++-
++> print(obj.double);
++< 30
++-
++> print(obj._v);
++< 15
++-
++> only = { _v: 0, get value() { return this._v; } };
++> only.value = 5;
++> print(only.value);
++< 0
++-
+diff --git a/tests/es5/objectCreateDefineProperties.io b/tests/es5/objectCreateDefineProperties.io
+new file mode 100644
+index 0000000..573242b
+--- /dev/null
++++ b/tests/es5/objectCreateDefineProperties.io
+@@ -0,0 +1,17 @@
++> p = { t: 3 };
++> o = Object.create(p, { x: { value: 1, enumerable: true }, y: { get: function(){ return this.x + this.t; }, enumerable: true } });
++> print(o.x);
++< 1
++> print(o.y);
++< 4
++> print(Object.getPrototypeOf(o) === p);
++< true
++-
++> o2 = {};
++> Object.defineProperties(o2, { a: { value: 1, enumerable: true }, b: { value: 2 } });
++> print(Object.keys(o2).join(','));
++< a
++> o2.a = 7;
++> print(o2.a);
++< 1
++-
+diff --git a/tests/es5/objectKeys.io b/tests/es5/objectKeys.io
+new file mode 100644
+index 0000000..bdc0a7f
+--- /dev/null
++++ b/tests/es5/objectKeys.io
+@@ -0,0 +1,22 @@
++> print(Object.keys({a:1,b:2}).sort().join(','));
++< a,b
++-
++> function F(){}
++> F.prototype.a = 1;
++> var o = new F();
++> o.b = 2;
++> print(Object.keys(o).join(','));
++< b
++-
++> var obj = {};
++> Object.defineProperty(obj, 'x', { value:1, enumerable:false });
++> obj.y = 2;
++> print(Object.keys(obj).join(','));
++< y
++-
++> print(Object.keys('hi').length);
++< 2
++-
++> try { Object.keys(null); } catch(e){ print(e instanceof TypeError); }
++< true
++-
+diff --git a/tests/es5/strictArgumentsObject.io b/tests/es5/strictArgumentsObject.io
+new file mode 100644
+index 0000000..da3fb35
+--- /dev/null
++++ b/tests/es5/strictArgumentsObject.io
+@@ -0,0 +1,8 @@
++> function f(a){ "use strict"; arguments[0] = 2; return a === 1 && arguments[0] === 2; }
++> print(f(1))
++< true
++-
++> function g(a){ "use strict"; a = 3; return arguments[0] === 1; }
++> print(g(1))
++< true
++-
+diff --git a/tests/es5/strictDeleteIdentifier.io b/tests/es5/strictDeleteIdentifier.io
+new file mode 100644
+index 0000000..8d859e9
+--- /dev/null
++++ b/tests/es5/strictDeleteIdentifier.io
+@@ -0,0 +1,7 @@
++> eval("\"use strict\"; var x = 1; delete x;")
++! !!!! SyntaxError: Deleting identifier in strict code
++-
++> function f(){ "use strict"; var y; delete y; }
++! !!!! Line: 1
++! !!!! SyntaxError: Deleting identifier in strict code
++-
+diff --git a/tests/es5/strictDuplicateParam.io b/tests/es5/strictDuplicateParam.io
+new file mode 100644
+index 0000000..60ae825
+--- /dev/null
++++ b/tests/es5/strictDuplicateParam.io
+@@ -0,0 +1,11 @@
++> function f(a, a){ "use strict"; }
++! !!!! Line: 1
++! !!!! SyntaxError: Duplicate parameter name not allowed in strict code
++-
++> function g(a, a){ return a; }
++> print(g(1))
++< undefined
++-
++> eval("\"use strict\"; function h(a, a){ return a; }")
++! !!!! SyntaxError: Duplicate parameter name not allowed in strict code
++-
+diff --git a/tests/es5/strictEvalArgsBinding.io b/tests/es5/strictEvalArgsBinding.io
+new file mode 100644
+index 0000000..72f7597
+--- /dev/null
++++ b/tests/es5/strictEvalArgsBinding.io
+@@ -0,0 +1,6 @@
++> eval("\"use strict\"; var eval = 0;")
++! !!!! SyntaxError: Illegal use of eval or arguments in strict code
++-
++> eval("\"use strict\"; function arguments(){}");
++! !!!! SyntaxError: Illegal use of eval or arguments in strict code
++-
+diff --git a/tests/es5/strictEvalScope.io b/tests/es5/strictEvalScope.io
+new file mode 100644
+index 0000000..71ea5d5
+--- /dev/null
++++ b/tests/es5/strictEvalScope.io
+@@ -0,0 +1,4 @@
++> function f(){ "use strict"; eval("1"); }
++! !!!! Line: 1
++! !!!! SyntaxError: Illegal use of eval or arguments in strict code
++-
+diff --git a/tests/es5/strictImplicitGlobal.io b/tests/es5/strictImplicitGlobal.io
+new file mode 100644
+index 0000000..3961474
+--- /dev/null
++++ b/tests/es5/strictImplicitGlobal.io
+@@ -0,0 +1,7 @@
++> eval("\"use strict\"; implicit = 1;")
++! !!!! ReferenceError: implicit is not defined
++-
++> f=function(){ "use strict"; implicit2 = 1; }
++> f()
++! !!!! ReferenceError: implicit2 is not defined
++-
+diff --git a/tests/es5/strictThisBinding.io b/tests/es5/strictThisBinding.io
+new file mode 100644
+index 0000000..1171128
+--- /dev/null
++++ b/tests/es5/strictThisBinding.io
+@@ -0,0 +1,8 @@
++> f=function(){ "use strict"; return this===undefined; }
++> print(f())
++< true
++-
++> g=function(){ return this===undefined; }
++> print(g())
++< false
++-
+diff --git a/tests/es5/strictWithStatement.io b/tests/es5/strictWithStatement.io
+new file mode 100644
+index 0000000..362f7bc
+--- /dev/null
++++ b/tests/es5/strictWithStatement.io
+@@ -0,0 +1,7 @@
++> eval("\"use strict\"; with({}){}")
++! !!!! SyntaxError: "with" is not allowed in strict code
++-
++> function f(){ "use strict"; with({}){} }
++! !!!! Line: 1
++! !!!! SyntaxError: "with" is not allowed in strict code
++-
+diff --git a/tests/es5/stringTrim.io b/tests/es5/stringTrim.io
+new file mode 100644
+index 0000000..9ea2d97
+--- /dev/null
++++ b/tests/es5/stringTrim.io
+@@ -0,0 +1,6 @@
++> print(" \tfoo \n".trim())
++< foo
++-
++> print("\u00A0bar\u00A0".trim())
++< bar
++-
+diff --git a/tests/es5/stringTrimLeftRight.io b/tests/es5/stringTrimLeftRight.io
+new file mode 100644
+index 0000000..16d13ba
+--- /dev/null
++++ b/tests/es5/stringTrimLeftRight.io
+@@ -0,0 +1,14 @@
++> var s = " \tfoo \n";
++-
++> print(s.trimLeft().charCodeAt(0));
++< 102
++-
++> print(s.trimLeft().charCodeAt(s.trimLeft().length - 1));
++< 10
++-
++> print(s.trimRight().charCodeAt(0));
++< 32
++-
++> print(s.trimRight().charCodeAt(s.trimRight().length - 1));
++< 111
++-
+diff --git a/tools/NuXJSTest.cpp b/tools/NuXJSTest.cpp
+index 13936d0..d1430ee 100644
+--- a/tools/NuXJSTest.cpp
++++ b/tools/NuXJSTest.cpp
+@@ -708,6 +708,7 @@ static void testStandardLibrary() {
+ 	EXPECT_EQUAL(upper.to<std::wstring>(), L"ABC");
+ }
+ 
++	#if (NUXJS_ES5)
+ static void testJSON() {
+ 	std::cout << std::endl << "***** JSON *****" << std::endl << std::endl;
+ 	std::cout << "  - stringify objects" << std::endl;
+@@ -726,6 +727,7 @@ static void testJSON() {
+ 	EXPECT_EQUAL(parsed["bar"][1], 2);
+         EXPECT_EQUAL(parsed["baz"].to<std::wstring>(), L"hi");
+ }
++	#endif
+ 
+ static void testCompilation() {
+ 	std::cout << std::endl << "***** Compilation *****" << std::endl << std::endl;
+@@ -1793,7 +1795,9 @@ int main(int argc, const char* argv[]) {
+ 		testTables();
+ 		testVars();
+ 		testArrayVars();
++	#if (NUXJS_ES5)
+ 		testJSON();
++	#endif
+ 		testCompilation();
+ 		testLimits();
+ 		testHighLevelAPI();
+diff --git a/tools/buildAndTest.cmd b/tools/buildAndTest.cmd
+index 8865056..66eb334 100644
+--- a/tools/buildAndTest.cmd
++++ b/tools/buildAndTest.cmd
+@@ -7,19 +7,62 @@ SET target=%~1
+ SET model=%~2
+ IF "%target%"=="" SET target=debug
+ IF "%model%"=="" SET model=x64
+-SET CPP_OPTIONS=/FS
++IF "%CPP_OPTIONS%"=="" SET CPP_OPTIONS=/FS
+ 
+-CD ..\externals\PikaCmd
++REM Build PikaCmd and update stdlibJS.cpp
++PUSHD ..\externals\PikaCmd
+ CALL .\BuildPikaCmd.cmd || GOTO error
+-CD ..\..\tools
++POPD
+ ..\externals\PikaCmd\PikaCmd.exe .\stdlibToCpp.pika ..\src\stdlib.js ..\src\stdlibJS.cpp || GOTO error
+-IF "%target%"=="release" SET CPP_OPTIONS=/GR- %CPP_OPTIONS%
++
++REM Optional dual-variant test mode (ES3 and ES5) — default OFF if not set
++IF "%NUXJS_TEST_ES5_VARIANTS%"=="" SET NUXJS_TEST_ES5_VARIANTS=0
++IF "%NUXJS_TEST_ES5_VARIANTS%"=="1" (
++	IF /I "%target%"=="release" IF "%NUXJS_SKIP_RELEASE%"=="1" (
++		ECHO Skipping release per NUXJS_SKIP_RELEASE=1
++		POPD
++		EXIT /b 0
++	)
++
++	SET CPP_OPTIONS_BASE=%CPP_OPTIONS%
++	MKDIR ..\output >NUL 2>&1
++	FOR %%E IN (0 1) DO (
++		ECHO Building and testing with NUXJS_ES5=%%E (%target% %model%)
++		SET CPP_OPTIONS=%CPP_OPTIONS_BASE% /DNUXJS_ES5=%%E
++		IF /I "%target%"=="release" SET CPP_OPTIONS=/GR- %CPP_OPTIONS%
++		CALL .\BuildCpp.cmd %target% %model% ..\output\NuXJSTest_%target%_%model%.exe .\NuXJSTest.cpp ..\src\NuXJS.cpp ..\src\stdlibJS.cpp || GOTO error
++		..\output\NuXJSTest_%target%_%model% -s >NUL 2>&1 || GOTO error
++		..\output\NuXJSTest_%target%_%model% || GOTO error
++		CALL .\BuildCpp.cmd %target% %model% ..\output\NuXJS_%target%_%model%.exe .\NuXJSREPL.cpp ..\src\NuXJS.cpp ..\src\stdlibJS.cpp || GOTO error
++		IF "%%E"=="1" (
++			SET TEST_DIRS=..\tests\conforming ..\tests\erroneous ..\tests\es3only ..\tests\es5 ..\tests\extremes ..\tests\from262 ..\tests\migrated ..\tests\regression ..\tests\stdlib ..\tests\unconforming ..\tests\unsorted
++		) ELSE (
++			SET TEST_DIRS=..\tests\conforming ..\tests\erroneous ..\tests\es3only ..\tests\extremes ..\tests\migrated ..\tests\regression ..\tests\stdlib ..\tests\unconforming ..\tests\unsorted
++		)
++		..\externals\PikaCmd\PikaCmd.exe .\test.pika -e -x ..\output\NuXJS_%target%_%model% %TEST_DIRS% || GOTO error
++		CALL runExamples.cmd %target% || GOTO error
++		ECHO Done NUXJS_ES5=%%E (%target% %model%)
++	)
++	ECHO Success!
++	POPD
++	EXIT /b 0
++)
++
++REM Default single-pass build and test
++IF /I "%target%"=="release" SET CPP_OPTIONS=/GR- %CPP_OPTIONS%
+ MKDIR ..\output >NUL 2>&1
+ CALL .\BuildCpp.cmd %target% %model% ..\output\NuXJSTest_%target%_%model%.exe .\NuXJSTest.cpp ..\src\NuXJS.cpp ..\src\stdlibJS.cpp || GOTO error
+ ..\output\NuXJSTest_%target%_%model% -s >NUL 2>&1 || GOTO error
+ ..\output\NuXJSTest_%target%_%model% || GOTO error
+ CALL .\BuildCpp.cmd %target% %model% ..\output\NuXJS_%target%_%model%.exe .\NuXJSREPL.cpp ..\src\NuXJS.cpp ..\src\stdlibJS.cpp || GOTO error
+-..\externals\PikaCmd\PikaCmd.exe .\test.pika -e -x ..\output\NuXJS_%target%_%model% ..\tests\ || GOTO error
++REM Select test directories; exclude ES5 tests only when explicitly disabled with /DNUXJS_ES5=0
++ECHO %CPP_OPTIONS% | FINDSTR /C:"/DNUXJS_ES5=0" >NUL
++IF ERRORLEVEL 0 (
++	SET TEST_DIRS=..\tests\conforming\ ..\tests\erroneous\ ..\tests\es3only\ ..\tests\extremes\..\tests\migrated\ ..\tests\regression\ ..\tests\stdlib\ ..\tests\unconforming\ ..\tests\unsorted
++) ELSE (
++	SET TEST_DIRS=..\tests\conforming\ ..\tests\erroneous\ ..\tests\es3only\ ..\tests\es5\ ..\tests\extremes\ ..\tests\from262\ ..\tests\migrated\ ..\tests\regression\ ..\tests\stdlib\ ..\tests\unconforming\ ..\tests\unsorted
++)
++..\externals\PikaCmd\PikaCmd.exe .\test.pika -e -x\ ..\output\NuXJS_%target%_%model% %TEST_DIRS% || GOTO error
+ CALL runExamples.cmd %target% || GOTO error
+ ECHO Success!
+ POPD
+diff --git a/tools/buildAndTest.sh b/tools/buildAndTest.sh
+index 1a40282..f9c43fc 100755
+--- a/tools/buildAndTest.sh
++++ b/tools/buildAndTest.sh
+@@ -5,15 +5,56 @@ cd "$(dirname "$0")"
+ target=${1-debug}
+ model=${2-x64}
+ 
++# Build PikaCmd tools and update stdlibJS.cpp if needed (once per invocation)
+ cd ../externals/PikaCmd
+ if [ ! -e ./PikaCmd ]; then
+ 	bash ./BuildCpp.sh ./PikaCmd -DPLATFORM_STRING=UNIX PikaCmdAmalgam.cpp
+ fi
+ bash ./BuildPikaCmd.sh
+ cd ../../tools
+-if [ "../src/stdlib.js" -nt "../src/stdlibJS.cpp" ]; then
++# Rebuild stdlibJS.cpp when any relevant source changed (base stdlib, ES5 extras, or the minifier pipeline).
++if [ "../src/stdlib.js" -nt "../src/stdlibJS.cpp" ] || \
++   [ "../src/stdlibES5.js" -nt "../src/stdlibJS.cpp" ] || \
++   [ "./stdlibToCpp.pika" -nt "../src/stdlibJS.cpp" ] || \
++   [ "./stdlibMinifier.ppeg" -nt "../src/stdlibJS.cpp" ]; then
+ 	../externals/PikaCmd/PikaCmd ./stdlibToCpp.pika ../src/stdlib.js ../src/stdlibJS.cpp
+ fi
++
++# When NUXJS_TEST_ES5_VARIANTS=1, run tests twice with NUXJS_ES5=0 and 1.
++if [ "${NUXJS_TEST_ES5_VARIANTS-0}" = "1" ]; then
++	# Optionally skip release target to speed up dev iterations.
++	if [ "$target" = "release" ] && [ "${NUXJS_SKIP_RELEASE-0}" = "1" ]; then
++		echo "Skipping release per NUXJS_SKIP_RELEASE=1"
++		exit 0
++	fi
++
++	CPP_OPTIONS_BASE="${CPP_OPTIONS-}"
++	mkdir ../output >/dev/null 2>&1 || true
++	for es5 in 0 1; do
++		echo "Building and testing with NUXJS_ES5=${es5} ($target $model)"
++		export CPP_OPTIONS="${CPP_OPTIONS_BASE} -DNUXJS_ES5=${es5}"
++		if [ "$target" == "release" ]; then
++			export CPP_OPTIONS="-fno-rtti ${CPP_OPTIONS}"
++		fi
++		bash ./BuildCpp.sh $target $model ../output/NuXJSTest_${target}_${model} ../tools/NuXJSTest.cpp ../src/NuXJS.cpp ../src/stdlibJS.cpp
++		../output/NuXJSTest_${target}_${model} -s >/dev/null 2>&1
++		../output/NuXJSTest_${target}_${model}
++		bash ./BuildCpp.sh $target $model ../output/NuXJS_${target}_${model} ../tools/NuXJSREPL.cpp ../src/NuXJS.cpp ../src/stdlibJS.cpp
++		# Select test directories; include ES5 tests only when ES5 is enabled.
++			if [ "$es5" = "1" ]; then
++					TEST_DIRS=(../tests/conforming ../tests/erroneous ../tests/es3only ../tests/es5 ../tests/extremes ../tests/from262 ../tests/migrated ../tests/regression ../tests/stdlib ../tests/unconforming ../tests/unsorted)
++			else
++					TEST_DIRS=(../tests/conforming ../tests/erroneous ../tests/es3only ../tests/extremes ../tests/migrated ../tests/regression ../tests/stdlib ../tests/unconforming ../tests/unsorted)
++			fi
++		../externals/PikaCmd/PikaCmd ./test.pika -e -x ../output/NuXJS_${target}_${model} "${TEST_DIRS[@]}"
++		bash ./runExamples.sh "$target"
++		echo "Done NUXJS_ES5=${es5} ($target $model)"
++	done
++	echo Success!
++	exit 0
++fi
++
++# Default single-pass build and test
+ if [ "$target" == "release" ]; then
+ 	export CPP_OPTIONS="-fno-rtti ${CPP_OPTIONS-}"
+ fi
+@@ -22,7 +63,14 @@ bash ./BuildCpp.sh $target $model ../output/NuXJSTest_${target}_${model} ../tool
+ ../output/NuXJSTest_${target}_${model} -s >/dev/null 2>&1
+ ../output/NuXJSTest_${target}_${model}
+ bash ./BuildCpp.sh $target $model ../output/NuXJS_${target}_${model} ../tools/NuXJSREPL.cpp ../src/NuXJS.cpp ../src/stdlibJS.cpp
+-../externals/PikaCmd/PikaCmd ./test.pika -e -x ../output/NuXJS_${target}_${model} ../tests/
++
++# Select test directories; exclude ES5 tests only when explicitly disabled with -DNUXJS_ES5=0.
++if echo " ${CPP_OPTIONS-} " | grep -q -- "-DNUXJS_ES5=0"; then
++	TEST_DIRS=(../tests/conforming/ ../tests/erroneous/ ../tests/es3only/ ../tests/extremes/ ../tests/migrated/ ../tests/regression/ ../tests/stdlib/ ../tests/unconforming/ ../tests/unsorted)
++else
++	TEST_DIRS=(../tests/conforming/ ../tests/erroneous/ ../tests/es3only/ ../tests/es5/ ../tests/extremes/ ../tests/from262/ ../tests/migrated/ ../tests/regression/ ../tests/stdlib/ ../tests/unconforming/ ../tests/unsorted)
++fi
++../externals/PikaCmd/PikaCmd ./test.pika -e -x ../output/NuXJS_${target}_${model} "${TEST_DIRS[@]}"
+ bash ./runExamples.sh "$target"
+ 
+ echo Success!
+diff --git a/tools/diffs/whitespace_ignored_diff_from_main.patch b/tools/diffs/whitespace_ignored_diff_from_main.patch
+new file mode 100644
+index 0000000..2c2c25a
+--- /dev/null
++++ b/tools/diffs/whitespace_ignored_diff_from_main.patch
+@@ -0,0 +1,2795 @@
++diff --git a/docs/ES5.1 Roadmap.md b/docs/ES5.1 Roadmap.md
++new file mode 100644
++index 000000000..4791d2522
++--- /dev/null
+++++ b/docs/ES5.1 Roadmap.md	
++@@ -0,0 +1,109 @@
+++# ES5.1 Implementation Roadmap
+++
+++## Overview
+++NuXJS today is a portable C++03 engine that fully implements ECMAScript 3 with a few ES5 conveniences such as JSON support and indexed string access. Custom property getters and setters are not yet available and `Object.defineProperty` only handles data properties. Built‑in library objects are written directly in JavaScript and omit modern helpers like `Object.assign` or `Array.prototype.map`. The repository already contains a broad test suite, including `tests/from262` for conformance.
+++
+++All ES5.1 work should be driven by regression tests. Whenever a roadmap item lands, reference its verifying `.io` file in this document.
+++ES5‑specific regression tests live in `tests/es5`.
+++
+++## Roadmap to ES5.1
+++
+++### Object model & descriptors
+++	- Extend the internal property representation to track attributes (`[[Writable]]`, `[[Enumerable]]`, `[[Configurable]]`) and accessor pairs.
+++       - `src/NuXJS.h` defines `Object::Table::Bucket`; expand the union to hold either a `Value` or a `{ get, set }` pair and add an `ACCESSOR_FLAG` bit.
+++       - Update `Object::getProperty` and `Object::setProperty` in `src/NuXJS.cpp` so that accessor buckets surface the getter or setter function while respecting attribute bits during writes and deletes.
+++               - `GET_PROPERTY_OP` in `Processor` already delegates to `Object::getProperty`; when an `ACCESSOR_FLAG` bucket is found, the getter function replaces the original value and the processor invokes it via its standard `invokeFunction` path with the object as `this`, leaving the call result on the stack.
+++               - `SET_PROPERTY_OP` similarly uses `Object::setProperty`; when an accessor exists, the processor calls the setter through `invokeFunction` with the provided value and keeps the caller's value as the final result.
+++- Implement full `Object.defineProperty`, `Object.defineProperties`, `Object.getOwnPropertyDescriptor`, and `Object.create` in both the C++ core and `src/stdlib.js`.
+++- Replace the legacy `support.defineProperty(o, name, value, readOnly, dontEnum, dontDelete)` with a `PropertyDescriptor` structure that can carry `value`, `get`, `set`, and attribute flags.
+++- The runtime helper in `src/NuXJS.cpp` should validate descriptor combinations and install either a data or accessor property in the object's hash table.
+++- Expose enumeration helpers like `Object.keys` and `Object.getOwnPropertyNames`.
+++	- `Object.keys` implemented in `src/stdlib.js` (`tests/es5/objectKeys.io`).
+++	- `Object.getOwnPropertyNames` pending; requires a runtime iterator that can expose non-enumerable properties.
+++	- Add support for accessor syntax (`get`/`set` in object literals) and function prototype attributes.
+++- Extend the parser to recognize `get name(){}` and `set name(v){}` tokens and emit descriptor objects for property creation.
+++- Bootstrapping of built‑ins in `src/stdlib.js` can then define getters on prototypes, e.g. for `Function.prototype.name`.
+++
+++### Strict mode
+++- Detect strict directives and propagate mode.
+++    - Add a `bool strict` member to `Code` in `src/NuXJS.h`. *(Implemented; `tests/es5/strictThisBinding.io`)*
+++   - In `Compiler::compile` and `compileFunction` (`src/NuXJS.cpp`), scan the directive prologue by walking the leading string literals before any other token. A literal whose contents are exactly `use strict` (10 characters, case‑sensitive) toggles `code->strict`. *(Implemented; `tests/es5/strictThisBinding.io`)*
+++- Enforce identifier restrictions and parameter checks.
+++   - Update `Compiler::identifier` so `eval` and `arguments` trigger a syntax error when the current scope is strict. *(Implemented; `tests/es5/strictEvalArgsBinding.io`)*
+++   - During parameter list parsing, reject duplicate names in strict functions. *(Implemented; `tests/es5/strictDuplicateParam.io`)*
+++- Preserve `undefined` for unbound `this` values.
+++    - Modify `Processor::enter` to skip substituting the global object when `code->strict` is set. *(Implemented; `tests/es5/strictThisBinding.io`)*
+++- Reject `with` statements in strict code.
+++    - Have `Compiler::withStatement` test the active scope’s `strict` flag and emit a syntax error if encountered. *(Implemented; `tests/es5/strictWithStatement.io`)*
+++- Propagate strict mode through `eval` and isolate its environment. *(Implemented; `tests/es5/strictEvalScope.io`)*
+++    - Pass the caller’s strict flag to `CALL_EVAL_OP` and down to `Runtime::compileEvalCode` and `Processor::enterEvalCode`. *(Implemented; `tests/es5/strictEvalScope.io`)*
+++    - When strict, compile eval code with a fresh variable environment. *(Implemented; `tests/es5/strictEvalScope.io`)*
+++- Tighten `delete` semantics.
+++    - If `delete` targets a simple identifier in strict mode, emit a syntax error instead of `DELETE_NAMED_OP`. *(Implemented; `tests/es5/strictDeleteIdentifier.io`)*
+++- Disallow implicit global variable creation.
+++   - When strict code assigns to an undeclared identifier, raise a `ReferenceError` rather than defining a global property. *(Implemented; `tests/es5/strictImplicitGlobal.io`)*
+++- Implement strict arguments-object behavior. *(Implemented; `tests/es5/strictArgumentsObject.io`)*
+++    - Introduce a non-mapped `ArgumentsObject` variant and construct it in `FunctionScope` when `code->strict`. *(Implemented; `tests/es5/strictArgumentsObject.io`)*
+++    - Ensure `arguments` does not alias parameters. *(Implemented; `tests/es5/strictArgumentsObject.io`)*
+++
+++### Arguments object & function semantics
+++- Implement ES5.1 arguments-object behavior (decoupled mapping, `Object.getOwnPropertyDescriptor` support).
+++	- Introduce an `ArgumentsObject` class that can either map indices to parameters or, in strict mode, hold a copy without parameter aliases.
+++	- `Object.getOwnPropertyDescriptor` on arguments must expose `length`, `callee`, and indexed properties with correct attributes.
+++- Provide `Function.prototype.bind` and ensure correct `.name`, `.length`, and `toString` outputs.
+++	- Implement `bind` in `src/stdlib.js`; the resulting bound functions require a C++ backing type to store the target, bound `this`, and partial arguments while exposing an adjusted `length` and `name`.
+++        - Revise function serialization so that `Function.prototype.toString` reconstructs source code for bound and native functions.
+++
+++### Spec compliance fixes
+++- Align ES5 semantics that differ from the current engine implementation.
+++	- Permit `for...in` on `null` or `undefined` to yield an empty iteration instead of throwing.  *(see `docs/notes/ECMAScript Compatibility Notes.md`)*
+++	- Make user-defined functions' `prototype` properties non-enumerable and adjust `name`/`length` attributes to match ES5.1.
+++	- Update `Object.prototype.toString` so `arguments` objects report `[object Arguments]` and enumerate indexed slots during `for...in`.
+++	- Add regression tests for each behaviour in `tests/es5`.
+++
+++### Array & string methods
+++- Add ES5.1 array iteration utilities: `forEach`, `map`, `filter`, `some`, `every`, `reduce`, `reduceRight`, `indexOf`, `lastIndexOf`.
+++- These are pure library additions to `src/stdlib.js`; each helper must follow the spec's callback invocation pattern and handle sparse arrays via `Object` property checks rather than simple loops.
+++- `Array.prototype.indexOf` and `Array.prototype.lastIndexOf` implemented (`tests/es5/arrayIndexOf.io`).
+++- `Array.prototype.forEach` implemented (`tests/es5/arrayForEach.io`).
+++- `Array.prototype.map` and `Array.prototype.filter` implemented (`tests/es5/arrayMapFilter.io`).
+++- `Array.prototype.some` and `Array.prototype.every` implemented (`tests/es5/arraySomeEvery.io`).
+++- `Array.prototype.reduce` and `Array.prototype.reduceRight` implemented (`tests/es5/arrayReduce.io`).
+++- Implement string utilities like `trim`, `trimLeft`, `trimRight`, and JSON-related `toJSON` helpers.
+++- Extend the string section in `src/stdlib.js` with whitespace tables identical to the spec and expose `String.prototype.trim*` methods.
+++ - `String.prototype.trim` implemented (`tests/es5/stringTrim.io`).
+++ - `String.prototype.trimLeft` and `trimRight` implemented (`tests/es5/stringTrimLeftRight.io`).
+++- Add `Date.prototype.toJSON` and `Number.prototype.toJSON` wrappers that call the internal `toISOString`/conversion paths.
+++
+++### Object immutability controls
+++- Support `Object.preventExtensions`, `Object.seal`, `Object.freeze`, and related predicates (`isExtensible`, `isSealed`, `isFrozen`).
+++	- Add an `extensible` flag to the base `Object` class and teach `setProperty`/`setOwnProperty` to honor it, returning false when extensions are blocked.
+++	- Implement helpers in `src/stdlib.js` that iterate over `Object.getOwnPropertyNames` descriptors and toggle `[[Configurable]]`/`[[Writable]]` bits as required by `seal` and `freeze`.
+++
+++### Date and Number extras
+++- Finish remaining ES5.1 Date features such as `toISOString`, `toJSON`, and `now`.
+++ - `Date.now` implemented using `support.getCurrentTime` (`tests/es5/dateNow.io`).
+++- Add a spec‑compliant `toISOString` implementation in JavaScript.
+++- Add Number and Math helpers (`isNaN`, `isFinite` refinements, `parseInt`/`parseFloat` alignment).
+++	- Refine `support.isNaN`/`isFinite` semantics and expose `Number.isNaN` and `Number.isFinite` shims.
+++	- Ensure `parseInt` and `parseFloat` follow ES5.1 whitespace trimming rules and radix handling; update the `Math` object with any missing constants.
+++
+++### Parser/VM robustness
+++- Update grammar to allow reserved words as property keys and recognize accessor definitions.
+++	- Expand the lexical grammar in `src/Parser.cpp` to treat keywords as identifiers in object literals and hook into the new accessor creation path.
+++- Revisit bytecode generation for new features and enforce ES5.1 evaluation order.
+++	- The compiler in `src/NuXJS.cpp` must emit bytecode for accessors, strict arguments, and `bind` calls while guaranteeing left‑to‑right evaluation as mandated by ES5.1.
+++
+++### Testing & conformance
+++- Expand the existing `tests/from262` set with ES5.1 cases from Test262.
+++- Import the ES5.1 section of Test262 and hook them into the `tests/from262` runner so failures can be tracked.
+++- Introduce regression tests for each new feature and run the full suite (`timeout 180 ./build.sh`) during development.
+++ - Add coverage in `tests/es5` for accessor edge cases, strict‑mode violations, and bound function behavior before shipping any change.
+++
+++### Documentation & tooling
+++- Revise compatibility notes and TypeScript guidance to reflect ES5.1 support.
+++- Expand `docs/notes/ECMAScript Compatibility Notes.md` once features land and document any intentional deviations.
+++- Update examples and `lib.NuXJS.d.ts` to expose new APIs and maintain TypeScript type safety.
+++- Regenerate declaration files so that editors pick up getters/setters and newly added methods.
+++- Refresh `docs/NuXJS Documentation.md` once features land.
+++- The "Partial ES5 features" table currently lists the arguments object as ES3-mapped and `Object.defineProperty` as data-only; rewrite these notes after the new behavior ships.
++diff --git a/docs/getter-setter-attempt.md b/docs/getter-setter-attempt.md
++new file mode 100644
++index 000000000..bb57cce59
++--- /dev/null
+++++ b/docs/getter-setter-attempt.md
++@@ -0,0 +1,13 @@
+++# Getter/Setter Work
+++
+++Initial infrastructure for ES5.1 accessor properties is in place. A new `Accessor` object stores getter and setter pairs in property buckets flagged with `ACCESSOR_FLAG`.
+++
+++`Object.defineProperty` now accepts descriptor objects containing `get` or `set` and forwards the functions to the runtime without invoking the blocking `Runtime::call` path.
+++
+++However, accessor properties remain non-functional: the example in `examples/getter_setter_example.cpp` still prints `obj.value = undefined` and leaves `obj._v` unchanged. Further work is needed to wire descriptor plumbing to property lookup and write paths.
+++
+++Current limitations:
+++- Descriptor validation is minimal and object literal `get`/`set` syntax is still unparsed.
+++- Redefinition semantics and strict mode error handling remain incomplete.
+++- Runtime `support.defineProperty` receives `undefined` for the `get` and `set` slots, indicating argument propagation from the
+++  JavaScript wrapper is still broken.
++diff --git a/examples/getter_setter_example.cpp b/examples/getter_setter_example.cpp
++new file mode 100644
++index 000000000..e3a29b9f3
++--- /dev/null
+++++ b/examples/getter_setter_example.cpp
++@@ -0,0 +1,57 @@
+++/**
+++	NuXJS is released under the BSD 2-Clause License.
+++
+++	Copyright (c) 2018-2025, Magnus Lidström
+++
+++	Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
+++	following conditions are met:
+++
+++	1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following
+++	disclaimer.
+++
+++	2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
+++	disclaimer in the documentation and/or other materials provided with the distribution.
+++
+++	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+++	INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+++	DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+++	SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+++	SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+++	WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+++	OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+++**/
+++
+++#include <iostream>
+++#include "../src/NuXJS.h"
+++
+++using namespace NuXJS;
+++
+++int main() {
+++	Heap heap;
+++	Runtime rt(heap);
+++	rt.setupStandardLibrary();
+++
+++	Var globals = rt.getGlobalsVar();
+++rt.run(
+++"var obj = {\n" \
+++"\t_v: 1,\n" \
+++"\tget value() { return this._v; },\n" \
+++"\tset value(v) { this._v = v; },\n" \
+++"\tget double() { return this._v * 2; },\n" \
+++"\tset double(v) { this._v = v / 2; }\n" \
+++"};\n" \
+++"var start = obj.value;\n" \
+++"var startDouble = obj.double;\n" \
+++"obj.double = 50;\n" \
+++"var afterSetDouble = obj.value;\n" \
+++"obj.value = 15;\n" \
+++"var finalDouble = obj.double;"
+++);
+++	Var obj = globals["obj"];
+++	std::wcout << L"start = " << globals["start"].to<int>() << std::endl;
+++	std::wcout << L"startDouble = " << globals["startDouble"].to<int>() << std::endl;
+++	std::wcout << L"afterSetDouble = " << globals["afterSetDouble"].to<int>() << std::endl;
+++	std::wcout << L"finalDouble = " << globals["finalDouble"].to<int>() << std::endl;
+++	std::wcout << L"obj._v = " << obj["_v"].to<int>() << std::endl;
+++	return 0;
+++}
++diff --git a/src/NuXJS.cpp b/src/NuXJS.cpp
++index 091635a04..5ba35b11d 100644
++--- a/src/NuXJS.cpp
+++++ b/src/NuXJS.cpp
++@@ -180,6 +180,8 @@ const String A_RGUMENTS_STRING("Arguments"), A_RRAY_STRING("Array"), B_OOLEAN_ST
++                 , E_RROR_STRING("Error"), F_UNCTION_STRING("Function"), N_UMBER_STRING("Number"), O_BJECT_STRING("Object")
++                 , S_TRING_STRING("String");
++ 
+++const String GET_STRING("get"), SET_STRING("set");
+++
++ static const String ANONYMOUS_STRING("anonymous"), ARGUMENTS_STRING("arguments")
++ 		, BRACKET_OBJECT_STRING("[object "), CALLEE_STRING("callee")
++ 		, CANNOT_CONVERT_TO_OBJECT_STRING("Cannot convert undefined or null to object")
++@@ -1277,6 +1279,7 @@ const String* Object::getClassName() const { return &O_BJECT_STRING; }
++ Object* Object::getPrototype(Runtime& rt) const { return rt.getObjectPrototype(); }
++ Value Object::getInternalValue(Heap&) const { return UNDEFINED_VALUE; }
++ Flags Object::getOwnProperty(Runtime&, const Value&, Value*) const { return NONEXISTENT; }
+++bool Object::setOwnProperty(Runtime& rt, const String* key, const Value& v, Flags flags) { return setOwnProperty(rt, Value(key), v, flags); }
++ bool Object::setOwnProperty(Runtime&, const Value&, const Value&, Flags) { return false; }
++ bool Object::deleteOwnProperty(Runtime&, const Value&) { return false; }
++ Enumerator* Object::getOwnPropertyEnumerator(Runtime&) const { return &EMPTY_ENUMERATOR; }
++@@ -1316,6 +1319,31 @@ Flags Object::getProperty(Runtime& rt, const Value& key, Value* v) const {
++ 	return NONEXISTENT;
++ }
++ 
+++Flags Object::getProperty(Runtime& rt, Processor& processor, const Value& key, Value* v) const {
+++const Object* o = this;
+++do {
+++Value current;
+++Flags flags = o->getOwnProperty(rt, key, &current);
+++if (flags != NONEXISTENT) {
+++if ((flags & ACCESSOR_FLAG) != 0) {
+++Accessor* acc = static_cast<Accessor*>(current.asObject());
+++Function* getter = (acc != 0 ? acc->getter : 0);
+++if (getter != 0) {
+++processor.invokeFunction(getter, 0, static_cast<const Value*>(0), const_cast<Object*>(this));
+++} else {
+++*v = UNDEFINED_VALUE;
+++}
+++} else {
+++*v = current;
+++}
+++return flags;
+++}
+++o = o->getPrototype(rt);
+++} while (o != 0);
+++return NONEXISTENT;
+++}
+++
+++
++ bool Object::setProperty(Runtime& rt, const Value& key, const Value& v) {
++ 	if (updateOwnProperty(rt, key, v)) {
++ 		return true;
++@@ -1330,6 +1358,23 @@ bool Object::setProperty(Runtime& rt, const Value& key, const Value& v) {
++ 	return setOwnProperty(rt, key, v);
++ }
++ 
+++bool Object::setProperty(Runtime& rt, Processor& processor, const Value& key, const Value& v) {
+++Value current;
+++Flags flags = getProperty(rt, key, &current);
+++if (flags != NONEXISTENT && (flags & ACCESSOR_FLAG) != 0) {
+++Accessor* acc = static_cast<Accessor*>(current.asObject());
+++Function* setter = (acc != 0 ? acc->setter : 0);
+++if (setter != 0) {
+++Value arg(v);
+++processor.invokeFunction(setter, 1, &arg, const_cast<Object*>(this));
+++return true;
+++}
+++return false;
+++}
+++setProperty(rt, key, v);
+++return false;
+++}
+++
++ Enumerator* Object::getPropertyEnumerator(Runtime& rt) const {
++ 	Heap& heap = rt.getHeap();
++ 	Enumerator* enumerator = getOwnPropertyEnumerator(rt);
++@@ -1479,9 +1524,26 @@ JSObject::JSObject(GCList& gcList, Object* prototype)
++ Object* JSObject::getPrototype(Runtime&) const { return prototype; }
++ 
++ bool JSObject::setOwnProperty(Runtime& rt, const Value& key, const Value& v, Flags flags) {
++-	return update(insert(key.toString(rt.getHeap())), v, flags);
+++	return setOwnProperty(rt, key.toString(rt.getHeap()), v, flags);
+++}
+++
+++bool JSObject::setOwnProperty(Runtime& rt, const String* key, const Value& v, Flags flags) {
+++	Table::Bucket* bucket = insert(key);
+++	if ((flags & ACCESSOR_FLAG) != 0 && bucket->valueExists() && (bucket->getFlags() & ACCESSOR_FLAG) != 0) {
+++	Accessor* acc = static_cast<Accessor*>(bucket->getValue().getObject());
+++	Accessor* nv = static_cast<Accessor*>(v.getObject());
+++	if (nv->getter != 0) {
+++	acc->getter = nv->getter;
+++	}
+++	if (nv->setter != 0) {
+++	acc->setter = nv->setter;
+++	}
+++	return true;
+++	}
+++	return update(bucket, v, flags);
++ }
++ 
+++
++ bool JSObject::updateOwnProperty(Runtime& rt, const Value& key, const Value& v) {
++ 	Table::Bucket* bucket = lookup(key.toString(rt.getHeap()));
++ 	return (bucket != 0 && update(bucket, v));
++@@ -1495,7 +1557,6 @@ Flags JSObject::getOwnProperty(Runtime& rt, const Value& key, Value* v) const {
++ 	}
++ 	return NONEXISTENT;
++ }
++-
++ bool JSObject::deleteOwnProperty(Runtime& rt, const Value& key) {
++ 	Table::Bucket* bucket = lookup(key.toString(rt.getHeap()));
++ 	return (bucket == 0 || erase(bucket));
++@@ -1553,7 +1614,7 @@ Code::Code(GCList& gcList, Constants* sharedConstants)
++ 	: super(gcList), codeWords(0, &gcList.getHeap())
++ 	, constants(sharedConstants ? sharedConstants : new(gcList.getHeap()) Constants(gcList.getHeap().managed()))
++ 	, nameIndexes(&gcList.getHeap()), varNames(&gcList.getHeap()), argumentNames(&gcList.getHeap()), name(0)
++-	, selfName(0), source(0), bloomSet(0), maxStackDepth(0)
+++, selfName(0), source(0), bloomSet(0), maxStackDepth(0), strict(false)
++ {
++ 	assert(constants != 0);
++ }
++@@ -1697,6 +1758,10 @@ bool JSArray::setElement(Runtime& rt, UInt32 index, const Value& v) {
++ 	return super::setOwnProperty(rt, index, v, STANDARD_FLAGS);
++ }
++ 
+++bool JSArray::setOwnProperty(Runtime& rt, const String* key, const Value& v, Flags flags) {
+++	return setOwnProperty(rt, Value(key), v, flags);
+++}
+++
++ bool JSArray::setOwnProperty(Runtime& rt, const Value& key, const Value& v, Flags flags) {
++ 	UInt32 index;
++ 	if (key.toArrayIndex(index) && index != 0xFFFFFFFFU) {
++@@ -1754,6 +1819,10 @@ template<class SUPER> bool LazyJSObject<SUPER>::setOwnProperty(Runtime& rt, cons
++ 	return getCompleteObject(rt)->setOwnProperty(rt, key, v, flags);
++ }
++ 
+++template<class SUPER> bool LazyJSObject<SUPER>::setOwnProperty(Runtime& rt, const String* key, const Value& v, Flags flags) {
+++	return getCompleteObject(rt)->setOwnProperty(rt, key, v, flags);
+++}
+++
++ template<class SUPER> bool LazyJSObject<SUPER>::deleteOwnProperty(Runtime& rt, const Value& key) {
++ 	return getCompleteObject(rt)->deleteOwnProperty(rt, key);
++ }
++@@ -1828,6 +1897,12 @@ void Error::updateReflection(Runtime& rt) {
++ 	message = (getProperty(rt, &MESSAGE_STRING, &v) != NONEXISTENT ? v.toString(rt.getHeap()) : 0);
++ }
++ 
+++bool Error::setOwnProperty(Runtime& rt, const String* key, const Value& v, Flags flags) {
+++	const bool result = super::setOwnProperty(rt, key, v, flags);
+++	updateReflection(rt);
+++	return result;
+++}
+++
++ bool Error::setOwnProperty(Runtime& rt, const Value& key, const Value& v, Flags flags) {
++ 	const bool result = super::setOwnProperty(rt, key, v, flags);
++ 	updateReflection(rt);
++@@ -1850,7 +1925,7 @@ void Error::constructCompleteObject(Runtime& rt) const {
++ 
++ Arguments::Arguments(GCList& gcList, const FunctionScope* scope, UInt32 argumentsCount) : super(gcList)
++ 	, scope(scope), function(scope->function), argumentsCount(argumentsCount)
++-	   , deletedArguments(argumentsCount, &gcList.getHeap()), values(0, &gcList.getHeap()) {
+++	, deletedArguments(argumentsCount, &gcList.getHeap()), values(0, &gcList.getHeap()), owner(const_cast<FunctionScope*>(scope)) {
++ 	std::fill(deletedArguments.begin(), deletedArguments.end(), false);
++ }
++ 
++@@ -1884,6 +1959,10 @@ Flags Arguments::getOwnProperty(Runtime& rt, const Value& key, Value* v) const {
++ 	return (p == 0 ? super::getOwnProperty(rt, key, v) : ((void)(*v = *p), (DONT_ENUM_FLAG | EXISTS_FLAG)));
++ }
++ 
+++bool Arguments::setOwnProperty(Runtime& rt, const String* key, const Value& v, Flags flags) {
+++	return setOwnProperty(rt, Value(key), v, flags);
+++}
+++
++ bool Arguments::setOwnProperty(Runtime& rt, const Value& key, const Value& v, Flags flags) {
++ 	Value* p = findProperty(key);
++ 	if (p != 0 && (flags & (READ_ONLY_FLAG | DONT_ENUM_FLAG | DONT_DELETE_FLAG)) != 0) {
++@@ -1910,8 +1989,8 @@ void Arguments::constructCompleteObject(Runtime& rt) const {
++ }
++ 
++ Arguments::~Arguments() {
++-	if (scope != 0) {
++-		scope->arguments = 0;
+++	if (owner != 0) {
+++		owner->arguments = 0;
++ 	}
++ }
++ 
++@@ -1961,13 +2040,24 @@ FunctionScope::FunctionScope(GCList& gcList, JSFunction* function, UInt32 argc,
++ 	if (code->getArgumentsCount() > argc) {
++ 		std::fill(e, locals.end(), UNDEFINED_VALUE);
++ 	}
+++	if (code->strict) {
+++		Heap& heap = gcList.getHeap();
+++		arguments = new(heap) Arguments(heap.managed(), this, passedArgumentsCount);
+++		arguments->detach();
+++	}
+++
++ }
++ 
++ JSObject* FunctionScope::getDynamicVars(Runtime& rt) const {
++ 	if (dynamicVars == 0) {
++ 		Heap& heap = rt.getHeap();
++ 		dynamicVars = new(heap) JSObject(heap.managed(), 0);
+++		if (arguments == 0) {
++ 			arguments = new(heap) Arguments(heap.managed(), this, passedArgumentsCount);
+++			if (function->code->strict) {
+++				arguments->detach();
+++			}
+++		}
++ 		dynamicVars->setOwnProperty(rt, &ARGUMENTS_STRING, arguments, DONT_DELETE_FLAG);
++ 	}
++ 	return dynamicVars;
++@@ -2062,6 +2152,7 @@ void FunctionScope::declareVar(Runtime& rt, const String* name, const Value& ini
++ 
++ FunctionScope::~FunctionScope() {
++         if (arguments != 0) {
+++                arguments->owner = 0;
++                 arguments->detach();
++                 arguments = 0;
++         }
++@@ -2095,7 +2186,8 @@ static struct EvalFunction : public Function {
++ 
++ 		Heap& heap = rt.getHeap();
++ 		const String* expression = argv[0].toString(heap);
++-		processor.enterEvalCode(rt.compileEvalCode(expression), direct);
+++		bool strict = direct && processor.isCurrentStrict();
+++		processor.enterEvalCode(rt.compileEvalCode(expression, strict), direct);
++ 		return UNDEFINED_VALUE;
++ 	}
++ 	bool direct;
++@@ -2119,6 +2211,8 @@ const Processor::OpcodeInfo Processor::opcodeInfo[Processor::OP_COUNT] = {
++ 	{ SET_PROPERTY_OP            , "SET_PROPERTY"            , -2     , 0 },
++ 	{ SET_PROPERTY_POP_OP        , "SET_PROPERTY_POP"        , -3     , 0 },
++ 	{ ADD_PROPERTY_OP            , "ADD_PROPERTY"            , -1     , 0 },
+++	{ ADD_GETTER_OP            , "ADD_GETTER"             , -1     , 0 },
+++	{ ADD_SETTER_OP            , "ADD_SETTER"             , -1     , 0 },
++ 	{ PUSH_ELEMENTS_OP           , "PUSH_ELEMENTS_OP"        , 0      , OpcodeInfo::POP_OPERAND },
++ 	{ OBJ_TO_PRIMITIVE_OP        , "OBJ_TO_PRIMITIVE"        , 0      , 0 },
++ 	{ OBJ_TO_NUMBER_OP           , "OBJ_TO_NUMBER"           , 0      , 0 },
++@@ -2202,10 +2296,49 @@ const Processor::OpcodeInfo& Processor::getOpcodeInfo(const Opcode opcode) {
++ */
++ struct Processor::EvalScope : public Scope {
++ 		typedef Scope super;
++-	EvalScope(GCList& gcList, Scope* parentScope) : super(gcList, parentScope) { }
++-	virtual void declareVar(Runtime& rt, const String* name, const Value& initValue, bool) {
+++		EvalScope(GCList& gcList, Scope* parentScope, bool isolated) : super(gcList, parentScope), vars(0), isolated(isolated) { }
+++		virtual Flags readVar(Runtime& rt, const String* name, Value* v) const {
+++			if (isolated && vars != 0) {
+++				const Flags flags = vars->getOwnProperty(rt, name, v);
+++				if (flags != NONEXISTENT) {
+++					return flags;
+++				}
+++			}
+++			return parentScope->readVar(rt, name, v);
+++		}
+++		virtual void writeVar(Runtime& rt, const String* name, const Value& value) {
+++			if (isolated && vars != 0) {
+++				Value tmp;
+++				if (vars->getOwnProperty(rt, name, &tmp) != NONEXISTENT) {
+++					vars->setOwnProperty(rt, name, value);
+++					return;
+++				}
+++			}
+++			parentScope->writeVar(rt, name, value);
+++		}
+++		virtual bool deleteVar(Runtime& rt, const String* name) {
+++			if (isolated && vars != 0 && vars->deleteOwnProperty(rt, name)) {
+++				return true;
+++			}
+++			return parentScope->deleteVar(rt, name);
+++		}
+++		virtual void declareVar(Runtime& rt, const String* name, const Value& initValue, bool dontDelete) {
+++			if (isolated) {
+++				if (vars == 0) {
+++					Heap& heap = rt.getHeap();
+++					vars = new(heap) JSObject(heap.managed(), 0);
+++				}
+++				vars->setOwnProperty(rt, name, initValue.isUndefined() ? UNDEFINED_VALUE : initValue, dontDelete ? DONT_DELETE_FLAG : 0);
+++			} else {
++ 				parentScope->declareVar(rt, name, initValue, false);
++ 			}
+++		}
+++		JSObject* vars;
+++		bool isolated;
+++		virtual void gcMarkReferences(Heap& heap) const {
+++			gcMark(heap, vars);
+++			super::gcMarkReferences(heap);
+++		}
++ };
++ 	
++ /*
++@@ -2313,7 +2446,8 @@ void Processor::enter(const Code* code, Scope* scope, Object* thisObject) {
++ 	if (sp + code->getMaxStackDepth() > stack.end()) {
++ 		ScriptException::throwError(heap, RANGE_ERROR, &STACK_OVERFLOW_STRING); // Notice: we can't use virtual throw here, cause we need to abort any sp changes etc that could happen if we continued execution beyond this point.
++ 	} else {
++-		pushFrame(code, scope, (thisObject == 0 ? rt.getGlobalObject() : thisObject));
+++Object* obj = (thisObject == 0 && !code->isStrict() ? rt.getGlobalObject() : thisObject);
+++pushFrame(code, scope, obj);
++ 		ip = code->getCodeWords();
++ 	}
++ }
++@@ -2326,14 +2460,16 @@ void Processor::enterGlobalCode(const Code* code) {
++ 	enter(code, rt.getGlobalScope(), rt.getGlobalObject());
++ }
++ 
++-void Processor::enterEvalCode(const Code* code, bool local) {
++-	if (local && currentFrame != 0) {
++-		enter(code, new(heap) Processor::EvalScope(heap.managed(), currentFrame->scope), currentFrame->thisObject);
+++void Processor::enterEvalCode(const Code* code, bool direct) {
+++	bool isolate = direct && code->isStrict();
+++	if (direct && currentFrame != 0) {
+++		enter(code, new(heap) Processor::EvalScope(heap.managed(), currentFrame->scope, isolate), currentFrame->thisObject);
++ 	} else {
++-		enter(code, new(heap) Processor::EvalScope(heap.managed(), rt.getGlobalScope()), rt.getGlobalObject());
+++		enter(code, new(heap) Processor::EvalScope(heap.managed(), rt.getGlobalScope(), isolate), rt.getGlobalObject());
++ 	}
++ }
++ 
+++
++ void Processor::enterFunctionCode(JSFunction* func, UInt32 argc, const Value* argv, Object* thisObject) {
++ 	enter(func->code, new(heap) FunctionScope(heap.managed(), func, argc, argv), thisObject);
++ }
++@@ -2451,42 +2587,80 @@ void Processor::innerRun() {
++ 				}
++ 			}
++ 			break;
++-			case WRITE_NAMED_OP:		scope->writeVar(rt, constants[im].getString(), sp[0]); break;
++-			case WRITE_NAMED_POP_OP:	scope->writeVar(rt, constants[im].getString(), sp[0]); pop(1); break;
++-
+++			case WRITE_NAMED_OP: {
+++				const String* name = constants[im].getString();
+++				if (code->isStrict()) {
+++					Value dummy;
+++					if (scope->readVar(rt, name, &dummy) == NONEXISTENT) {
+++						error(REFERENCE_ERROR, new(heap) String(heap.managed(), *name, IS_NOT_DEFINED_STRING));
+++						return;
+++					}
+++				}
+++				scope->writeVar(rt, name, sp[0]);
+++			}
+++			break;
+++			case WRITE_NAMED_POP_OP: {
+++				const String* name = constants[im].getString();
+++				if (code->isStrict()) {
+++					Value dummy;
+++					if (scope->readVar(rt, name, &dummy) == NONEXISTENT) {
+++						error(REFERENCE_ERROR, new(heap) String(heap.managed(), *name, IS_NOT_DEFINED_STRING));
+++						return;
+++					}
+++				}
+++				scope->writeVar(rt, name, sp[0]);
+++				pop(1);
+++			}
+++			break;
++ case GET_PROPERTY_OP: {
++ const Object* o = convertToObject(sp[-1], false);
++ if (o == 0) {
++ return;
++ }
++-				if (o->getProperty(rt, sp[0], sp - 1) == NONEXISTENT) {
+++Flags f = o->getProperty(rt, *this, sp[0], sp - 1);
+++if (f == NONEXISTENT) {
++ sp[-1] = UNDEFINED_VALUE;
+++pop(1);
+++break;
++ }
++ pop(1);
+++if ((f & ACCESSOR_FLAG) != 0) {
+++return;
+++}
++ break;
++ }
++ 
+++			
++ case SET_PROPERTY_OP: {
++ Object* o = convertToObject(sp[-2], false);
++ if (o == 0) {
++ return;
++ }
++-				o->setProperty(rt, sp[-1], sp[0]);
++-				sp[-2] = sp[0];
+++Value v = sp[0];
+++bool acc = o->setProperty(rt, *this, sp[-1], sp[0]);
+++sp[-2] = v;
++ pop(2);
+++if (acc) {
+++return;
+++}
++ break;
++ }
++ 
+++			
++ case SET_PROPERTY_POP_OP: {
++ Object* o = convertToObject(sp[-2], false);
++ if (o == 0) {
++ return;
++ }
++-				o->setProperty(rt, sp[-1], sp[0]);
+++bool acc = o->setProperty(rt, *this, sp[-1], sp[0]);
++ pop(3);
+++if (acc) {
+++return;
+++}
++ break;
++ }
++ 
+++
++ 			case OBJ_TO_PRIMITIVE_OP:
++ 			case OBJ_TO_NUMBER_OP:
++ 			case OBJ_TO_STRING_OP: {
++@@ -2596,7 +2770,7 @@ void Processor::innerRun() {
++ 			case NEW_ARRAY_OP: push(new(heap) JSArray(heap.managed())); break;
++ 			case NEW_REG_EXP_OP: invokeFunction(rt.createRegExpFunction, 1, 2); return;
++ 			case RETURN_OP:	ip = currentFrame->returnIP; popFrame(); return;
++-			case THIS_OP: push(thisObject); break;
+++case THIS_OP: push(thisObject != 0 ? Value(thisObject) : UNDEFINED_VALUE); break;
++ 			case VOID_OP: push(UNDEFINED_VALUE); break;
++ 			
++ 			case GEN_FUNC_OP: {
++@@ -2615,6 +2789,20 @@ void Processor::innerRun() {
++ 				pop(1);
++ 				break;
++ 			}
+++			case ADD_GETTER_OP: {
+++				Object* o = sp[-1].getObject();
+++				Accessor* acc = new(heap) Accessor(heap.managed(), sp[0].asFunction(), 0);
+++				o->setOwnProperty(rt, constants[im], acc, ACCESSOR_FLAG);
+++				pop(1);
+++				break;
+++			}
+++			case ADD_SETTER_OP: {
+++				Object* o = sp[-1].getObject();
+++				Accessor* acc = new(heap) Accessor(heap.managed(), 0, sp[0].asFunction());
+++				o->setOwnProperty(rt, constants[im], acc, ACCESSOR_FLAG);
+++				pop(1);
+++				break;
+++			}
++ 
++ 			case PUSH_ELEMENTS_OP: {
++ 				Object* o = sp[-im].getObject();
++@@ -3123,7 +3311,11 @@ const String* Compiler::identifier(bool required, bool allowKeywords) {
++         if (!allowKeywords && findReservedKeyword(parsed.size(), parsed.begin()) >= 0) {
++                 error(SYNTAX_ERROR, "Illegal use of keyword");
++         }
++-	return newHashedString(heap, parsed.begin(), parsed.end());
+++        const String* name = newHashedString(heap, parsed.begin(), parsed.end());
+++        if (code->isStrict() && name->isEqualTo(EVAL_STRING)) {
+++                error(SYNTAX_ERROR, "Illegal use of eval or arguments in strict code");
+++        }
+++        return name;
++ }
++ 
++ static UInt32 unescapedMaxLength(const Char* p, const Char* e) {
++@@ -3367,17 +3559,36 @@ Compiler::ExpressionResult Compiler::objectInitialiser() { // FIX : share stuff
++ 	
++ 	white();
++ 	while (!token("}", false)) {
+++		bool handled = false;
++ 		const Char* b = p;
++ 		Value key = stringOrNumberConstant();
++ 		if (p == b) {
++-			key = identifier(false, true);
++-			if (key.equalsString(EMPTY_STRING)) {
+++			const String* id = identifier(false, true);
+++			if (id->isEqualTo(EMPTY_STRING)) {
++ 			error(SYNTAX_ERROR, "Expected property name");
++ 			}
+++			white();
+++				if ((id->isEqualTo(GET_STRING) || id->isEqualTo(SET_STRING)) && *p != ':') {
+++				bool isGetter = id->isEqualTo(GET_STRING);
+++				const Char* b2 = p;
+++				Value accKey = stringOrNumberConstant();
+++				if (p == b2) {
+++				accKey = identifier(true, true);
+++				}
+++				white();
+++				const String* funcName = accKey.toString(heap);
+++				functionDefinition(funcName, funcName);
+++				emitWithConstant(isGetter ? Processor::ADD_GETTER_OP : Processor::ADD_SETTER_OP, accKey);
+++				handled = true;
+++			} else {
+++			key = id;
+++			}
++ 			}
+++		if (!handled) {
++ 				expectToken(":", true);
++ 				rvalueExpression(COMMA_PREC);
++ 				emitWithConstant(Processor::ADD_PROPERTY_OP, key);
+++		}
++ 			if (token("}", true)) {
++ 				break;
++ 			}
++@@ -3459,8 +3670,19 @@ bool Compiler::preOperate(ExpressionResult& xr, Precedence precedence) {
++ 				case ExpressionResult::PUSHED_PRIMITIVE: emit(Processor::POP_OP, 1); /* fall through */
++ 				case ExpressionResult::NONE:
++ 				case ExpressionResult::CONSTANT: xr = ExpressionResult(ExpressionResult::CONSTANT, true); break;
++-				case ExpressionResult::LOCAL: xr = ExpressionResult(ExpressionResult::CONSTANT, false); break;
++-				case ExpressionResult::NAMED: emitWithConstant(Processor::DELETE_NAMED_OP, xr.v); xr = ExpressionResult(ExpressionResult::PUSHED_PRIMITIVE); break;
+++				case ExpressionResult::LOCAL:
+++					if (code->isStrict()) {
+++						error(SYNTAX_ERROR, "Deleting identifier in strict code");
+++					}
+++					xr = ExpressionResult(ExpressionResult::CONSTANT, false);
+++					break;
+++				case ExpressionResult::NAMED:
+++					if (code->isStrict()) {
+++						error(SYNTAX_ERROR, "Deleting identifier in strict code");
+++					}
+++					emitWithConstant(Processor::DELETE_NAMED_OP, xr.v);
+++					xr = ExpressionResult(ExpressionResult::PUSHED_PRIMITIVE);
+++					break;
++ 				case ExpressionResult::PROPERTY: emit(Processor::DELETE_OP); xr = ExpressionResult(ExpressionResult::PUSHED_PRIMITIVE); break;
++ 				default: assert(0);
++ 			}
++@@ -3665,6 +3887,7 @@ bool Compiler::postOperate(ExpressionResult& xr, Precedence precedence) {
++ void Compiler::functionDefinition(const String* functionName, const String* selfName) {
++ 	assert(functionName != 0);
++ 	Code* func = new(heap) Code(heap.managed(), code->constants);
+++	func->strict = code->strict;
++ 	Compiler funcCompiler(heap.roots(), func, Compiler::FOR_FUNCTION, nestCounter);
++ 	try {
++ 		p = funcCompiler.compileFunction(p, e, functionName, selfName);
++@@ -3819,6 +4042,9 @@ void Compiler::rvalueGroup() {
++ 
++ // FIX : ok, this is serious mess
++ Compiler::ExpressionResult Compiler::declareIdentifier(const String* name, bool func) {
+++	if (code->isStrict() && (name->isEqualTo(EVAL_STRING) || name->isEqualTo(ARGUMENTS_STRING))) {
+++		error(SYNTAX_ERROR, "Illegal use of eval or arguments in strict code");
+++	}
++ 	ExpressionResult lxr(ExpressionResult::NAMED, name);
++ 	if (compilingFor != FOR_FUNCTION) {
++ 		CodeSection* previousSection = changeSection(&setupSection);
++@@ -3974,6 +4200,9 @@ void Compiler::functionStatement() {
++ }
++ 
++ void Compiler::withStatement(SemanticScope* currentScope) {
+++	if (code->isStrict()) {
+++		error(SYNTAX_ERROR, "\"with\" is not allowed in strict code");
+++	}
++ 	rvalueGroup();
++ 	emit(Processor::WITH_SCOPE_OP);
++ 	{
++@@ -4461,6 +4690,28 @@ const Char* Compiler::compile(const Char* b, const Char* e) {
++ 	p = b;
++ 	this->e = e;
++ 	acceptInOperator = true;
+++	const Char* directiveStart = p;
+++	white();
+++	bool foundStrict = false;
+++	while (p < e && (*p == '"' || *p == '\'')) {
+++		Char q = *p++;
+++		const Char* litStart = p;
+++		while (p < e && *p != q) { ++p; }
+++		if (p >= e) { break; }
+++		if (!foundStrict && p - litStart == 10 && strncmp(litStart, "use strict", 10) == 0) {
+++			foundStrict = true;
+++		}
+++		++p;
+++		white();
+++		if (p < e && *p == ';') {
+++			++p;
+++			white();
+++			continue;
+++		}
+++		break;
+++	}
+++	if (foundStrict) { code->setStrict(true); }
+++	p = directiveStart;
++ 	
++ 	// FIX : not 100% necessary now because we should always start with undefined on top of stack
++ 	if (compilingFor == FOR_EVAL) {
++@@ -4496,6 +4747,7 @@ const Char* Compiler::compileFunction(const Char* b, const Char* e, const String
++ 	white();
++ 	Table& nameIndexes = code->nameIndexes;
++ 	Vector<const String*>& argumentNames = code->argumentNames;
+++	bool hasDuplicateParameters = false;
++ 	while (!token(")", false)) {
++ 		if (eof()) {
++ 			error(SYNTAX_ERROR, argumentNames.size() == 0 ? "Expected ')'" : "Expected ',' or ')'");
++@@ -4507,6 +4759,15 @@ const Char* Compiler::compileFunction(const Char* b, const Char* e, const String
++ 			white();
++ 		}
++ 		const String* name = identifier(true, false);
+++		if (code->isStrict() && (name->isEqualTo(EVAL_STRING) || name->isEqualTo(ARGUMENTS_STRING))) {
+++			error(SYNTAX_ERROR, "Illegal use of eval or arguments in strict code");
+++		}
+++		for (size_t i = 0; i < argumentNames.size(); ++i) {
+++			if (argumentNames[i]->isEqualTo(*name)) {
+++				hasDuplicateParameters = true;
+++				break;
+++			}
+++		}
++ 		nameIndexes.update(nameIndexes.insert(name), static_cast<Int32>(argumentNames.size()));
++ 		argumentNames.push(name);
++ 		code->bloomSet |= name->createBloomCode();
++@@ -4515,6 +4776,9 @@ const Char* Compiler::compileFunction(const Char* b, const Char* e, const String
++ 	expectToken("{", true);
++ 	compile(p, e); // FIX: ugly as it sets p and e again, although it doesn't hurt
++ 	expectToken("}", false);
+++	if (code->strict && hasDuplicateParameters) {
+++		error(SYNTAX_ERROR, "Duplicate parameter name not allowed in strict code");
+++	}
++ 	code->name = functionName;
++ 	code->selfName = selfName;
++ 	code->source = String::concatenate(heap, String(heap.roots(), FUNCTION_SPACE, *functionName), String(heap.roots(), b, p));
++@@ -4734,11 +4998,17 @@ struct Support {
++ 		if (argc >= 2) {
++ 			Object *o = argv[0].asObject();
++ 			if (o != 0) {
++-				success = o->setOwnProperty(rt, argv[1], (argc >= 3 ? argv[2] : UNDEFINED_VALUE)
++-						, (argc >= 4 && argv[3].toBool() ? READ_ONLY_FLAG : 0)
++-						| (argc >= 5 && argv[4].toBool() ? DONT_ENUM_FLAG : 0)
++-						| (argc >= 6 && argv[5].toBool() ? DONT_DELETE_FLAG : 0)
++-						| EXISTS_FLAG);
+++				Flags flags = (argc >= 4 && argv[3].toBool() ? READ_ONLY_FLAG : 0) |
+++				              (argc >= 5 && argv[4].toBool() ? DONT_ENUM_FLAG : 0) |
+++				              (argc >= 6 && argv[5].toBool() ? DONT_DELETE_FLAG : 0) | EXISTS_FLAG;
+++				if (argc >= 7) {
+++					Heap &heap = rt.getHeap();
+++					Accessor *acc = new (heap)
+++					    Accessor(heap.managed(), argv[6].asFunction(), (argc >= 8 ? argv[7].asFunction() : 0));
+++					success = o->setOwnProperty(rt, argv[1], acc, flags | ACCESSOR_FLAG);
+++				} else {
+++					success = o->setOwnProperty(rt, argv[1], (argc >= 3 ? argv[2] : UNDEFINED_VALUE), flags);
+++				}
++ 			}
++ 		}
++ 		return success;
++@@ -5058,21 +5328,23 @@ Var Runtime::eval(const String& expression) {
++ 	return runUntilReturn(processor);
++ }
++ 
++-Code* Runtime::compileEvalCode(const String* expression) {
++-	const Table::Bucket* bucket = evalCodeCache.lookup(expression);
+++Code* Runtime::compileEvalCode(const String* expression, bool strict) {
+++	const Table::Bucket* bucket = (strict ? 0 : evalCodeCache.lookup(expression));
++ 	if (bucket != 0) {
++ 		Object* o = bucket->getValue().getObject();
++ 		assert(dynamic_cast<Code*>(o) != 0);
++ 		return reinterpret_cast<Code*>(o);
++ 	} else {
++ 		Code* code = new(heap) Code(heap.managed());
+++		if (strict) { code->setStrict(true); }
++ 		Compiler compiler(heap.roots(), code, Compiler::FOR_EVAL);
++ 		compiler.compile(*expression);
++-		evalCodeCache.update(evalCodeCache.insert(expression), code);
+++		if (!strict) { evalCodeCache.update(evalCodeCache.insert(expression), code); }
++ 		return code;
++ 	}
++ }
++ 
+++
++ Code* Runtime::compileGlobalCode(const String& source, const String* filename) {
++ 	Code* code = new(heap) Code(heap.managed());
++ 	Compiler compiler(heap.roots(), code, Compiler::FOR_GLOBAL);
++diff --git a/src/NuXJS.h b/src/NuXJS.h
++index 98904d66f..08901b336 100644
++--- a/src/NuXJS.h
+++++ b/src/NuXJS.h
++@@ -447,11 +447,13 @@ const Flags READ_ONLY_FLAG = 2;
++ const Flags DONT_ENUM_FLAG = 4;
++ const Flags DONT_DELETE_FLAG = 8;
++ const Flags INDEX_TYPE_FLAG = 16;	///< internal index type, only used as an optimization for faster name -> local index lookup
+++const Flags ACCESSOR_FLAG = 32;       ///< property stores accessor pair
++ const Flags STANDARD_FLAGS = EXISTS_FLAG;	///< use with setOwnProperty()
++ const Flags HIDDEN_CONST_FLAGS = READ_ONLY_FLAG | DONT_ENUM_FLAG | DONT_DELETE_FLAG | EXISTS_FLAG;
++ const Flags NONEXISTENT = 0;		///< use with getOwnProperty() to check for existence, e.g. getOwnProperty(o, k, v) != NONEXISTENT
++ const UInt32 TABLE_BUILT_IN_N = 3; ///< 1 << 3 == 8
++ 
+++class Accessor;
++ /**
++ 	Table implements a hash table for storing object properties. It provides fast lookup and is used internally by JS
++ 	objects.
++@@ -538,13 +540,16 @@ class Object : public GCItem {
++ 		virtual Object* getPrototype(Runtime& rt) const;		///< Default returns the Object prototype.
++ 
++ 		virtual Flags getOwnProperty(Runtime& rt, const Value& key, Value* v) const;								///< Don't touch v if you return NONEXISTENT. Default returns NONEXISTENT.
+++		virtual bool setOwnProperty(Runtime& rt, const String* key, const Value& v, Flags flags = STANDARD_FLAGS);	///< Insert a new or update an existing property. Return false if not possible (e.g. read-only property already exists). Default returns false.
++ 		virtual bool setOwnProperty(Runtime& rt, const Value& key, const Value& v, Flags flags = STANDARD_FLAGS);	///< Insert a new or update an existing property. Return false if not possible (e.g. read-only property already exists). Default returns false.
++ 		virtual bool updateOwnProperty(Runtime& rt, const Value& key, const Value& v);								///< Update existing property. Return false if it doesn't exist or can't be updated (e.g. read-only property exists). Can be overriden for optimization. (Default implementation checks existence with hasOwnProperty() first.)
++ 		virtual bool deleteOwnProperty(Runtime& rt, const Value& key);												///< Default returns false.
++ 		virtual Enumerator* getOwnPropertyEnumerator(Runtime& rt) const;											///< Default returns an empty enumerator.
++ 
++ 		Flags getProperty(Runtime& rt, const Value& key, Value* v) const; 	///< Searches prototype chain.
+++		Flags getProperty(Runtime& rt, Processor& processor, const Value& key, Value* v) const;
++ 		bool setProperty(Runtime& rt, const Value& key, const Value& v); 	///< First tries updateOwnProperty(). If that fails, checks prototype chain for read-only property with the same name and returns false if found. Otherwise attempts to insert a new property with setOwnProperty() and returns its outcome.
+++		bool setProperty(Runtime& rt, Processor& processor, const Value& key, const Value& v);
++ 		bool isOwnPropertyEnumerable(Runtime& rt, const Value& key) const;
++ 		bool hasOwnProperty(Runtime& rt, const Value& key) const; 			///< Checks via getOwnProperty().
++ 		bool hasProperty(Runtime& rt, const Value& key) const;				///< Checks via getProperty().
++@@ -707,6 +712,7 @@ class JSObject : public Object, public Table {
++ 		JSObject(GCList& gcList, Object* prototype);
++ 		virtual Object* getPrototype(Runtime& rt) const;
++ 		virtual Flags getOwnProperty(Runtime& rt, const Value& key, Value* v) const;
+++		virtual bool setOwnProperty(Runtime& rt, const String* key, const Value& v, Flags flags = STANDARD_FLAGS);
++ 		virtual bool setOwnProperty(Runtime& rt, const Value& key, const Value& v, Flags flags = STANDARD_FLAGS);
++ 		virtual bool updateOwnProperty(Runtime& rt, const Value& key, const Value& v);
++ 		virtual bool deleteOwnProperty(Runtime& rt, const Value& key);
++@@ -742,6 +748,7 @@ template<class SUPER> class LazyJSObject : public SUPER {
++ 		typedef SUPER super;
++ 		LazyJSObject(GCList& gcList) : super(gcList), completeObject(0) { }
++ 		virtual Flags getOwnProperty(Runtime& rt, const Value& key, Value* v) const;
+++		virtual bool setOwnProperty(Runtime& rt, const String* key, const Value& v, Flags flags = STANDARD_FLAGS);
++ 		virtual bool setOwnProperty(Runtime& rt, const Value& key, const Value& v, Flags flags = STANDARD_FLAGS);
++ 		virtual bool deleteOwnProperty(Runtime& rt, const Value& key);
++ 		virtual Enumerator* getOwnPropertyEnumerator(Runtime& rt) const;
++@@ -773,6 +780,7 @@ class JSArray : public LazyJSObject<Object> {
++ 		virtual Object* getPrototype(Runtime& rt) const;
++ 		// FIX : toString too?
++ 		virtual Flags getOwnProperty(Runtime& rt, const Value& key, Value* v) const;
+++		virtual bool setOwnProperty(Runtime& rt, const String* key, const Value& v, Flags flags = STANDARD_FLAGS);
++ 		virtual bool setOwnProperty(Runtime& rt, const Value& key, const Value& v, Flags flags = STANDARD_FLAGS);
++ 		virtual bool updateOwnProperty(Runtime& rt, const Value& key, const Value& v);
++ 		virtual bool deleteOwnProperty(Runtime& rt, const Value& key);
++@@ -833,6 +841,8 @@ class Code : public Object {
++ 		const String* getName() const { return name; }
++ 		const String* getSource() const { return source; }
++ 		UInt32 getMaxStackDepth() const { return maxStackDepth; }
+++		bool isStrict() const { return strict; }
+++		void setStrict(bool v) { strict = v; }
++ 		UInt32 calcLocalsSize(UInt32 argc) const { return getVarsCount() + std::max(getArgumentsCount(), argc); }
++ 
++ 	protected:
++@@ -846,6 +856,7 @@ class Code : public Object {
++ 		const String* source;
++ 		UInt32 bloomSet;							///< Bloom bits of all local variables, arguments (+ self name and "arguments"). For faster scope resolution.
++ 		UInt32 maxStackDepth;
+++		bool strict;
++ 
++ 		virtual void gcMarkReferences(Heap& heap) const {
++ 			gcMark(heap, constants);
++@@ -883,6 +894,20 @@ class Function : public Object {
++ 		Function(GCList& gcList) : super(gcList) { }
++ };
++ 
+++class Accessor : public Object {
+++	public:
+++		Accessor(GCList& gcList, Function* g, Function* s)
+++			: Object(gcList), getter(g), setter(s) { }
+++		Function* getter;
+++		Function* setter;
+++	protected:
+++		virtual void gcMarkReferences(Heap& heap) const {
+++			gcMark(heap, getter);
+++			gcMark(heap, setter);
+++			super::gcMarkReferences(heap);
+++		}
+++};
+++
++ typedef Value (*NativeFunction)(Runtime&, Processor&, UInt32, const Value*, Object*);
++ 
++ // FIX : overkill?
++@@ -983,6 +1008,7 @@ class Error : public LazyJSObject<Object> {
++ 		virtual const String* toString(Heap& heap) const;
++ 		virtual Value getInternalValue(Heap& heap) const; // error type name
++ 		virtual Object* getPrototype(Runtime& rt) const;
+++		virtual bool setOwnProperty(Runtime& rt, const String* key, const Value& v, Flags flags = STANDARD_FLAGS);
++ 		virtual bool setOwnProperty(Runtime& rt, const Value& key, const Value& v, Flags flags = STANDARD_FLAGS);
++ 		virtual bool deleteOwnProperty(Runtime& rt, const Value& key);
++ 		ErrorType getErrorType() const;
++@@ -1007,12 +1033,14 @@ class FunctionScope;
++ class Arguments : public LazyJSObject<Object> {
++ 	public:
++ 		typedef LazyJSObject<Object> super;
+++		friend class FunctionScope;
++ 
++         Arguments(GCList& gcList, const FunctionScope* scope, UInt32 argumentsCount);
++ 		virtual const String* getClassName() const;	// &A_RGUMENTS_STRING
++ 		virtual const String* toString(Heap& heap) const;
++ 		virtual Object* getPrototype(Runtime& rt) const;
++ 		virtual Flags getOwnProperty(Runtime& rt, const Value& key, Value* v) const;
+++		virtual bool setOwnProperty(Runtime& rt, const String* key, const Value& v, Flags flags = STANDARD_FLAGS);
++ 		virtual bool setOwnProperty(Runtime& rt, const Value& key, const Value& v, Flags flags = STANDARD_FLAGS);
++ 		virtual bool deleteOwnProperty(Runtime& rt, const Value& key);
++ 		virtual Enumerator* getOwnPropertyEnumerator(Runtime& rt) const;
++@@ -1027,6 +1055,7 @@ class Arguments : public LazyJSObject<Object> {
++ 		UInt32 const argumentsCount;
++ 		Vector<Byte> deletedArguments;
++ 		Vector<Value> values;	// Contains copied values after the Argument has been detached from its closure.
+++		FunctionScope* owner;	// Weak reference to owning FunctionScope for cleanup.
++ 
++ 		/**
++ 			Notice that we do not mark the scope reference, thus creating a "weak" reference that is handled by
++@@ -1133,7 +1162,7 @@ class Runtime : public GCItem {
++ 		JSArray* newJSArray(UInt32 initialLength = 0) const;	///< Convenience routine for `new(heap) JSArray(heap.managed(), initialLength)`
++ 		const String* newStringConstant(const char* s);
++ 
++-		Code* compileEvalCode(const String* expression);
+++		Code* compileEvalCode(const String* expression, bool strict = false);
++ 		Code* compileGlobalCode(const String& source, const String* filename = 0);
++ 
++ 		Var getGlobalsVar();							///< Convenience routine for `Var(rt, rt.getGlobalObject())`
++@@ -1338,14 +1367,42 @@ class Property : public AccessorBase {
++ 	friend class AccessorBase;
++ 
++   public:
++-		template<typename T> const Property& operator=(const T& v) const { object->setProperty(rt, key, Var(rt, v)); return *this; }
++-		template<typename T> const Property& operator+=(const T& r) const { object->setProperty(rt, key, get().add(rt.getHeap(), makeValue(r))); return *this; }
+++	template <typename T> const Property &operator=(const T &v) const {
+++		Value current;
+++		Flags flags = object->getProperty(rt, key, &current);
+++		if (flags != NONEXISTENT && (flags & ACCESSOR_FLAG) != 0) {
+++			Accessor *acc = static_cast<Accessor *>(current.asObject());
+++			Function *setter = (acc != 0 ? acc->setter : 0);
+++			if (setter != 0) {
+++				Value arg = Var(rt, v);
+++				rt.call(setter, 1, &arg, object);
+++				return *this;
+++			}
+++		}
+++		object->setProperty(rt, key, Var(rt, v));
+++		return *this;
+++	}
+++	template <typename T> const Property &operator+=(const T &r) const {
+++		object->setProperty(rt, key, get().add(rt.getHeap(), makeValue(r)));
+++		return *this;
+++	}
++ 
++   protected:
++ 	typedef AccessorBase super;
++ 	Property(Runtime &rt, Object *object, const Var &key) : super(rt), object(object), key(key) {}
++-		virtual Value get() const { Value v(UNDEFINED_VALUE); object->getProperty(rt, key, &v); return v; }
++-		virtual Var call(int argc, const Value* argv) const { return rt.call(*this, argc, argv, object); }
+++	virtual Value get() const {
+++		Value v(UNDEFINED_VALUE);
+++		Flags flags = object->getProperty(rt, key, &v);
+++		if (flags != NONEXISTENT && (flags & ACCESSOR_FLAG) != 0) {
+++			Accessor *acc = static_cast<Accessor *>(v.asObject());
+++			Function *getter = (acc != 0 ? acc->getter : 0);
+++			return (getter != 0 ? rt.call(getter, 0, 0, object) : UNDEFINED_VALUE);
+++		}
+++		return v;
+++	}
+++	virtual Var call(int argc, const Value *argv) const {
+++		return rt.call(*this, argc, argv, object);
+++	}
++ 	Object *const object;
++ 	const Var key;
++ };
++@@ -1531,6 +1588,8 @@ class Processor : public GCItem {
++ 			, SET_PROPERTY_OP								// stack: object, name, value -> value
++ 			, SET_PROPERTY_POP_OP							// stack: object, name, value ->
++ 			, ADD_PROPERTY_OP								// operand: const_index (name), stack: object, value -> object
+++							, ADD_GETTER_OP						// operand: const_index(name), stack: object, function -> object
+++							, ADD_SETTER_OP						// operand: const_index(name), stack: object, function -> object
++ 			, PUSH_ELEMENTS_OP								// operand: count, stack: object, count * elements ... -> object
++ 			, OBJ_TO_PRIMITIVE_OP							// stack: value -> primitive_value (no preference)	// these three must be in this exact order
++ 			, OBJ_TO_NUMBER_OP								// stack: value -> primitive_value (number preferred)
++@@ -1585,7 +1644,12 @@ class Processor : public GCItem {
++ 		};
++ 	
++ 		struct OpcodeInfo {
++-			enum { TERMINAL = 1, POP_OPERAND = 2, POP_ON_BRANCH = 4, NO_POP_ON_BRANCH = 8 };
+++			enum {
+++				TERMINAL = 1,			/// instruction ends current basic block
+++				POP_OPERAND = 2,	/// pop `operand` values after execution
+++				POP_ON_BRANCH = 4,	/// branch path pops the top of stack
+++				NO_POP_ON_BRANCH = 8	/// branch path keeps the top of stack
+++			};
++ 			Opcode opcode;
++ 			const char* mnemonic;
++ 			Int32 stackUse;
++@@ -1600,12 +1664,13 @@ class Processor : public GCItem {
++ 		Processor(Runtime& rt);
++ 		void invokeFunction(Function* f, Int32 argc, const Value* argv, Object* thisObject = 0);
++ 		void enterGlobalCode(const Code* code);
++-		void enterEvalCode(const Code* code, bool local = false);
+++		void enterEvalCode(const Code* code, bool direct = false);
++ 		void enterFunctionCode(JSFunction* func, UInt32 argc, const Value* argv, Object* thisObject = 0);
++ 		void throwVirtualException(const Value& exception);
++ 		void error(ErrorType errorType, const String* message = 0);
++ 		bool run(Int32 maxCycles);
++ 		Value getResult() const;	// make sure you've called run() until it returns false before calling this
+++		bool isCurrentStrict() const { return currentFrame != 0 && currentFrame->code->isStrict(); }
++ 
++ 	protected:
++ 		struct Frame : public GCItem {
++diff --git a/src/stdlib.js b/src/stdlib.js
++index 2c8acffc9..0571ba0d2 100644
++--- a/src/stdlib.js
+++++ b/src/stdlib.js
++@@ -2,24 +2,24 @@
++ 	@preserve: Array,Boolean,Date,E,Error,Function,Infinity,LN10,LN2,LOG10E,LOG2E,MAX_VALUE,MIN_VALUE,Math
++ 	@preserve: NEGATIVE_INFINITY,NaN,Number,Object,PI,POSITIVE_INFINITY,RangeError,RegExp,SQRT1_2,SQRT2,String
++ 	@preserve: SyntaxError,TypeError,UTC,abs,acos,apply,arguments,asin,atan,atan2,break,call,callWithArgs,case,ceil
++-	@preserve: charAt,charCodeAt,configurable,concat,cos,default,defineProperty,delete,do,dontDelete,dontEnum
++-	@preserve: else,enumerable,eval,exec,exp,false,finally,floor,for,fromCharCode,function,getCurrentTime
+++	@preserve: charAt,charCodeAt,configurable,concat,cos,default,defineProperty,delete,do,dontDelete,dontEnum,get,set
+++	@preserve: else,enumerable,eval,exec,exp,false,finally,floor,for,forEach,fromCharCode,function,getCurrentTime
++ 	@preserve: getDate,getDay,getFullYear,getHours,getInternalProperty,getMilliseconds,getMinutes,getMonth
++ 	@preserve: getPrototypeOf,getSeconds,getTime,getTimezoneOffset,getUTCDate,getUTCDay,getUTCFullYear,getUTCHours
++ 	@preserve: getUTCMilliseconds,getUTCMinutes,getUTCMonth,getUTCSeconds,hasOwnProperty,if,ignoreCase,in,index,indexOf
++-	@preserve: input,isArray,isFinite,isNaN,isPropertyEnumerable,join,lastIndex,lastIndexOf,length,localeCompare,log
++-	@preserve: match,max,maxNumber,message,min,minNumber,multiline,name,new,null,parseFloat,parseInt,pow
+++        @preserve: input,isArray,isFinite,isNaN,isPropertyEnumerable,join,lastIndex,lastIndexOf,length,localeCompare,log,keys
+++	@preserve: match,max,maxNumber,message,min,minNumber,multiline,name,new,now,null,parseFloat,parseInt,pow
++ 	@preserve: propertyIsEnumerable,prototype,push,readOnly,regExpCanonicalize,return,reverse,round,setDate
++ 	@preserve: setFullYear,setHours,setMilliseconds,setMinutes,setMonth,setSeconds,setTime,setUTCDate
++ 	@preserve: setUTCFullYear,setUTCHours,setUTCMilliseconds,setUTCMinutes,setUTCMonth,setUTCSeconds,shift,sin,slice
++ 	@preserve: sort,distinctConstructor,sqrt,submatch,substr,substring,switch,tan,this,throw,time,toExponential
++ 	@preserve: toFixed,toISOString,toLocaleDateString,toLocaleLowerCase,toLocaleString,toLocaleTimeString
++-	@preserve: toLocaleUpperCase,toLowerCase,toPrecision,toString,toTimeString,toUTCString,toUpperCase,true,try,typeof
+++	@preserve: toLocaleUpperCase,toLowerCase,toPrecision,toString,toTimeString,toUTCString,toUpperCase,trim,trimLeft,trimRight,true,try,typeof
++ 	@preserve: undefined,upperToLower,value,valueOf,var,void,while,writable,pop,parse,toDateString,instanceof,test
++ 	@preserve: toPrimitiveNumber,toPrimitiveString,constructor,isPrototypeOf,prototypes,createWrapper,$match
++ @preserve: $sub,createRegExp,CC,global,source,JSON,stringify,toJSON,unshift,compileFunction,localTimeDifference
++ @preserve: splice,split,search,replace,random,evalFunction,updateDateValue,toPrimitive
++-
+++@preserve: every,some,filter,map,reduce,reduceRight
++ support: {
++ 	prototypes: {	// built-in prototype objects
++ 	object, function, string, boolean, number, date, array
++@@ -60,19 +60,15 @@
++ 	Infinity
++ 	}
++ 	*/
++-
++ 	(function(support) {
++-
++ 	var globals = this;
++ 	var unconstructable = support.distinctConstructor; // these are the same now, but not guaranteed in the future
++-
++ 	var $isNaN = support.isNaN, $isFinite = support.isFinite, $floor = support.floor, $NaN = support.NaN
++ 	, $Infinity = support.Infinity, $match = support.submatch, $sub = support.substring // "$match" and "$sub" are used from within regexps, so names has to be preserved
++ 	, $getInternalProperty = support.getInternalProperty, $callWithArgs = support.callWithArgs
++ 	, $charCodeAt = support.charCodeAt, abs, syntaxError, rangeError, typeError
++ 	, ALPHA_DIGITS_LOWER = "0123456789abcdefghijklmnopqrstuvwxyz", ALPHA_DIGITS_UPPER = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
++ 	, WHITE_SPACES = " \f\n\r\t\v\xA0\u2028\u2029";
++-
++ 	var PARSE_INT_CHARS = (function() {
++ 	var pic = { }, ws = WHITE_SPACES;
++ 	for (var i = ws.length - 1; i >= 0; --i) {
++@@ -85,7 +81,6 @@ var PARSE_INT_CHARS = (function() {
++ 	}
++ 	return pic
++ 	})();
++-
++ 	function StringBuilder() {
++ 	var i = 20, b = this.buffers = [ ];
++ 	do { b[--i] = '' } while (i > 0)
++@@ -102,12 +97,10 @@ StringBuilder.prototype.build = function build() {
++ 	do { s += b[--i] } while (i > 0);
++ 	return s
++ 	};
++-
++ 	function isPrimitive(v) {
++ 	var v, t;
++ 	return (((t = typeof v) !== "object" || v === null) && t !== "function")
++ 	}
++-
++ 	function objectToPrimitive(o, f1, f2) {
++ 	var v;
++ 	if ((typeof (o[f1]) !== "function" || !isPrimitive(v = o[f1]()))
++@@ -116,34 +109,27 @@ function objectToPrimitive(o, f1, f2) {
++ 	}
++ 	return v
++ 	}
++-
++ 	support.toPrimitiveNumber = function(o) { return objectToPrimitive(o, "valueOf", "toString"); };
++ 	support.toPrimitiveString = function(o) { return objectToPrimitive(o, "toString", "valueOf"); };
++ 	support.toPrimitive = function(o) {
++ 	return support[$getInternalProperty(o, "class") === "Date" ? "toPrimitiveString" : "toPrimitiveNumber"](o);
++ 	};
++-
++ 	function int(v) { return $isNaN(v = +v) ? 0 : (!$isFinite(v) ? v : (v < 0 ? -$floor(-v) : $floor(v))); }
++ 	function int32(v) { return int(v) | 0; }
++ 	function uint32(v) { return int(v) >>> 0; }
++-
++ 	// TODO : what a waste of cycles, could be a simple OBJ_TO_STRING, problem with ''+s is that it uses OBJ_TO_NUMBER which only affects the priority of toString vs valueOf... so subtle!
++ 	function str(o) { return '' + (isPrimitive(o) ? o : support.toPrimitiveString(o)) }
++-
++ 	function defineProperties(object, attribs, props) {
++ 	var ro = attribs.readOnly, de = attribs.dontEnum, dd = attribs.dontDelete;
++ 	for (var p in props) support.defineProperty(object, p, props[p], ro, de, dd);
++ 	return object
++ 	}
++-
++ 	function checkClass(object, expectedClass, forFunction) {
++ 	if ($getInternalProperty(object, "class") !== expectedClass) {
++ 	throw typeError(expectedClass + ".prototype." + forFunction + " is not generic");
++ 	}
++ 	}
++-
++ 	function leftPad(s, l) { var n = (s = "00000000000000000000" + s).length; return $sub(s, n - l, n); }
++-
++ 	function numberToString(num, digits, eNotationBelow) {
++ 	var string = '';
++ 	if (num < 0) {
++@@ -187,7 +173,6 @@ function numberToString(num, digits, eNotationBelow) {
++ 	if (exponent !== null) string += (exponent >= 0 ? "e+" : 'e') + exponent;
++ 	return string
++ 	}
++-
++ 	function numberToRadix(val, radix) {
++ 	var sign = '', s = '';
++ 	if ((val = int(val)) < 0) {
++@@ -197,16 +182,13 @@ function numberToRadix(val, radix) {
++ 	do { s = ALPHA_DIGITS_LOWER[val % radix] + s } while ((val = $floor(val / radix)) > 0);
++ 	return sign + s;
++ 	}
++-
++ 	// eval without loads of local variables but with access to all internals
++ 	function evalThere(s) {
++ 	var customEval = eval;
++ 	eval = support.evalFunction; // must reassign for "direct mode" eval
++ 	try { return eval(s); } finally { eval = customEval; }
++ 	}
++-
++ 	/* --- Object --- */
++-
++ 	var Object = function Object(v) {
++ 	switch (typeof v) {
++ 	case "object":
++@@ -235,9 +217,7 @@ defineProperties(Object.prototype, { dontEnum: true }, {
++ 	return false;
++ 	})
++ 	});
++-
++ 	/* --- Function --- */
++-
++ 	var Function = function Function(body) {
++ 	var argv, src = '(', n = (argv = arguments).length - 1;
++ 	for (var i = 0; i < n; ++i) {
++@@ -267,9 +247,7 @@ defineProperties(Function.prototype, { dontEnum: true }, {
++ 	return $getInternalProperty(this, "value");
++ 	})
++ 	});
++-
++ 	/* --- Boolean --- */
++-
++ 	var Boolean = support.distinctConstructor(function Boolean(v) {
++ 	return !!v;
++ 	}, function Boolean(v) {
++@@ -287,14 +265,11 @@ defineProperties(Boolean.prototype, { dontEnum: true }, {
++ 	return '' + $getInternalProperty(this, "value");
++ 	})
++ 	});
++-
++ 	/* --- Number --- */
++-
++ 	function getInternalNumber(object, forFunction) {
++ 	checkClass(object, "Number", forFunction);
++ 	return $getInternalProperty(object, "value")
++ 	}
++-
++ 	var Number = support.distinctConstructor(function Number(v) {
++ 	return (arguments.length ? +v : 0);
++ 	}, function Number(v) {
++@@ -362,11 +337,8 @@ defineProperties(Number.prototype, { dontEnum: true }, {
++ 	}
++ 	})
++ 	});
++-
++ 	/* --- String --- */
++-
++ 	var lowerToUpper, upperToLower; // "upperToLower" is used from within regexps, so the name has to be preserved
++-
++ 	function createCaseTables() {
++ 	// In the future constant tables might be (nearly) free to setup, but as of 20160423 this is quite "expensive".
++ 	lowerToUpper = {
++@@ -405,23 +377,19 @@ function createCaseTables() {
++ 	};
++ 	for (c in BIDIRECTIONAL) lowerToUpper[upperToLower[c] = BIDIRECTIONAL[c]] = c
++ 	};
++-
++ 	function translateString(string, table) {
++ 	var i = -1, len = string.length, s = '', t, c;
++ 	while (++i < len) s += (t = table[c = string[i]]) ? t : c;
++ 	return s
++ 	}
++-
++ 	function toLower(o) {
++ 	if (!lowerToUpper) createCaseTables();
++ 	return translateString(str(o), upperToLower);
++ 	}
++-
++ 	function toUpper(o) {
++ 	if (!lowerToUpper) createCaseTables();
++ 	return translateString(str(o), lowerToUpper);
++ 	}
++-
++ 	var String = support.distinctConstructor(function String(v) {
++ 	return (arguments.length ? str(v) : '');
++ 	}, function String(v) {
++@@ -589,6 +557,34 @@ defineProperties(String.prototype, { dontEnum: true }, {
++ 	toLocaleUpperCase: unconstructable(function toLocaleUpperCase() { return toUpper(this) }),
++ 	toLowerCase: unconstructable(function toLowerCase() { return toLower(this) }),
++ 	toLocaleLowerCase: unconstructable(function toLocaleLowerCase() { return toLower(this) }),
+++	trimLeft: unconstructable(function trimLeft() {
+++	var s = str(this), i = 0, j = s.length, c;
+++	for (; i < j; ++i) {
+++	c = s.charCodeAt(i);
+++	if (c !== 0x20 && (c < 0x09 || c > 0x0D) && c !== 0xA0 && c !== 0x2028 && c !== 0x2029 && c !== 0xFEFF) break;
+++	}
+++	return $sub(s, i, j);
+++	}),
+++	trimRight: unconstructable(function trimRight() {
+++	var s = str(this), j = s.length, c;
+++	for (; j > 0; --j) {
+++	c = s.charCodeAt(j - 1);
+++	if (c !== 0x20 && (c < 0x09 || c > 0x0D) && c !== 0xA0 && c !== 0x2028 && c !== 0x2029 && c !== 0xFEFF) break;
+++	}
+++	return $sub(s, 0, j);
+++	}),
+++	trim: unconstructable(function trim() {
+++	var s = str(this), i = 0, j = s.length, c;
+++	for (; i < j; ++i) {
+++	c = s.charCodeAt(i);
+++	if (c !== 0x20 && (c < 0x09 || c > 0x0D) && c !== 0xA0 && c !== 0x2028 && c !== 0x2029 && c !== 0xFEFF) break;
+++	}
+++	for (; j > i; --j) {
+++	c = s.charCodeAt(j - 1);
+++	if (c !== 0x20 && (c < 0x09 || c > 0x0D) && c !== 0xA0 && c !== 0x2028 && c !== 0x2029 && c !== 0xFEFF) break;
+++	}
+++	return $sub(s, i, j);
+++	}),
++ 	valueOf: unconstructable(function valueOf() {
++ 	checkClass(this, "String", "valueOf");
++ 	return $getInternalProperty(this, "value");
++@@ -598,9 +594,7 @@ defineProperties(String.prototype, { dontEnum: true }, {
++ 	return $getInternalProperty(this, "value");
++ 	})
++ 	});
++-
++ 	/* --- Array --- */
++-
++ 	var Array = function Array(v) {
++ 	var a = [ ], argv, argc;
++ 	if ((argc = (argv = arguments).length) === 1 && typeof v === "number") {
++@@ -764,11 +758,75 @@ defineProperties(Array.prototype, { dontEnum: true }, {
++ }
++ for (var i = 0; i < n; ++i) this[i] = argv[i];
++ return (this.length = len + n);
+++	}),
+++	forEach: unconstructable(function forEach(callbackfn) { // .length should be 1
+++	var o = Object(this), len = uint32(o.length), t = arguments[1];
+++	if (typeof callbackfn !== "function") throw TypeError();
+++	for (var k = 0; k < len; ++k) if (k in o) callbackfn.call(t, o[k], k, o);
+++	}),
+++	map: unconstructable(function map(callbackfn) { // .length should be 1
+++	var o = Object(this), len = uint32(o.length), t = arguments[1], a = new Array(len);
+++	if (typeof callbackfn !== "function") throw TypeError();
+++	for (var k = 0; k < len; ++k) if (k in o) a[k] = callbackfn.call(t, o[k], k, o);
+++	return a;
+++	}),
+++	filter: unconstructable(function filter(callbackfn) { // .length should be 1
+++	var o = Object(this), len = uint32(o.length), t = arguments[1], a = [], to = 0;
+++	if (typeof callbackfn !== "function") throw TypeError();
+++	for (var k = 0; k < len; ++k) if (k in o) { var v = o[k]; if (callbackfn.call(t, v, k, o)) a[to++] = v; }
+++	a.length = to;
+++	return a;
+++	}),
+++	indexOf: unconstructable(function indexOf(searchElement) {
+++	var len = uint32(this.length), i = arguments[1];
+++	if (len === 0) return -1;
+++	if ((i = int(i)) < 0) { i += len; if (i < 0) i = 0; }
+++	for (; i < len; ++i) if (i in this && this[i] === searchElement) return i;
+++	return -1;
+++	}),
+++lastIndexOf: unconstructable(function lastIndexOf(searchElement) {
+++var len = uint32(this.length), i = arguments[1];
+++if (len === 0) return -1;
+++if (i === void 0) i = len - 1; else { i = int(i); if (i < 0) i += len; if (i >= len) i = len - 1; }
+++for (; i >= 0; --i) if (i in this && this[i] === searchElement) return i;
+++return -1;
+++}),
+++	reduce: unconstructable(function reduce(callbackfn) { // .length should be 1
+++	var o = Object(this), len = uint32(o.length), k = 0, acc;
+++	if (typeof callbackfn !== "function") throw TypeError();
+++	if (arguments.length > 1) acc = arguments[1]; else {
+++	while (k < len && !(k in o)) ++k;
+++	if (k >= len) throw TypeError();
+++	acc = o[k++];
+++	}
+++	for (; k < len; ++k) if (k in o) acc = callbackfn.call(void 0, acc, o[k], k, o);
+++	return acc;
+++	}),
+++	reduceRight: unconstructable(function reduceRight(callbackfn) { // .length should be 1
+++	var o = Object(this), len = uint32(o.length), k = len - 1, acc;
+++	if (typeof callbackfn !== "function") throw TypeError();
+++	if (arguments.length > 1) acc = arguments[1]; else {
+++	while (k >= 0 && !(k in o)) --k;
+++	if (k < 0) throw TypeError();
+++	acc = o[k--];
+++	}
+++	for (; k >= 0; --k) if (k in o) acc = callbackfn.call(void 0, acc, o[k], k, o);
+++	return acc;
+++	}),
+++	every: unconstructable(function every(callbackfn) { // .length should be 1
+++	var o = Object(this), len = uint32(o.length), t = arguments[1];
+++	if (typeof callbackfn !== "function") throw TypeError();
+++	for (var k = 0; k < len; ++k) if (k in o && !callbackfn.call(t, o[k], k, o)) return false;
+++	return true;
+++	}),
+++	some: unconstructable(function some(callbackfn) { // .length should be 1
+++	var o = Object(this), len = uint32(o.length), t = arguments[1];
+++	if (typeof callbackfn !== "function") throw TypeError();
+++	for (var k = 0; k < len; ++k) if (k in o && callbackfn.call(t, o[k], k, o)) return true;
+++	return false;
++ 	})
++ });
++-
++ 	/* --- Date --- */
++-
++ 	function localMaxDiff() { // local max is during DST
++ 	var startOfYearDiff = support.localTimeDifference(14516064e5); // 2016-01-01T00:00:00.000Z
++ 	var midOfYearDiff = support.localTimeDifference(14673312e5); // 2016-07-01T00:00:00.000Z
++@@ -781,18 +839,15 @@ function localMinDiff() { // local min is timezone (non DST)
++ 	}
++ 	function localTimeDiff(z) { var l = support.localTimeDifference(z); return ($isNaN(l) ? localMinDiff() : l) }
++ 	function toLocalTime(z) { return $isNaN(z) ? z : z + localTimeDiff(z) }
++-
++ 	function checkDateClass(object) {
++ 	if ($getInternalProperty(object, "class") !== "Date") throw typeError("this is not a Date object");
++ 	}
++-
++ 	function getDateValue(object) { checkDateClass(object); return $getInternalProperty(object, "value"); }
++ 	function getLocalDateValue(object) { return toLocalTime(getDateValue(object)); }
++ 	function setDateValue(object, v) { checkDateClass(object); support.updateDateValue(object, v); return v; }
++ 	function localDateTimeToString(v) {
++ 	return $isNaN(v = toLocalTime(v)) ? "Invalid Date" : (epochToDateString(v) + ' ' + epochToTimeString(v));
++ 	}
++-
++ 	function floorMod(x, n) { return (x % n + n) % n }
++ 	function epochFromTime(hour, minute, second, ms) { return hour * 36e5 + minute * 6e4 + second * 1e3 + ms }
++ 	function timeFromEpoch(z) { return [ floorMod($floor(z / 36e5), 24), floorMod($floor(z / 6e4), 60), floorMod($floor(z / 1e3), 60), floorMod(z, 1e3) ] }
++@@ -804,7 +859,6 @@ function secFromTime(z) { return floorMod($floor(z / 1e3), 60) }
++ 	function msFromTime(z) { return floorMod(z, 1e3) }
++ 	function timeClip(z) { return (!$isFinite(z) || abs(z) > 8.64e15 ? $NaN : int(z)) }
++ 	function timeClipLocal(z) { return fromLocalTime(timeClip(z)); }
++-
++ 	function dateFromEpoch(z) {
++ 	z = $floor(z / 864e5) + 719468;
++ 	var era = int( (z >= 0 ? z : z - 146096) / 146097 );
++@@ -817,19 +871,16 @@ function dateFromEpoch(z) {
++ 	var d = doy - int( (153 * mp + 2) / 5 ) + 1;
++ 	return [ (y + (m <= 1)), m, d ];
++ 	}
++-
++ 	function epochToDateString(z) {
++ 	var y, dt = dateFromEpoch(z);
++ 	return (0 <= (y = dt[0]) && y <= 9999 ? leftPad(y, 4) : (y < 0 ? "-" : "+") + leftPad(abs(y), 6))
++ 	+ "-" + leftPad(dt[1] + 1, 2) + "-" + leftPad(dt[2], 2);
++ 	}
++-
++ 	function epochToTimeString(z, ms) {
++ 	var tm = timeFromEpoch(z);
++ 	return leftPad(tm[0], 2) + ":" + leftPad(tm[1], 2) + ":" + leftPad(tm[2], 2)
++ 	+ (ms ? "." + leftPad($sub(tm[3], 0, 3), 3) : "")
++ 	}
++-
++ 	function epochFromDate(year, month, day) {
++ 	year += $floor(month / 12) - (floorMod(month, 12) <= 1);
++ 	var era = int( (year >= 0 ? year : year - 399) / 400 );
++@@ -838,31 +889,26 @@ function epochFromDate(year, month, day) {
++ 	var doe = yoe * 365 + int(yoe / 4) - int(yoe / 100) + doy;
++ 	return (era * 146097 + doe - 719468) * 864e5;
++ 	}
++-
++ 	function setDateParts(z, n, a) {
++ 	var i, d = dateFromEpoch(z), r = floorMod(z, 864e5);
++ 	for (i = 0; i < a.length; ++i, ++n) d[n] = int(a[i]);
++ 	return $callWithArgs(epochFromDate, null, d) + r;
++ 	}
++-
++ 	function setTimeParts(z, n, a) {
++ 	var i, t = timeFromEpoch(z), r = $floor(z / 864e5) * 864e5;
++ 	for (i = 0; i < a.length; ++i, ++n) t[n] = int(a[i]);
++ 	return $callWithArgs(epochFromTime, null, t) + r;
++ 	}
++-
++ 	function makeDateTime(year, month, date, hours, minutes, seconds, ms) {
++ 	var argc = arguments.length;
++ 	return epochFromDate( (year = int(year)) + (0 <= year && year <= 99 ? 1900 : 0),
++ 	int(month), (argc > 2 ? int(date) : 1)) + epochFromTime( argc > 3 ? int(hours) : 0,
++ 	argc > 4 ? int(minutes) : 0, argc > 5 ? int(seconds) : 0, argc > 6 ? int(ms) : 0);
++ 	}
++-
++ 	function isoDate(d) {
++ 	var z;
++ 	return $isNaN(z = getDateValue(d)) ? null : epochToDateString(z) + "T" + epochToTimeString(z, true) + "Z";
++ 	}
++-
++ 	var parseDate, Date = support.distinctConstructor(function Date() {
++ 	return localDateTimeToString(support.getCurrentTime());
++ 	}, function Date(year, month, date, hours, minutes, seconds, ms) {
++@@ -872,7 +918,6 @@ var parseDate, Date = support.distinctConstructor(function Date() {
++ 	else v = support.getCurrentTime();
++ 	return support.createWrapper("Date", v, support.prototypes.Date);
++ 	});
++-
++ 	defineProperties(Date, { dontEnum: true, readOnly: true, dontDelete: true }, { prototype: support.prototypes.Date });
++ 	defineProperties(Date, { dontEnum: true }, {
++ 	parse: unconstructable(parseDate = function parse(s) {
++@@ -891,9 +936,7 @@ defineProperties(Date, { dontEnum: true }, {
++ 	s[i] === ":" && (++i, readPart(2)) || 0,
++ 	s[i] === ":" && (++i, readPart(2)) || 0,
++ 	s[i] === "." && (++i, readPart(3)) || 0);
++-
++ 	while ((ch = s[i]) !== void 0 && ch !== "Z" && ch !== "z" && ch !== "+" && ch !== "-") ++i;
++-
++ 	if (ch === "Z" || ch === "z") tz = 0;
++ 	else if (ch === "+" || ch === "-") {
++ 	++i, tzh = readPart(2) * 36e5,
++@@ -904,9 +947,11 @@ defineProperties(Date, { dontEnum: true }, {
++ 	}),
++ 	UTC: unconstructable(function UTC(year, month, date, hours, minutes, seconds, ms) {
++ 		return timeClip(makeDateTime(year, month, date, hours, minutes, seconds, ms))
+++	}),
+++	now: unconstructable(function now() {
+++		return support.getCurrentTime();
++ 	})
++ 	});
++-
++ 	defineProperties(Date.prototype, { dontEnum: true }, {
++ 	constructor: Date,
++ 	toISOString: unconstructable(function toISOString() {
++@@ -970,9 +1015,7 @@ defineProperties(Date.prototype, { dontEnum: true }, {
++ 	// TODO: this isn't as generic as in the ES5 spec, e.g. not converting this to object, not going via the objects reassignable `toISOString`.
++ 	toJSON: unconstructable(function toJSON() { return isoDate(this); })
++ 	});
++-
++ 	/* --- RegExp --- */
++-
++ 	var v = 1;
++ 	var EMPTY_CHAR = v, NEWLINE_CHAR = (v <<= 1), SPACE_CHAR = (v <<= 1), WORD_CHAR = (v <<= 1), DECIMAL_CHAR = (v <<= 1)
++ 	, LETTER_CHAR = (v <<= 1), HEX_CHAR = (v <<= 1), ESCAPE_CHAR = (v <<= 1), SPECIAL_CHAR = (v <<= 1)
++@@ -980,7 +1023,6 @@ var EMPTY_CHAR = v, NEWLINE_CHAR = (v <<= 1), SPACE_CHAR = (v <<= 1), WORD_CHAR
++ 	var CC = { }; // "CC" is used from within regexps, so the name has to be preserved
++ 	(function() {
++ 	function setupCharClass(mask, chars) { for (var i in chars) CC[chars[i]] |= mask }
++-
++ 	setupCharClass(SPECIAL_CHAR, "^$.*+?()[]{}|");
++ 	setupCharClass(DECIMAL_CHAR | HEX_CHAR | WORD_CHAR, "0123456789");
++ 	setupCharClass(HEX_CHAR | LETTER_CHAR | WORD_CHAR, "abcdefABCDEF");
++@@ -1000,7 +1042,6 @@ var CC = { }; // "CC" is used from within regexps, so the name has to be preserv
++ 	for (var j = IDENTITY_ESCAPE_RANGES[i], k = IDENTITY_ESCAPE_RANGES[i + 1]; j < k; ++j)
++ 	CC[support.fromCharCode(j)] |= IDENTITY_ESCAPE_CHAR;
++ 	})();
++-
++ 	// "regExpCanonicalize" is used from within regexps, so the name has to be preserved
++ 	function regExpCanonicalize(s) {
++ 	var t = '', c, d;
++@@ -1009,25 +1050,20 @@ function regExpCanonicalize(s) {
++ 	t += ((d = lowerToUpper[c = s[i]]) && d.length === 1 && (c < '\x80' || d >= '\x80') ? d : c);
++ 	return t
++ 	}
++-
++ 	// FIX : all charCodeAt etc need to be stowed away so that we won't destroy regexp if changing global objects. This is true for all the code in here actually.
++ 	function compileRegExp(s, caseInsensitive, multiLine) {
++ 	var p = 0, functions = '', functionCounter = 0, captureCounter = 0, closureVars = '', maxBackReference = 0;
++-
++ 	function isClass(char, mask) { return ((CC[char] & mask) !== 0); }
++-
++ 	function areClass(s, mask) { // FIX : only used once
++ 	for (var i = s.length - 1; i >= 0; --i) if ((CC[s[i]] & mask) === 0) return false;
++ 	return true;
++ 	}
++-
++ 	var CHAR_CLASS_RULES = {
++ 	'D': [ DECIMAL_CHAR, true ], 'd': [ DECIMAL_CHAR, false ],
++ 	'S': [ SPACE_CHAR, true ], 's': [ SPACE_CHAR, false ],
++ 	'W': [ WORD_CHAR, true ], 'w': [ WORD_CHAR, false ],
++ 	'.': [ NEWLINE_CHAR, true ]
++ 	};
++-
++ 	function parseNumber(defaultValue) {
++ 	var n = defaultValue;
++ 	if (isClass(s[p], DECIMAL_CHAR)) {
++@@ -1039,7 +1075,6 @@ function compileRegExp(s, caseInsensitive, multiLine) {
++ 	}
++ 	return n;
++ 	}
++-
++ 	function parseQuantifier() {
++ 	var mini = 0, maxi = $Infinity, greedy = true;
++ 	switch (s[p]) {
++@@ -1075,17 +1110,14 @@ function compileRegExp(s, caseInsensitive, multiLine) {
++ 	}
++ 	return { mini: mini, maxi: maxi, greedy: greedy };
++ 	}
++-
++ 	function escapeCharacter(c) {
++ 	if (isClass(c, OK_IN_STRING_LITERAL)) return c;
++ 	// TODO : shorter escapes for \n etc
++ 	return (c <= '~' ? "\\x" : "\\u") + leftPad(numberToRadix($charCodeAt(c, 0), 16), (c <= '~' ? 2 : 4));
++ 	}
++-
++ 	function canonicalizeAndEscape(c) {
++ 	return escapeCharacter(caseInsensitive ? regExpCanonicalize(c) : c);
++ 	}
++-
++ 	function parseLiteralCharacter() {
++ 	var c0, c1, sub;
++ 	if ((c0 = s[p]) === '\\') {
++@@ -1129,14 +1161,12 @@ function compileRegExp(s, caseInsensitive, multiLine) {
++ 	return c0;
++ 	}
++ 	}
++-
++ 	function parseLiteralSequence() {
++ 	var literalSequence = [ ], v, n = 0;
++ 	while (!isClass(s[p], SPECIAL_CHAR) && (v = parseLiteralCharacter()))
++ 	literalSequence[n++] = canonicalizeAndEscape(v);
++ 	return (literalSequence.length ? literalSequence : null);
++ 	}
++-
++ 	function parseClassAtom() {
++ 	var v, rule, c;
++ 	if ((c = s[p]) !== ']' && (v = parseLiteralCharacter())) return v;
++@@ -1151,9 +1181,7 @@ function compileRegExp(s, caseInsensitive, multiLine) {
++ 	}
++ 	}
++ 	}
++-	
++ 	function positionToCode(offset) { return (offset === 0 ? 'p' : ((offset < 0 ? 'p' : 'p+') + offset)); }
++-
++ 	function literalSequenceToCode(literalSequence, offset) {
++ 	if (literalSequence.length === 0) return "true";
++ 	else if (literalSequence.length === 1)
++@@ -1166,7 +1194,6 @@ function compileRegExp(s, caseInsensitive, multiLine) {
++ 	return "$match(s," + positionToCode(offset) + ',"' + s + '")';
++ 	}
++ 	}
++-
++ 	function and(a, b) {
++ 	switch (a) {
++ 	case "false": return "false";
++@@ -1174,7 +1201,6 @@ function compileRegExp(s, caseInsensitive, multiLine) {
++ 	default: return (b === "true" ? a : a + " && " + b);
++ 	}
++ 	}
++-
++ 	function or(a, b) {
++ 	switch (a) {
++ 	case "false": return b;
++@@ -1182,12 +1208,10 @@ function compileRegExp(s, caseInsensitive, multiLine) {
++ 	default: return (b === "false" ? a : a + " || " + b);
++ 	}
++ 	}
++-	
++ 	function addFunction(name, definition) {
++ 	// TODO : sometimes functions are identical (e.g. class-tests), reuse here or in '[' parsing directly?
++ 	functions += "\tfunction " + name + "(p) { " + definition + " }\n";
++ 	}
++-
++ 	function quantify(code, offset, repeatCode, tail, quantity, stepSize) {
++ 	// TODO : eliminate unnecessary b=p+0,e=p+Infinity and stuff
++ 	var functionName = 'q' + (++functionCounter)
++@@ -1206,7 +1230,6 @@ function compileRegExp(s, caseInsensitive, multiLine) {
++ 	}
++ 	return and(code, functionName + "(" + positionToCode(offset) + ")");
++ 	}
++-	
++ 	function captureWrap(code, capture, resetCaptureFrom, resetCaptureTo) {
++ 	if (capture === null && resetCaptureFrom === resetCaptureTo) {
++ 	return "return " + code;
++@@ -1239,11 +1262,9 @@ function compileRegExp(s, caseInsensitive, multiLine) {
++ 	return "var " + declares + "; return " + code;
++ 	}
++ 	}
++-
++ 	function charClassToCode(ch, rule) {
++ 	return (rule[1] ? '!' : "!!") + "(CC[" + ch + "]&" + (rule[0] | (rule[1] ? EMPTY_CHAR : 0)) + ')';
++ 	}
++-
++ 	function compileTerms(offset, junction) {
++ 	var literalSequence, quantity, code = "true";
++ 	termLoop: for (;;) {
++@@ -1436,7 +1457,6 @@ function compileRegExp(s, caseInsensitive, multiLine) {
++ 	default: return and(code, junction + '(' + positionToCode(offset) + ')');
++ 	}
++ 	}
++-
++ 	function compileDisjunction(offset, junction) { // junction = function name, undefined (for none for lookahead) or '' (for end of pattern)
++ 	var code = compileTerms(offset, junction);
++ 	if (s[p] === '|') {
++@@ -1448,7 +1468,6 @@ function compileRegExp(s, caseInsensitive, multiLine) {
++ 	}
++ 	return code;
++ 	}
++-
++ 	var disjunction = compileDisjunction(0, ''); 
++ 	if (p < s.length) throw syntaxError("Invalid regular expression");
++ 	if (maxBackReference > captureCounter) throw syntaxError("Invalid back reference in regular expression");
++@@ -1460,9 +1479,7 @@ function compileRegExp(s, caseInsensitive, multiLine) {
++ 	code += "];\n})";
++ 	return code
++ 	}
++-
++ 	var REG_EXP_FLAG_TO_PROPERTY = { 'g': "global", 'i': "ignoreCase", 'm': "multiline" }, regExpCache = { }, regExpPrototype;
++-
++ 	function execRegExp(re, string) {
++ 	string = str(string);
++ 	var i;
++@@ -1476,7 +1493,6 @@ function execRegExp(re, string) {
++ 	}
++ 	re.lastIndex = 0
++ 	}
++-
++ 	function regExpExecMethod(re, string) {
++ 	var m, a = null;
++ 	if (m = execRegExp(re, string)) {
++@@ -1487,9 +1503,7 @@ function regExpExecMethod(re, string) {
++ 	}
++ 	return a;
++ 	}
++-
++ 	function convertFlagsToText(re) { return (re.global ? 'g' : '') + (re.ignoreCase ? 'i' : '') + (re.multiline ? 'm' : ''); }
++-
++ 	var RegExp = support.distinctConstructor(function RegExp(pattern, flags) {
++ 	return ($getInternalProperty(pattern, "class") === "RegExp" && flags === void 0 ? pattern : new support.createRegExp(pattern, flags));
++ 	}, support.createRegExp = function RegExp(pattern, flags) {
++@@ -1498,7 +1512,6 @@ var RegExp = support.distinctConstructor(function RegExp(pattern, flags) {
++ 	flags = convertFlagsToText(pattern);
++ 	pattern = pattern.source;
++ 	}
++-	
++ 	// TODO : short-cut most of this through cache instead of only the func def.
++ 	// TODO : limit number of entries in cache
++ 	pattern = (pattern === void 0 ? '' : str(pattern));
++@@ -1518,7 +1531,6 @@ var RegExp = support.distinctConstructor(function RegExp(pattern, flags) {
++ 	defineProperties(re, { dontEnum: true, dontDelete: true }, { lastIndex: 0 });
++ 	return re;
++ 	});
++-
++ 	defineProperties(RegExp, { dontEnum: true, readOnly: true, dontDelete: true }, { prototype: regExpPrototype = RegExp.prototype });
++ 	defineProperties(RegExp.prototype, { dontEnum: true }, {
++ 	exec: unconstructable(function exec(string) { checkClass(this, "RegExp", "exec"); return regExpExecMethod(this, string); }),
++@@ -1528,9 +1540,7 @@ defineProperties(RegExp.prototype, { dontEnum: true }, {
++ 	return '/' + this.source + '/' + convertFlagsToText(this);
++ 	})
++ 	});
++-
++ 	/* --- Set up globals --- */
++-
++ 	defineProperties(globals, { dontEnum: true }, {
++ 	Array: Array,
++ 	Boolean: Boolean,
++@@ -1565,13 +1575,10 @@ defineProperties(globals, { dontEnum: true }, {
++ 	return (b === i ? $NaN : v * sign);
++ 	})
++ 	});
++-
++ 	defineProperties(globals, { dontEnum: true, dontDelete: true }, {
++ 	NaN: $NaN, Infinity: $Infinity, undefined: support.undefined
++ 	});
++-
++ 	/* --- Math --- */
++-
++ 	defineProperties(Math, { readOnly: true, dontEnum: true, dontDelete: true }, {
++ 	E: 2.718281828459045235360,
++ 	LN10: 2.302585092994045684018,
++@@ -1582,7 +1589,6 @@ defineProperties(Math, { readOnly: true, dontEnum: true, dontDelete: true }, {
++ 	SQRT1_2: 0.7071067811865475244008,
++ 	SQRT2: 1.414213562373095048802
++ 	});
++-
++ 	defineProperties(Math, { dontEnum: true }, {
++ 	abs: unconstructable(abs = function abs(v) { return ((v = +v) < 0 ? -v : v) }),
++ 	acos: unconstructable(function acos(v) { return support.acos(+v) }),
++@@ -1603,9 +1609,7 @@ defineProperties(Math, { dontEnum: true }, {
++ 	sqrt: unconstructable(function sqrt(v) { return support.sqrt(+v) }),
++ 	tan: unconstructable(function tan(v) { return support.tan(+v) })
++ 	});
++-
++ 	/* --- Errors --- */
++-
++ 	function createErrorConstructor(name, prototype) {
++ 	return function(message) {
++ 	var e;
++@@ -1614,10 +1618,8 @@ function createErrorConstructor(name, prototype) {
++ 	return e
++ 	}
++ 	};
++-
++ 	(function() {
++ 	var ERROR_NAMES = [ "Error", "EvalError", "RangeError", "ReferenceError", "SyntaxError", "TypeError", "URIError" ];
++-
++ 	for (var i = ERROR_NAMES.length; --i >= 0;) {
++ 	var n, c, p;
++ 	support.defineProperty(globals, n = ERROR_NAMES[i], c = createErrorConstructor(n, p = support.prototypes[n])
++@@ -1627,43 +1629,34 @@ function createErrorConstructor(name, prototype) {
++ 	defineProperties(p, { dontEnum: true }, { constructor: c });
++ 	p.name = n;
++ 	}
++-
++ 	defineProperties(Error.prototype, { dontEnum: true }, {
++ 	message: '',
++ 	toString: unconstructable(function toString() {
++ 	return (this.name === void 0 ? "Error" : this.name) + (this.message ? (": " + this.message) : '');
++ 	})
++ 	});
++-
++ 	syntaxError = SyntaxError;
++ 	rangeError = RangeError;
++ 	typeError = TypeError;
++ 	})();
++-
++ 	/* --- ES >3 polyfills --- */
++-
++ 	// These are not guaranteed to be 100% compatible
++-
++ 	var JSON_ESCAPE_SEQUENCES = { '\\': "\\\\", '"': "\\\"", '\b': "\\b", '\f': "\\f", '\n': "\\n", '\r': "\\r", '\t': "\\t" };
++ 	var MAX_JSON_DEPTH = 61;	// compiler internal recursion limit is 64 (as of 20180610), we must stick under this for eval() to work and 61 gives us enough margin
++-
++ 	// TODO : use StringBuilder?
++ 	defineProperties(JSON, { dontEnum: true }, {
++ 	stringify: unconstructable(function stringify(val, replacer, space) {
++ 	var stack = [ ], replacerFunction = (typeof replacer === "function" ? replacer : null), gap = '', includeProps;
++-
++ 	if ($getInternalProperty(replacer, "class") === "Array") {
++ 	includeProps = { };
++ 	for (var i = replacer.length; --i >= 0;) includeProps[replacer[i]] = true;
++ 	}
++-
++ 	if (typeof space === "number" || (typeof space === "object" && $getInternalProperty(space, "class") === "Number")) {
++ 	space = +space;
++ 	for (var i = (space > 10 ? 10 : space); --i >= 0;) gap += ' ';
++ 	} else if (typeof space === "string" || (typeof space === "object" && $getInternalProperty(space, "class") === "String")) {
++ 	gap = $sub(str(space), 0, 10);
++ 	}
++-
++ 	function quote(s) {
++ 	var t = '"', len = s.length;
++ 	for (var i = 0; i < len; ++i) {
++@@ -1674,12 +1667,10 @@ defineProperties(JSON, { dontEnum: true }, {
++ 	}
++ 	return t + '"';
++ 	}
++-
++ 	function string(key, holder, indent) {
++ 	var val;
++ 	if ((val = holder[key]) && typeof val === "object" && typeof val.toJSON === "function") val = val.toJSON(key);
++ 	if (replacerFunction) val = $callWithArgs(replacerFunction, holder, [ key, val ]);
++-
++ 	var lineEnd = (gap ? '\n' + indent : '');
++ 	if (typeof val === "object") {
++ 	switch ($getInternalProperty(val, "class")) {
++@@ -1719,7 +1710,6 @@ defineProperties(JSON, { dontEnum: true }, {
++ 	--stack.length;
++ 	return s.build();
++ 	}
++-
++ 	case "string": return quote(val);
++ 	case "number": return ($isFinite(val) ? str(val) : "null");
++ 	case "boolean": return str(val);
++@@ -1727,7 +1717,6 @@ defineProperties(JSON, { dontEnum: true }, {
++ 	}
++ 	return string('', { '': val }, '');
++ 	}),
++-
++ 	parse: unconstructable(function parse(text, reviver) {
++ 	var nest = 0;
++ 	function space(t, p) {
++@@ -1831,18 +1820,40 @@ defineProperties(JSON, { dontEnum: true }, {
++ 	throw syntaxError("Error parsing JSON");
++ 	})
++ 	});
++-
++ 	defineProperties(Array, { dontEnum: true }, {
++ 	isArray: unconstructable(function isArray(o) { return $getInternalProperty(o, "class") === "Array"; })
++ 	});
++-
++ 	defineProperties(Object, {dontEnum : true}, {
++ 	defineProperty : unconstructable(function defineProperty(o, p, d) {
++-		support.defineProperty(o, str(p), d.value, !d.writable, !d.enumerable, !d.configurable);
+++	var k = str(p);
+++	var ro = !d.writable, de = !d.enumerable, dd = !d.configurable;
+++	if ("get" in d || "set" in d) {
+++	if ("value" in d || "writable" in d)
+++	throw TypeError();
+++	var g = d.get;
+++	var s = d.set;
+++	if (g !== undefined && typeof g !== "function")
+++	throw TypeError();
+++	if (s !== undefined && typeof s !== "function")
+++	throw TypeError();
+++	support.defineProperty(o, k, undefined, ro, de, dd, g, s);
+++	} else {
+++	support.defineProperty(o, k, d.value, ro, de, dd);
+++	}
+++	}),
+++	getPrototypeOf : unconstructable(function getPrototypeOf(o) {
+++	return $getInternalProperty(o, "prototype");
++ 	}),
++-	getPrototypeOf: unconstructable(function getPrototypeOf(o) { return $getInternalProperty(o, "prototype"); })
+++	keys : unconstructable(function keys(o) {
+++	if (o === undefined || o === null) throw TypeError();
+++	var obj = Object(o);
+++	var res = [];
+++	var k;
+++	for (k in obj) {
+++		if (Object.prototype.hasOwnProperty.call(obj, k)) res[res.length] = k;
+++	}
+++	return res;
+++	})
++ 	});
++-
++ 	if ($NaN.toString() !== "NaN") throw Error("Internal self test failed. Check C++ compiler options concerning IEEE 754 compliance.");
++-
++ 	})
++diff --git a/src/stdlibES5.js b/src/stdlibES5.js
++new file mode 100644
++index 000000000..b4df0abcc
++--- /dev/null
+++++ b/src/stdlibES5.js
++@@ -0,0 +1,24 @@
+++/*
+++ES5 additions to the standard library.
+++This file is appended to stdlib.js by tools/stdlibToCpp.pika.
+++
+++@preserve: indexOf,lastIndexOf,Q
+++*/
+++
+++Q(Array.prototype, {
+++indexOf: unconstructable(function indexOf(searchElement) {
+++var len = uint32(this.length), i = arguments[1];
+++if (len === 0) return -1;
+++if ((i = int(i)) < 0) { i += len; if (i < 0) i = 0; }
+++for (; i < len; ++i) if (i in this && this[i] === searchElement) return i;
+++return -1;
+++}),
+++lastIndexOf: unconstructable(function lastIndexOf(searchElement) {
+++var len = uint32(this.length), i = arguments[1];
+++if (len === 0) return -1;
+++if (i === void 0) i = len - 1; else { i = int(i); if (i < 0) i += len; if (i >= len) i = len - 1; }
+++for (; i >= 0; --i) if (i in this && this[i] === searchElement) return i;
+++return -1;
+++})
+++});
+++
++diff --git a/src/stdlibJS.cpp b/src/stdlibJS.cpp
++index 8754846d4..faef14492 100644
++--- a/src/stdlibJS.cpp
+++++ b/src/stdlibJS.cpp
++@@ -252,240 +252,269 @@ const char* STDLIB_JS =
++ "aX;return $sub(B,aX,(length===void 0?h:aX+M(length)))}),substring:c(function substring(aX,aY){aX=M(aX);if(aY===void 0)"
++ "aY=h;else if((aY=M(aY))<aX){var b5=aX;aX=aY;aY=b5}return $sub(P(this),aX,aY)}),toUpperCase:c(function toUpperCase(){re"
++ "turn aA(this)}),toLocaleUpperCase:c(function toLocaleUpperCase(){return aA(this)}),toLowerCase:c(function toLowerCase("
++-"){return az(this)}),toLocaleLowerCase:c(function toLocaleLowerCase(){return az(this)}),valueOf:c(function valueOf(){Y("
++-"this,\"String\",\"valueOf\");return i(this,\"value\")}),toString:c(function toString(){Y(this,\"String\",\"toString\")"
++-";return i(this,\"value\")})});var Array=function Array(G){var aM=[],ak,aB;if((aB=(ak=arguments).length)===1&&typeof G="
++-"==\"number\"){if((G>>>0)!==G)throw m(\"Invalid array length\");aM.length=G}else{for(var u=0;u<aB;++u)aM[u]=ak[u]}retur"
++-"n aM};Q(Array,{dontEnum:true,readOnly:true,dontDelete:true},{prototype:a.prototypes.Array});Q(Array.prototype,{dontEnu"
++-"m:true},{constructor:Array,concat:c(function concat(b6){var aM=[],ak,aB=(ak=arguments).length,C=0,G=this;for(var u=-1;"
++-"u<aB;G=ak[++u]){if(i(G,\"class\")!==\"Array\"){aM[C++]=G}else{for(var b7=0,aG=G.length;b7<aG;++b7)if(b7 in G)aM[C+b7]="
++-"G[b7];aM.length=(C+=b7)}}return aM}),join:c(function join(aZ){var B=new x,b8,ay=O(this.length);aZ=(aZ===void 0?',':P(a"
++-"Z));for(var u=0;u<ay;++u){if(u>0)B.A(aZ);if((b8=this[u])!=null)B.A(P(b8))}return B.D()}),pop:c(function pop(){var G=vo"
++-"id 0,ay;if((ay=O(this.length))>0)G=this[--ay];this.length=ay;return G}),push:c(function push(b9){var ak,ba=O(this.leng"
++-"th),aY=(ak=arguments).length+ba;for(var u=ba;u<aY;++u)this[u]=ak[u-ba];return(this.length=aY)}),reverse:c(function rev"
++-"erse(){var ay,bb=f((ay=O(this.length))/2);--ay;for(var bc=0;bc<bb;++bc){var bd=ay-bc;var be=(bd in this),bf=this[bd];i"
++-"f(bc in this)this[bd]=this[bc];else delete this[bd];if(be)this[bc]=bf;else delete this[bc]}return this}),shift:c(funct"
++-"ion shift(){var ay,bg;if(ay=O(this.length)){bg=this[0];for(var u=1;u<ay;++u){if(u in this)this[u-1]=this[u];else delet"
++-"e this[u-1]}--ay};this.length=ay;return bg}),slice:c(function slice(aX,aY){var aM=[],ay=O(this.length);if((aX=M(aX))<0"
++-"){aX+=ay;if(aX<0)aX=0}if(aY===void 0||(aY=M(aY))>ay)aY=ay;else if(aY<0)aY+=ay;for(var u=aX,b7=0;u<aY;++u,++b7)if(u in "
++-"this)aM[b7]=this[u];aM.length=b7;return aM}),sort:c(function sort(bh){var bi=this;function b5(bj,bk,bl){var bm=(bk in "
++-"bj),bn=bj[bk];if(bl in bj)bj[bk]=bj[bl];else delete bj[bk];if(bm)bj[bl]=bn;else delete bj[bl]};function bo(bj,bk,bl){i"
++-"f(!(bk in bj)&&!(bl in bj))return 0;else if(!(bk in bj))return 1;else if(!(bl in bj))return-1;else{var aM=bj[bk];var y"
++-"=bj[bl];if(aM===void 0&&y===void 0)return 0;else if(aM===void 0)return 1;else if(y===void 0)return-1;else return bh(aM"
++-",y)}};function bp(bq,br){var bs=b5,bt=bo,bj=bi,bb,bu;for(--br;bq+1<br;bq=bu){var bv=br;bu=bq;bb=f((bu+bv)/2);while(bu<"
++-"bv){while(bu<=bv&&bt(bj,bu,bb)<=0&&bt(bj,bv,bb)>=0){++bu;--bv}while(bu<=bv&&bt(bj,bv,bb)>0)--bv;while(bu<=bv&&bt(bj,bu"
++-",bb)<0)++bu;if(bb===bu||bb===bv)bb^=bv^bu;if(bu<bv)bs(bj,bu,bv)}bp(bq,bu)}if(bq<br&&bt(bj,bq,br)>0)bs(bj,bq,br)};if(bh"
++-"===void 0){bh=function(aM,y){return((aM=P(aM))<(y=P(y))?-1:(aM>y?1:0))}};bp(0,this.length>>>0);return this}),splice:c("
++-"function splice(aX,bw){var aM=[],ay=O(this.length),ak,aB=(ak=arguments).length,aY,bx,by;if((aX=M(aX))<0){aX+=ay;if(aX<"
++-"0)aX=0}else if(aX>ay)aX=ay;if(aB==1||(aY=aX+M(bw))>ay)aY=ay;else if(aY<aX)aY=aX;for(var u=aX,b7=0;u<aY;++u,++b7)if(u i"
++-"n this)aM[b7]=this[u];aM.length=b7;if((bx=aB-2)<0)bx=0;if((by=aX+bx-aY)!==0){var bz=1,b7=aY;if(by>0){bz=-1;b7=ay-1}for"
++-"(u=ay-aY;--u>=0;b7+=bz){if(b7 in this)this[b7+by]=this[b7];else delete this[b7+by]}for(u=ay;--u>=ay+by;)delete this[u]"
++-"}for(u=2,b7=aX;u<aB;++u,++b7)this[b7]=ak[u];this.length=ay+by;return aM}),toLocaleString:Object.prototype.toLocaleStri"
++-"ng,toString:c(function toString(){Y(this,\"Array\",\"toString\");return this.join()}),unshift:c(function unshift(b6){v"
++-"ar ay,ak,C=(ak=arguments).length;if(ay=O(this.length)){for(var u=ay;--u>=0;){if(u in this)this[u+C]=this[u];else delet"
++-"e this[u+C]}}for(var u=0;u<C;++u)this[u]=ak[u];return(this.length=ay+C)})});function bA(){var bB=a.localTimeDifference"
++-"(14516064e5);var bC=a.localTimeDifference(14673312e5);return(bB>bC?bB:bC)}function bD(){var bB=a.localTimeDifference(1"
++-"4516064e5);var bC=a.localTimeDifference(14673312e5);return(bB<bC?bB:bC)}function bE(bF){var a2=a.localTimeDifference(b"
++-"F);return(d(a2)?bD():a2)}function bG(bF){return d(bF)?bF:bF+bE(bF)}function bH(R){if(i(R,\"class\")!==\"Date\")throw n"
++-"(\"this is not a Date object\")}function bI(R){bH(R);return i(R,\"value\")}function bJ(R){return bG(bI(R))}function bK"
++-"(R,G){bH(R);a.updateDateValue(R,G);return G}function bL(G){return d(G=bG(G))?\"Invalid Date\":(bM(G)+' '+bN(G))}functi"
++-"on bO(bP,C){return(bP%C+C)%C}function bQ(bR,bS,bT,bU){return bR*36e5+bS*6e4+bT*1e3+bU}function bV(bF){return[bO(f(bF/3"
++-"6e5),24),bO(f(bF/6e4),60),bO(f(bF/1e3),60),bO(bF,1e3)]}function bW(bF){return d(bF)?bF:(bF-bE(bF-bA()))}function bX(bF"
++-"){return bO(f(bF/864e5)+4,7)}function bY(bF){return bO(f(bF/36e5),24)}function bZ(bF){return bO(f(bF/6e4),60)}function"
++-" c0(bF){return bO(f(bF/1e3),60)}function c1(bF){return bO(bF,1e3)}function c2(bF){return(!e(bF)||abs(bF)>8.64e15?g:M(b"
++-"F))}function c3(bF){return bW(c2(bF))}function c4(bF){bF=f(bF/864e5)+719468;var c5=M((bF>=0?bF:bF-146096)/146097);var "
++-"c6=bF-c5*146097;var c7=M((c6-M(c6/1460)+M(c6/36524)-M(c6/146096))/365);var c8=c7+c5*400;var c9=c6-(365*c7+M(c7/4)-M(c7"
++-"/100));var ca=M((5*c9+2)/153);var aT=ca+(ca<10?2:-10);var cb=c9-M((153*ca+2)/5)+1;return[(c8+(aT<=1)),aT,cb]}function "
++-"bM(bF){var c8,cc=c4(bF);return(0<=(c8=cc[0])&&c8<=9999?a1(c8,4):(c8<0?\"-\":\"+\")+a1(abs(c8),6))+\"-\"+a1(cc[1]+1,2)+"
++-"\"-\"+a1(cc[2],2)}function bN(bF,bU){var cd=bV(bF);return a1(cd[0],2)+\":\"+a1(cd[1],2)+\":\"+a1(cd[2],2)+(bU?\".\"+a1"
++-"($sub(cd[3],0,3),3):\"\")}function ce(cf,cg,ch){cf+=f(cg/12)-(bO(cg,12)<=1);var c5=M((cf>=0?cf:cf-399)/400);var c7=cf-"
++-"c5*400;var c9=M((153*(cg+(cg>1?-2:10))+2)/5)+ch-1;var c6=c7*365+M(c7/4)-M(c7/100)+c9;return(c5*146097+c6-719468)*864e5"
++-"}function ci(bF,C,aM){var u,cb=c4(bF),aN=bO(bF,864e5);for(u=0;u<aM.length;++u,++C)cb[C]=M(aM[u]);return j(ce,null,cb)+"
++-"aN}function cj(bF,C,aM){var u,H=bV(bF),aN=f(bF/864e5)*864e5;for(u=0;u<aM.length;++u,++C)H[C]=M(aM[u]);return j(bQ,null"
++-",H)+aN}function ck(cf,cg,cl,cm,cn,co,bU){var aB=arguments.length;return ce((cf=M(cf))+(0<=cf&&cf<=99?1900:0),M(cg),(aB"
++-">2?M(cl):1))+bQ(aB>3?M(cm):0,aB>4?M(cn):0,aB>5?M(co):0,aB>6?M(bU):0)}function cp(cb){var bF;return d(bF=bI(cb))?null:b"
++-"M(bF)+\"T\"+bN(bF,true)+\"Z\"}var cq,Date=a.distinctConstructor(function Date(){return bL(a.getCurrentTime())},functio"
++-"n Date(cf,cg,cl,cm,cn,co,bU){var G,aB;if((aB=arguments.length)>=2&&aB<=7)G=c3(j(ck,null,arguments));else if(aB===1)G=c"
++-"2(typeof(G=a.toPrimitive(cf))===\"string\"?cq(G):+G);else G=a.getCurrentTime();return a.createWrapper(\"Date\",G,a.pro"
++-"totypes.Date)});Q(Date,{dontEnum:true,readOnly:true,dontDelete:true},{prototype:a.prototypes.Date});Q(Date,{dontEnum:t"
++-"rue},{parse:c(cq=function parse(B){var bF,c8,u,aU,cr,cs,ct,u=0;function cu(ay){var G;for(G=0;--ay>=0;)if(\"0\"<=B[u]&&"
++-"B[u]<=\"9\")G=G*10+(+B[u++]);else return g;return G}bF=ce(((aU=B[u])===\"+\"||aU===\"-\")&&(++u,c8=cu(6),aU===\"-\"?-c"
++-"8:c8)||cu(4),B[u]===\"-\"&&(++u,cu(2)-1)||0,B[u]===\"-\"&&(++u,cu(2))||1);bF+=bQ(((aU=B[u])===\"T\"||aU===\"t\"||aU==="
++-"' ')&&(++u,cu(2))||0,B[u]===\":\"&&(++u,cu(2))||0,B[u]===\":\"&&(++u,cu(2))||0,B[u]===\".\"&&(++u,cu(3))||0);while((aU"
++-"=B[u])!==void 0&&aU!==\"Z\"&&aU!==\"z\"&&aU!==\"+\"&&aU!==\"-\")++u;if(aU===\"Z\"||aU===\"z\")cr=0;else if(aU===\"+\"|"
++-"|aU===\"-\"){++u,cs=cu(2)*36e5,B[u]===\":\"&&++u,cs+=d(ct=cu(2))?0:ct*6e4,d(cs)||(cr=aU===\"-\"?-cs:cs)}return(cr===vo"
++-"id 0?bW(bF):bF-cr)}),UTC:c(function UTC(cf,cg,cl,cm,cn,co,bU){return c2(ck(cf,cg,cl,cm,cn,co,bU))})});Q(Date.prototype"
++-",{dontEnum:true},{constructor:Date,toISOString:c(function toISOString(){var B;if((B=cp(this))===null)throw m(\"Invalid"
++-" time value\");return B}),toUTCString:c(function toUTCString(){var bF;if(d(bF=bI(this)))return\"Invalid Date\";return("
++-"bM(bF)+' '+bN(bF))}),toString:c(function toString(){return bL(bI(this))}),toDateString:c(function toDateString(){var a"
++-"2;if(d(a2=bJ(this)))return\"Invalid Date\";return bM(a2)}),toTimeString:c(function toTimeString(){var a2;if(d(a2=bJ(th"
++-"is)))return\"Invalid Date\";return bN(a2)}),toLocaleString:Object.prototype.toLocaleString,toLocaleDateString:c(functi"
++-"on toLocaleDateString(){return this.toDateString()}),toLocaleTimeString:c(function toLocaleTimeString(){return this.to"
++-"TimeString()}),valueOf:c(function valueOf(){return bI(this)}),getTime:c(function getTime(){return bI(this)}),getFullYe"
++-"ar:c(function getFullYear(){return c4(bJ(this))[0]}),getUTCFullYear:c(function getUTCFullYear(){return c4(bI(this))[0]"
++-"}),getMonth:c(function getMonth(){return c4(bJ(this))[1]}),getUTCMonth:c(function getUTCMonth(){return c4(bI(this))[1]"
++-"}),getDate:c(function getDate(){return c4(bJ(this))[2]}),getUTCDate:c(function getUTCDate(){return c4(bI(this))[2]}),g"
++-"etDay:c(function getDay(){return bX(bJ(this))}),getUTCDay:c(function getUTCDay(){return bX(bI(this))}),getHours:c(func"
++-"tion getHours(){return bY(bJ(this))}),getUTCHours:c(function getUTCHours(){return bY(bI(this))}),getMinutes:c(function"
++-" getMinutes(){return bZ(bJ(this))}),getUTCMinutes:c(function getUTCMinutes(){return bZ(bI(this))}),getSeconds:c(functi"
++-"on getSeconds(){return c0(bJ(this))}),getUTCSeconds:c(function getUTCSeconds(){return c0(bI(this))}),getMilliseconds:c"
++-"(function getMilliseconds(){return c1(bJ(this))}),getUTCMilliseconds:c(function getUTCMilliseconds(){return c1(bI(this"
++-"))}),getTimezoneOffset:c(function getTimezoneOffset(){var G=bI(this);return(G-bG(G))/6e4}),setTime:c(function setTime("
++-"time){return bK(c2(+time))}),setMilliseconds:c(function setMilliseconds(bU){return bK(this,c3(cj(bJ(this),3,arguments)"
++-"))}),setUTCMilliseconds:c(function setUTCMilliseconds(bU){return bK(this,c2(cj(bI(this),3,arguments)))}),setSeconds:c("
++-"function setSeconds(B,bU){return bK(this,c3(cj(bJ(this),2,arguments)))}),setUTCSeconds:c(function setUTCSeconds(B,bU){"
++-"return bK(this,c2(cj(bI(this),2,arguments)))}),setMinutes:c(function setMinutes(aT,B,bU){return bK(this,c3(cj(bJ(this)"
++-",1,arguments)))}),setUTCMinutes:c(function setUTCMinutes(aT,B,bU){return bK(this,c2(cj(bI(this),1,arguments)))}),setHo"
++-"urs:c(function setHours(cv,aT,B,bU){return bK(this,c3(cj(bJ(this),0,arguments)))}),setUTCHours:c(function setUTCHours("
++-"cv,aT,B,bU){return bK(this,c2(cj(bI(this),0,arguments)))}),setDate:c(function setDate(cl){return bK(this,c3(ci(bJ(this"
++-"),2,arguments)))}),setUTCDate:c(function setUTCDate(cl){return bK(this,c2(ci(bI(this),2,arguments)))}),setMonth:c(func"
++-"tion setMonth(cg,cl){return bK(this,c3(ci(bJ(this),1,arguments)))}),setUTCMonth:c(function setUTCMonth(cg,cl){return b"
++-"K(this,c2(ci(bI(this),1,arguments)))}),setFullYear:c(function setFullYear(cf,cg,cl){var G;return bK(this,c3(ci(d(G=bI("
++-"this))?0:bG(G),0,arguments)))}),setUTCFullYear:c(function setUTCFullYear(cf,cg,cl){var G;return bK(this,c2(ci(d(G=bI(t"
++-"his))?0:G,0,arguments)))}),toJSON:c(function toJSON(){return cp(this)})});var G=1;var cw=G,cx=(G<<=1),cy=(G<<=1),cz=(G"
++-"<<=1),cA=(G<<=1),cB=(G<<=1),cC=(G<<=1),cD=(G<<=1),cE=(G<<=1),cF=(G<<=1),cG=(G<<=1);var CC={};(function(){function cH(c"
++-"I,cJ){for(var u in cJ)CC[cJ[u]]|=cI}cH(cE,\"^$.*+?()[]{}|\");cH(cA|cC|cz,\"0123456789\");cH(cC|cB|cz,\"abcdefABCDEF\")"
++-";cH(cB|cz,\"ghijklmnopqrstuvwxyzGHIJKLMNOPQRSTUVWXYZ\");cH(cx|cy,\"\\n\\r\\u2028\\u2029\");cH(cy,\" \\t\\v\\f\\xA0\");"
++-"CC['_']|=cz;CC[\"undefined\"]|=cw;CC['']|=cw;cH(cD,\"fnrtv\");for(var u=32;u<=126;++u){var au=a.fromCharCode(u);if(au!"
++-"=='\"'&&au!=='\\\\')CC[a.fromCharCode(u)]|=cF}var cK=[0,48,58,65,91,95,96,97,123,128];for(var u=cK.length-2;u>=0;u-=2)"
++-"for(var b7=cK[u],cL=cK[u+1];b7<cL;++b7)CC[a.fromCharCode(b7)]|=cG})();function regExpCanonicalize(B){var H='',au,cb;if"
++-"(!as)at();for(var u=0,ay=B.length;u<ay;++u)H+=((cb=as[au=B[u]])&&cb.length===1&&(au<'\\x80'||cb>='\\x80')?cb:au);retur"
++-"n H}function cM(B,cN,cO){var X=0,cP='',cQ=0,cR=0,cS='',cT=0;function cU(cV,cI){return((CC[cV]&cI)!==0)}function cW(B,c"
++-"I){for(var u=B.length-1;u>=0;--u)if((CC[B[u]]&cI)===0)return false;return true}var cX={'D':[cA,true],'d':[cA,false],'S"
++-"':[cy,true],'s':[cy,false],'W':[cz,true],'w':[cz,false],'.':[cx,true]};function cY(cZ){var C=cZ;if(cU(B[X],cA)){C=0;do"
++-"{C=C*10+(k(B,X)-48);++X}while(cU(B[X],cA))}return C}function d0(){var d1=0,d2=h,d3=true;switch(B[X]){case'*':++X;break"
++-";case'+':++X;d1=1;break;case'?':++X;d2=1;break;case'{':{var y=X;++X;if((d1=d2=cY(-1))<0){X=y;return null}if(B[X]===','"
++-"){++X;d2=cY(h)}if(B[X]!=='}'){X=y;return null}if(d1>d2){throw l(\"Min greater than max in regular expression quantifie"
++-"r\")}++X;break}default:return null}if(B[X]==='?'){++X;d3=false}return{d1:d1,d2:d2,d3:d3}}function d4(au){if(cU(au,cF))"
++-"return au;return(au<='~'?\"\\\\x\":\"\\\\u\")+a1(ad(k(au,0),16),(au<='~'?2:4))}function d5(au){return d4(cN?regExpCano"
++-"nicalize(au):au)}function d6(){var d7,d8,d9;if((d7=B[X])==='\\\\'){switch(d8=B[X+1]){case'0':{if(!cU(B[X+2],cA)){X+=2;"
++-"return'\\0'}break}case'c':{if(cU(B[X+2],cB)){X+=3;return a.fromCharCode(k(B,X-1)&31)}break}case'x':case'u':{var C=(d8="
++-"=='x'?2:4);if(cW(d9=$sub(B,X+2,X+2+C),cC)){X+=2+C;return a.fromCharCode(parseInt(d9,16))}break}default:{if(cU(d8,cD)){"
++-"X+=2;return eval('\"\\\\'+d8+'\"')}else if(cU(d8,cG)){X+=2;return d8}break}}}else if(d7){++X;return d7}}function da(){"
++-"var db=[],G,C=0;while(!cU(B[X],cE)&&(G=d6()))db[C++]=d5(G);return(db.length?db:null)}function dc(){var G,dd,au;if((au="
++-"B[X])!==']'&&(G=d6()))return G;if(au==='\\\\'){if((au=B[X+1])==='b'){X+=2;return'\\b'}if(dd=cX[au]){X+=2;return dd}}}f"
++-"unction de(ba){return(ba===0?'p':((ba<0?'p':'p+')+ba))}function df(db,ba){if(db.length===0)return\"true\";else if(db.l"
++-"ength===1)return\"s[\"+de(ba)+']===\"'+db[0]+'\"';else if(db.length===2)return\"s[\"+de(ba)+']===\"'+db[0]+'\" && s['+"
++-"de(ba+1)+']===\"'+db[1]+'\"';else{for(var u=0,B='',a2=db.length;u<a2;++u)B+=db[u];return\"$match(s,\"+de(ba)+',\"'+B+'"
++-"\")'}}function dg(aM,y){switch(aM){case\"false\":return\"false\";case\"true\":return y;default:return(y===\"true\"?aM:"
++-"aM+\" && \"+y)}}function dh(aM,y){switch(aM){case\"false\":return y;case\"true\":return\"true\";default:return(y===\"f"
++-"alse\"?aM:aM+\" || \"+y)}}function di(name,dj){cP+=\"\\tfunction \"+name+\"(p) { \"+dj+\" }\\n\"}function dk(dl,ba,dm,"
++-"dn,dp,dq){var dr='q'+(++cQ),ds=(dq?\"var h=\"+dq+\",\":\"var \")+(dp.d1?\"b=p+\"+dp.d1+(dq?\"*h\":\"\"):\"b=p\")+(dp.d"
++-"2<h?\",e=p+\"+dp.d2+(dq?\"*h\":\"\"):\"\")+\"; \";if(dq)ds+=\"if (h<=0 || h!==h) return \"+dn+\"; \";if(dp.d3){di(dr,d"
++-"s+\"while (\"+dg((dp.d2<h?\"p<e\":\"true\"),dm)+\") \"+(dq?\"p+=h\":\"++p\")+\"; while (\"+dg(\"p>=b\",\"!(\"+dn+\")\""
++-")+\") \"+(dq?\"p-=h\":\"--p\")+\"; return p>=b\")}else{di(dr,ds+\"while (\"+dh((dp.d1?\"p<b\":\"false\"),\"!(\"+dn+\")"
++-"\")+\") { if (\"+dh((dp.d2<h?\"p>=e\":\"false\"),\"!(\"+dm+\")\")+\") return false; \"+(dq?\"p+=h\":\"++p\")+\" }; ret"
++-"urn true\")}return dg(dl,dr+\"(\"+de(ba)+\")\")}function dt(dl,du,dv,dw){if(du===null&&dv===dw){return\"return \"+dl}e"
++-"lse{var dx='',dy='',dz='';if(du!==null){dx+='r'+du+\"=c\"+du;dy='c'+du+\"=p\";dz='c'+du+\"=r\"+du}if(dw!==void 0){for("
++-"var u=dv;u<dw;++u){var b7=u*2;if(du!==null||u>dv){dx+=',';dz+=',';if(u===dv){dy+=','}}dx+='r'+b7+\"=c\"+b7;dy+='c'+b7+"
++-"'=';dz+='c'+b7+\"=r\"+b7;if(u===dw-1){dy+=\"void 0\"}}}dl=dy+\", \"+dh(dl,'('+dz+\",false)\");return\"var \"+dx+\"; re"
++-"turn \"+dl}}function dA(aU,dd){return(dd[1]?'!':\"!!\")+\"(CC[\"+aU+\"]&\"+(dd[0]|(dd[1]?cw:0))+')'}function dB(ba,dC)"
++-"{var db,dp,dl=\"true\";dD:for(;;){if(db=da()){if(dp=d0()){var dE=db[db.length-1];--db.length;return dk(dg(dl,df(db,ba)"
++-"),ba+db.length,df(dE,0),dB(0,dC),dp)}dl=dg(dl,df(db,ba));ba+=db.length}else{var au,dF,dn,dG,dH;switch(au=B[X]){case'^'"
++-":{++X;dF=de(ba)+\"===0\";if(cO)dF='('+dh(dF,\"!!(CC[s[\"+de(ba-1)+\"]]&\"+cx+')')+')';dl=dg(dl,dF);break}case'$':{++X;"
++-"dF=de(ba)+\"===l\";if(cO)dF='('+dh(dF,\"!!(CC[s[\"+de(ba)+\"]]&\"+cx+')')+')';dl=dg(dl,dF);break}case'[':{var dI=false"
++-",dJ,dK,dL=\"false\";if(B[++X]==='^'){dI=true;++X}while(dJ=dc()){var y=X;if(B[X]==='-'&&(++X,dK=dc())){if(typeof dJ==="
++-"\"string\"&&typeof dK===\"string\"&&dJ<=dK){if(cN&&(dJ>'~'||dK>'~'||(regExpCanonicalize(dJ)!==dJ)!==(regExpCanonicaliz"
++-"e(dK)!==dK))){dJ=d4(dJ);dK=d4(dK);dL=dh(dL,dg('upperToLower[c]>=\"'+dJ+'\"','upperToLower[c]<=\"'+dK+'\"'))}else{dJ=d5"
++-"(dJ);dK=d5(dK)}dL=dh(dL,dg('c>=\"'+dJ+'\"','c<=\"'+dK+'\"'))}else{throw l(\"Invalid character class syntax in regular "
++-"expression\")}}else if(typeof dJ===\"string\"){X=y;dL=dh(dL,'c===\"'+d5(dJ)+'\"')}else{dL=dh(dL,dA('c',dJ))}}if(B[X]!="
++-"=']'){throw l(\"Invalid character class syntax in regular expression\")}++X;var dr='k'+(++cQ);di(dr,\"var c=s[p]; retu"
++-"rn \"+(dI?\"p!==l && !(\"+dL+')':dL));if(dp=d0()){return dk(dl,ba,dr+'('+de(0)+')',dB(0,dC),dp)}dl=dg(dl,dr+'('+de(ba)"
++-"+')');++ba;break}case'\\\\':{var C;++X;if((C=cY(-1))>=0){if(C>cT)cT=C;C=(C-1)*2;dp=d0();var dq='c'+(C+1)+\"-c\"+C,dM="
++-"\"$match(s,\"+de(ba)+\",$sub(s, c\"+C+\",c\"+(C+1)+\"))\";dn=dB(0,dC);var dN='t'+(++cQ);di(dN,\"return \"+dn);return d"
++-"p?dk(dl,ba,dM,dN+'('+de(0)+')',dp,dq):dg(dl,'(c'+C+\"<c\"+(C+1)+\" ? \"+dg(dM,dN+'('+de(ba)+'+'+dq+')')+\" : \"+dN+'('"
++-"+de(ba)+\"))\")}else if((au=B[X])==='b'||au==='B'){++X;dl=dg(dl,(au==='b'?\"!!((CC[s[\":\"!((CC[s[\")+de(ba-1)+\"]]^CC"
++-"[s[\"+de(ba)+\"]])&\"+cz+')');break}}case'.':{var dd;if(!(dd=cX[au]))throw l(\"Invalid escape in regular expression\")"
++-";++X;if(dp=d0()){return dk(dl,ba,dA(\"s[\"+de(0)+']',dd),dB(0,dC),dp)}dl=dg(dl,dA(\"s[\"+de(ba)+']',dd));++ba;break}ca"
++-"se'(':{var dO=++cQ,dP='g'+dO,dQ=dP+'('+de(ba)+')',dR='j'+dO,dS=dR+'('+de(ba)+')',dT=true,dU=false,dV=false;++X;if(B[X]"
++-"==='?'){switch(B[X+1]){case'!':dV=true;case'=':dU=true;case':':dT=false;X+=2}}var dW=null,dX=null;if(dT){(dX=(dW=(cR++"
++-")*2)+1);cS+=\",c\"+dW+\",c\"+dX}var dY=cR,dZ=e0(0,(dU?void 0:dR)),e1=cR;if((au=B[X])!==')'){throw l(au?\"Unterminated "
++-"group in regular expression\":\"Invalid regular expression\")}++X;dp=(dU?null:d0());dn=dB(0,dC);dH=dZ;var e2='',e3=(dp"
++-"&&dp.d2>1);if(e3&&(dp.d2<h||dp.d1>1)){cS+=\",n\"+dO+\"=0\";dH=((dp.d2<h)?dg(\"++n\"+dO+\"<=\"+dp.d2,dH):\"++n\"+dO+\","
++-" \"+dH);if(dp.d1>1){dH=dg(dH,'n'+dO+\">=\"+dp.d1);e2='n'+dO+'<'+dp.d1}dH=dh(dH,\"(--n\"+dO+\",false)\")}if(dU){dG=dR+'"
++-"('+de(0)+')';if(dV){dH=\"!(\"+dH+')';if(dY<e1){var e4='';for(var u=dY;u<e1;++u)e4+='c'+u*2+'=';dG='('+e4+\"void 0, \"+"
++-"dG+')'}}dH=dg(dH,dG)}if(e3){cS+=\",p\"+dO;var e5='p'+dO+\"!=p\";dH=dg(e2?'('+dh(e5,e2)+')':e5,\"(p\"+dO+\"=p, \"+dH+')"
++-"')}di(dP,dt(dH,dW,dY,e1));if(e3){var e6=dP+'('+de(0)+')';dH=(dp.d3?dh(e6,dn):dh(dn,e6));di(dR,dt(dH,dX));dG=(dp.d1===0"
++-"?dS:dQ);dl=dg(dl,'(p'+dO+\"=void 0,\"+dG+')')}else{di(dR,dt(dn,dX));dl=((dp&&dp.d1===0)?dg(dl,(dp.d2===0?dS:'('+(dp.d3"
++-"?dh(dQ,dS):dh(dS,dQ))+')')):dg(dl,dQ))}return dl}default:break dD}}}switch(dC){case void 0:return dl;case'':return dg("
++-"dl,\"(q=\"+de(ba)+\",true)\");default:return dg(dl,dC+'('+de(ba)+')')}}function e0(ba,dC){var dl=dB(ba,dC);if(B[X]==='"
++-"|'){do{++X;dl=dh(dl,dB(ba,dC))}while(B[X]==='|');dl='('+dl+')'}return dl}var dZ=e0(0,'');if(X<B.length)throw l(\"Inval"
++-"id regular expression\");if(cT>cR)throw l(\"Invalid back reference in regular expression\");var dl=\"(function(s, p) {"
++-"\\n\";if(cN)dl+=\"\\ts=regExpCanonicalize(s)\\n\";dl+=\"\\tvar l=s.length,q\";dl+=cS+\";\\n\"+cP+\"\\tif (\"+dZ+\") re"
++-"turn [p,q\";for(var u=0;u<cR*2;++u)dl+=\",c\"+u;dl+=\"];\\n})\";return dl}var e7={'g':\"global\",'i':\"ignoreCase\",'m"
++-"':\"multiline\"},e8={},e9;function ea(b4,a7){a7=P(a7);var u;if((u=(b4.global?M(b4.lastIndex):0))>=0){var aW=i(b4,\"val"
++-"ue\"),ay=a7.length,aT;for(;u<=ay;++u)if(aT=aW(a7,u)){if(b4.global)b4.lastIndex=aT[1];return aT}}b4.lastIndex=0}functio"
++-"n aL(b4,a7){var aT,aM=null;if(aT=ea(b4,a7)){(aM=[]).input=a7;aM.index=aT[0];for(var b7=0;b7<aT.length;b7+=2)aM[aM.leng"
++-"th]=((aT[b7]===void 0)?void 0:$sub(a7,aT[b7],aT[b7+1]))}return aM}function eb(b4){return(b4.global?'g':'')+(b4.ignoreC"
++-"ase?'i':'')+(b4.multiline?'m':'')}var RegExp=a.distinctConstructor(function RegExp(ec,ed){return(i(ec,\"class\")===\"R"
++-"egExp\"&&ed===void 0?ec:new a.createRegExp(ec,ed))},a.createRegExp=function RegExp(ec,ed){if(i(ec,\"class\")===\"RegEx"
++-"p\"){if(ed!==void 0)throw n(\"Cannot supply flags when constructing one RegExp from another\");ed=eb(ec);ec=ec.source}"
++-"ec=(ec===void 0?'':P(ec));ed=(ed===void 0?'':P(ed));var ee={global:false,ignoreCase:false,multiline:false,source:ec};f"
++-"or(var u=ed.length-1;u>=0;--u){var X;if(!(X=e7[ed[u]])||ee[X])throw l(\"Invalid regular expression flags\");ee[X]=true"
++-"}var ef,eg;if(!(eg=e8[ef=ec+','+ee.ignoreCase+','+ee.multiline]))e8[ef]=eg=ah(cM(ec,ee.ignoreCase,ee.multiline));var b"
++-"4=a.createWrapper(\"RegExp\",eg,e9);Q(b4,{dontEnum:true,readOnly:true,dontDelete:true},ee);Q(b4,{dontEnum:true,dontDel"
++-"ete:true},{lastIndex:0});return b4});Q(RegExp,{dontEnum:true,readOnly:true,dontDelete:true},{prototype:e9=RegExp.proto"
++-"type});Q(RegExp.prototype,{dontEnum:true},{exec:c(function exec(a7){Y(this,\"RegExp\",\"exec\");return aL(this,a7)}),t"
++-"est:c(function test(a7){Y(this,\"RegExp\",\"test\");return ea(this,a7)!==void 0}),toString:c(function toString(){Y(thi"
++-"s,\"RegExp\",\"toString\");return'/'+this.source+'/'+eb(this)})});Q(b,{dontEnum:true},{Array:Array,Boolean:Boolean,Dat"
++-"e:Date,Function:Function,Math:a.createWrapper(\"Math\",void 0),Number:Number,Object:Object,RegExp:RegExp,String:String"
++-",isFinite:c(function isFinite(G){return e(+G)}),isNaN:c(function isNaN(G){return d(+G)}),JSON:a.createWrapper(\"JSON\""
++-",void 0),eval:a.evalFunction=c(function eval(bP){return a.eval(bP)}),parseFloat:c(function parseFloat(a7){return a.par"
++-"seFloat(P(a7))}),parseInt:c(function parseInt(a7,af){a7=P(a7);var s=r,u=-1,ag=1;while(s[a7[++u]]===null);switch(a7[u])"
++-"{case'-':ag=-1;case'+':++u}if(((af=N(af))===0||af===16)&&(a7[u]==='0'&&a7[u+1]==='x')){u+=2;af=16}if(af===0)af=10;else"
++-" if(af<2||af>36)return g;var G=0,y,aG=a7.length,C;for(y=u;u<aG&&(C=s[a7[u]])!=null&&C<af;++u)G=G*af+C;return(y===u?g:G"
++-"*ag)})});Q(b,{dontEnum:true,dontDelete:true},{NaN:g,Infinity:h,undefined:a.undefined});Q(Math,{readOnly:true,dontEnum:"
++-"true,dontDelete:true},{E:2.718281828459045235360,LN10:2.302585092994045684018,LN2:0.6931471805599453094172,LOG10E:0.43"
++-"429448190325182765113,LOG2E:1.442695040888963407360,PI:3.1415926535897932,SQRT1_2:0.7071067811865475244008,SQRT2:1.414"
++-"213562373095048802});Q(Math,{dontEnum:true},{abs:c(abs=function abs(G){return((G=+G)<0?-G:G)}),acos:c(function acos(G)"
++-"{return a.acos(+G)}),asin:c(function asin(G){return a.asin(+G)}),atan:c(function atan(G){return a.atan(+G)}),atan2:c(f"
++-"unction atan2(c8,bP){return a.atan2(+c8,+bP)}),ceil:c(function ceil(G){return-f(-G)}),cos:c(function cos(G){return a.c"
++-"os(+G)}),exp:c(function exp(G){return a.exp(+G)}),floor:c(function floor(G){return f(+G)}),log:c(function log(G){retur"
++-"n a.log(+G)}),max:c(function max(bP,c8){var aT=-h,G,ak;for(var u=(ak=arguments).length-1;u>=0;--u)if((G=+ak[u])>aT||d("
++-"G))aT=G;return aT}),min:c(function min(bP,c8){var aT=h,G,ak;for(var u=(ak=arguments).length-1;u>=0;--u)if((G=+ak[u])<a"
++-"T||d(G))aT=G;return aT}),pow:c(function pow(bP,c8){return a.pow(+bP,+c8)}),random:c(function random(){return a.random("
++-")}),round:c(function round(G){return(G===0.0?G:(G>=-0.5&&G<0.0?-0.0:f(G+0.5)))}),sin:c(function sin(G){return a.sin(+G"
++-")}),sqrt:c(function sqrt(G){return a.sqrt(+G)}),tan:c(function tan(G){return a.tan(+G)})});function eh(name,prototype)"
++-"{return function(message){var aG;a.defineProperty(aG=a.createWrapper(\"Error\",name,prototype),\"message\",(message!=="
++-"void 0?P(message):''),false,true,false);return aG}};(function(){var ei=[\"Error\",\"EvalError\",\"RangeError\",\"Refer"
++-"enceError\",\"SyntaxError\",\"TypeError\",\"URIError\"];for(var u=ei.length;--u>=0;){var C,au,X;a.defineProperty(b,C=e"
++-"i[u],au=eh(C,X=a.prototypes[C]),false,true,false);au.name=C;Q(au,{dontEnum:true,readOnly:true,dontDelete:true},{protot"
++-"ype:X});Q(X,{dontEnum:true},{constructor:au});X.name=C}Q(Error.prototype,{dontEnum:true},{message:'',toString:c(functi"
++-"on toString(){return(this.name===void 0?\"Error\":this.name)+(this.message?(\": \"+this.message):'')})});l=SyntaxError"
++-";m=RangeError;n=TypeError})();var ej={'\\\\':\"\\\\\\\\\",'\"':\"\\\\\\\"\",'\\b':\"\\\\b\",'\\f':\"\\\\f\",'\\n':\"\\"
++-"\\n\",'\\r':\"\\\\r\",'\\t':\"\\\\t\"};var ek=61;Q(JSON,{dontEnum:true},{stringify:c(function stringify(ae,el,em){var "
++-"en=[],eo=(typeof el===\"function\"?el:null),ep='',eq;if(i(el,\"class\")===\"Array\"){eq={};for(var u=el.length;--u>=0;"
++-")eq[el[u]]=true}if(typeof em===\"number\"||(typeof em===\"object\"&&i(em,\"class\")===\"Number\")){em=+em;for(var u=(e"
++-"m>10?10:em);--u>=0;)ep+=' '}else if(typeof em===\"string\"||(typeof em===\"object\"&&i(em,\"class\")===\"String\")){ep"
++-"=$sub(P(em),0,10)}function er(B){var H='\"',ay=B.length;for(var u=0;u<ay;++u){var aU=B[u],es;H+=((es=ej[aU])?es:((aU>="
++-"' '&&aU<='~')?aU:\"\\\\u\"+a1(ad(k(aU,0),16),4)))}return H+'\"'}function a7(ef,et,eu){var ae;if((ae=et[ef])&&typeof ae"
++-"===\"object\"&&typeof ae.toJSON===\"function\")ae=ae.toJSON(ef);if(eo)ae=j(eo,et,[ef,ae]);var ev=(ep?'\\n'+eu:'');if(t"
++-"ypeof ae===\"object\"){switch(i(ae,\"class\")){case\"Number\":ae=+ae;break;case\"String\":ae=P(ae);break;case\"Boolean"
++-"\":ae=i(ae,\"value\");break}}switch(typeof ae){case\"object\":{if(!ae)return\"null\";var ay,B=new x,G;for(var u=(ay=en"
++-".length);--u>=0;){if(en[u]===ae)throw n(\"Cannot convert circular structure to JSON\")}if(ay>ek)throw n(\"Structure to"
++-"o deeply nested for JSON conversion\");en[ay]=ae;if(i(ae,\"class\")===\"Array\"){ay=ae.length;for(var u=0;u<ay;++u){B."
++-"A((u==0?'[':',')+ev+ep+(a7(u,ae,eu+ep)||\"null\"))}B.A(ay==0?\"[]\":ev+']')}else{var ew=false;for(var cL in(eq?eq:ae))"
++-"{if(a.hasOwnProperty(ae,cL)){if(G=a7(cL,ae,eu+ep)){B.A((ew?',':'{')+ev+ep+er(cL)+(ep?\": \":':')+G);ew=true}}}B.A(ew?e"
++-"v+'}':\"{}\")}--en.length;return B.D()}case\"string\":return er(ae);case\"number\":return(e(ae)?P(ae):\"null\");case\""
++-"boolean\":return P(ae)}}return a7('',{'':ae},'')}),parse:c(function parse(ex,ey){var ez=0;function em(H,X){var aU;whil"
++-"e((aU=H[X])===' '||aU==='\\t'||aU==='\\r'||aU==='\\n')++X;return X}function eA(H,X){var aU;if(H[X]==='-')++X;if((aU=H["
++-"X])==='0')aU=H[++X];else if(aU>='1'&&aU<='9')do{aU=H[++X]}while(aU>='0'&&aU<='9');else return;if(aU==='.'){if((aU=H[++"
++-"X])<'0'||aU>'9')return;while((aU=H[++X])>='0'&&aU<='9')}if(aU==='e'||aU==='E'){if((aU=H[++X])==='-'||aU==='+')aU=H[++X"
++-"];if(aU<'0'||aU>'9')return;while((aU=H[++X])>='0'&&aU<='9')}return X}function a7(H,X){var aU;if(H[X]!=='\"')return;++X"
++-";while((aU=H[X])!=='\"'&&aU>=' '){if(aU==='\\\\'){switch(H[++X]){default:return;case'\"':case'/':case'\\\\':case'b':ca"
++-"se'f':case'n':case'r':case't':break;case'u':for(var u=4;--u>=0;)if(!(((aU=H[++X])>='0'&&aU<='9')||(aU>='a'&&aU<='f')||"
++-"(aU>='A'&&aU<='F')))return;break}}++X}if(aU==='\"')return++X}function eB(H,X){if($match(H,X,\"true\")||$match(H,X,\"nu"
++-"ll\"))return X+4;else if($match(H,X,\"false\"))return X+5}function R(H,X){if(ez>ek)throw n(\"Structure too deeply nest"
++-"ed for JSON conversion\");++ez;try{var aU,eC=false,eD=H[X],eE=(eD==='['?']':'}');X=em(H,++X);while((aU=H[X])!==eE&&aU)"
++-"{if(eC){if(aU!==',')return;X=em(H,++X)}if(eD==='{'){if(!(X=a7(H,X))||H[X=em(H,X)]!==':')return;X=em(H,++X)}if(!(eF=eG["
++-"H[X]])||!(X=eF(H,X)))return;X=em(H,X);eC=true}if(aU===eE)return++X}finally{--ez}}var eG={'{':R,'[':R,'\"':a7,'t':eB,'f"
++-"':eB,'n':eB,'-':eA,'0':eA,'1':eA,'2':eA,'3':eA,'4':eA,'5':eA,'6':eA,'7':eA,'8':eA,'9':eA};ex=P(ex);var X,eF;if((eF=eG["
++-"ex[X=em(ex,0)]])&&(X=eF(ex,X))&&em(ex,X)===ex.length){var ae=eval('('+ex+')');if(typeof ey===\"function\"){function eH"
++-"(et,ef){var cL,G,J;if(typeof(J=et[ef])===\"object\"&&J){for(cL in J){if(a.hasOwnProperty(J,cL)){if((G=eH(J,cL))!==void"
++-" 0)J[cL]=G;else delete J[cL]}}}return j(ey,et,[ef,J])}ae=eH({\"\":ae},\"\")}return ae}throw l(\"Error parsing JSON\")}"
++-")});Q(Array,{dontEnum:true},{isArray:c(function isArray(J){return i(J,\"class\")===\"Array\"})});Q(Object,{dontEnum:tr"
++-"ue},{defineProperty:c(function defineProperty(J,X,cb){a.defineProperty(J,P(X),cb.value,!cb.writable,!cb.enumerable,!cb"
++-".configurable)}),getPrototypeOf:c(function getPrototypeOf(J){return i(J,\"prototype\")})});if(g.toString()!==\"NaN\")t"
++-"hrow Error(\"Internal self test failed. Check C++ compiler options concerning IEEE 754 compliance.\")})"
+++"){return az(this)}),toLocaleLowerCase:c(function toLocaleLowerCase(){return az(this)}),trimLeft:c(function trimLeft(){"
+++"var B=P(this),u=0,b6=B.length,au;for(;u<b6;++u){au=B.charCodeAt(u);if(au!==0x20&&(au<0x09||au>0x0D)&&au!==0xA0&&au!==0"
+++"x2028&&au!==0x2029&&au!==0xFEFF)break}return $sub(B,u,b6)}),trimRight:c(function trimRight(){var B=P(this),b6=B.length"
+++",au;for(;b6>0;--b6){au=B.charCodeAt(b6-1);if(au!==0x20&&(au<0x09||au>0x0D)&&au!==0xA0&&au!==0x2028&&au!==0x2029&&au!=="
+++"0xFEFF)break}return $sub(B,0,b6)}),trim:c(function trim(){var B=P(this),u=0,b6=B.length,au;for(;u<b6;++u){au=B.charCod"
+++"eAt(u);if(au!==0x20&&(au<0x09||au>0x0D)&&au!==0xA0&&au!==0x2028&&au!==0x2029&&au!==0xFEFF)break}for(;b6>u;--b6){au=B.c"
+++"harCodeAt(b6-1);if(au!==0x20&&(au<0x09||au>0x0D)&&au!==0xA0&&au!==0x2028&&au!==0x2029&&au!==0xFEFF)break}return $sub(B"
+++",u,b6)}),valueOf:c(function valueOf(){Y(this,\"String\",\"valueOf\");return i(this,\"value\")}),toString:c(function to"
+++"String(){Y(this,\"String\",\"toString\");return i(this,\"value\")})});var Array=function Array(G){var aM=[],ak,aB;if(("
+++"aB=(ak=arguments).length)===1&&typeof G===\"number\"){if((G>>>0)!==G)throw m(\"Invalid array length\");aM.length=G}els"
+++"e{for(var u=0;u<aB;++u)aM[u]=ak[u]}return aM};Q(Array,{dontEnum:true,readOnly:true,dontDelete:true},{prototype:a.proto"
+++"types.Array});Q(Array.prototype,{dontEnum:true},{constructor:Array,concat:c(function concat(b7){var aM=[],ak,aB=(ak=ar"
+++"guments).length,C=0,G=this;for(var u=-1;u<aB;G=ak[++u]){if(i(G,\"class\")!==\"Array\"){aM[C++]=G}else{for(var b6=0,aG="
+++"G.length;b6<aG;++b6)if(b6 in G)aM[C+b6]=G[b6];aM.length=(C+=b6)}}return aM}),join:c(function join(aZ){var B=new x,b8,a"
+++"y=O(this.length);aZ=(aZ===void 0?',':P(aZ));for(var u=0;u<ay;++u){if(u>0)B.A(aZ);if((b8=this[u])!=null)B.A(P(b8))}retu"
+++"rn B.D()}),pop:c(function pop(){var G=void 0,ay;if((ay=O(this.length))>0)G=this[--ay];this.length=ay;return G}),push:c"
+++"(function push(b9){var ak,ba=O(this.length),aY=(ak=arguments).length+ba;for(var u=ba;u<aY;++u)this[u]=ak[u-ba];return("
+++"this.length=aY)}),reverse:c(function reverse(){var ay,bb=f((ay=O(this.length))/2);--ay;for(var bc=0;bc<bb;++bc){var bd"
+++"=ay-bc;var be=(bd in this),bf=this[bd];if(bc in this)this[bd]=this[bc];else delete this[bd];if(be)this[bc]=bf;else del"
+++"ete this[bc]}return this}),shift:c(function shift(){var ay,bg;if(ay=O(this.length)){bg=this[0];for(var u=1;u<ay;++u){i"
+++"f(u in this)this[u-1]=this[u];else delete this[u-1]}--ay};this.length=ay;return bg}),slice:c(function slice(aX,aY){var"
+++" aM=[],ay=O(this.length);if((aX=M(aX))<0){aX+=ay;if(aX<0)aX=0}if(aY===void 0||(aY=M(aY))>ay)aY=ay;else if(aY<0)aY+=ay;"
+++"for(var u=aX,b6=0;u<aY;++u,++b6)if(u in this)aM[b6]=this[u];aM.length=b6;return aM}),sort:c(function sort(bh){var bi=t"
+++"his;function b5(bj,bk,bl){var bm=(bk in bj),bn=bj[bk];if(bl in bj)bj[bk]=bj[bl];else delete bj[bk];if(bm)bj[bl]=bn;els"
+++"e delete bj[bl]};function bo(bj,bk,bl){if(!(bk in bj)&&!(bl in bj))return 0;else if(!(bk in bj))return 1;else if(!(bl "
+++"in bj))return-1;else{var aM=bj[bk];var y=bj[bl];if(aM===void 0&&y===void 0)return 0;else if(aM===void 0)return 1;else "
+++"if(y===void 0)return-1;else return bh(aM,y)}};function bp(bq,br){var bs=b5,bt=bo,bj=bi,bb,bu;for(--br;bq+1<br;bq=bu){v"
+++"ar bv=br;bu=bq;bb=f((bu+bv)/2);while(bu<bv){while(bu<=bv&&bt(bj,bu,bb)<=0&&bt(bj,bv,bb)>=0){++bu;--bv}while(bu<=bv&&bt"
+++"(bj,bv,bb)>0)--bv;while(bu<=bv&&bt(bj,bu,bb)<0)++bu;if(bb===bu||bb===bv)bb^=bv^bu;if(bu<bv)bs(bj,bu,bv)}bp(bq,bu)}if(b"
+++"q<br&&bt(bj,bq,br)>0)bs(bj,bq,br)};if(bh===void 0){bh=function(aM,y){return((aM=P(aM))<(y=P(y))?-1:(aM>y?1:0))}};bp(0,"
+++"this.length>>>0);return this}),splice:c(function splice(aX,bw){var aM=[],ay=O(this.length),ak,aB=(ak=arguments).length"
+++",aY,bx,by;if((aX=M(aX))<0){aX+=ay;if(aX<0)aX=0}else if(aX>ay)aX=ay;if(aB==1||(aY=aX+M(bw))>ay)aY=ay;else if(aY<aX)aY=a"
+++"X;for(var u=aX,b6=0;u<aY;++u,++b6)if(u in this)aM[b6]=this[u];aM.length=b6;if((bx=aB-2)<0)bx=0;if((by=aX+bx-aY)!==0){v"
+++"ar bz=1,b6=aY;if(by>0){bz=-1;b6=ay-1}for(u=ay-aY;--u>=0;b6+=bz){if(b6 in this)this[b6+by]=this[b6];else delete this[b6"
+++"+by]}for(u=ay;--u>=ay+by;)delete this[u]}for(u=2,b6=aX;u<aB;++u,++b6)this[b6]=ak[u];this.length=ay+by;return aM}),toLo"
+++"caleString:Object.prototype.toLocaleString,toString:c(function toString(){Y(this,\"Array\",\"toString\");return this.j"
+++"oin()}),unshift:c(function unshift(b7){var ay,ak,C=(ak=arguments).length;if(ay=O(this.length)){for(var u=ay;--u>=0;){i"
+++"f(u in this)this[u+C]=this[u];else delete this[u+C]}}for(var u=0;u<C;++u)this[u]=ak[u];return(this.length=ay+C)}),forE"
+++"ach:c(function forEach(bA){var J=Object(this),ay=O(J.length),H=arguments[1];if(typeof bA!==\"function\")throw TypeErro"
+++"r();for(var bB=0;bB<ay;++bB)if(bB in J)bA.call(H,J[bB],bB,J)}),map:c(function map(bA){var J=Object(this),ay=O(J.length"
+++"),H=arguments[1],aM=new Array(ay);if(typeof bA!==\"function\")throw TypeError();for(var bB=0;bB<ay;++bB)if(bB in J)aM["
+++"bB]=bA.call(H,J[bB],bB,J);return aM}),filter:c(function filter(bA){var J=Object(this),ay=O(J.length),H=arguments[1],aM"
+++"=[],br=0;if(typeof bA!==\"function\")throw TypeError();for(var bB=0;bB<ay;++bB)if(bB in J){var G=J[bB];if(bA.call(H,G,"
+++"bB,J))aM[br++]=G}aM.length=br;return aM}),indexOf:c(function indexOf(bC){var ay=O(this.length),u=arguments[1];if(ay==="
+++"0)return-1;if((u=M(u))<0){u+=ay;if(u<0)u=0}for(;u<ay;++u)if(u in this&&this[u]===bC)return u;return-1}),lastIndexOf:c("
+++"function lastIndexOf(bC){var ay=O(this.length),u=arguments[1];if(ay===0)return-1;if(u===void 0)u=ay-1;else{u=M(u);if(u"
+++"<0)u+=ay;if(u>=ay)u=ay-1}for(;u>=0;--u)if(u in this&&this[u]===bC)return u;return-1}),reduce:c(function reduce(bA){var"
+++" J=Object(this),ay=O(J.length),bB=0,bD;if(typeof bA!==\"function\")throw TypeError();if(arguments.length>1)bD=argument"
+++"s[1];else{while(bB<ay&&!(bB in J))++bB;if(bB>=ay)throw TypeError();bD=J[bB++]}for(;bB<ay;++bB)if(bB in J)bD=bA.call(vo"
+++"id 0,bD,J[bB],bB,J);return bD}),reduceRight:c(function reduceRight(bA){var J=Object(this),ay=O(J.length),bB=ay-1,bD;if"
+++"(typeof bA!==\"function\")throw TypeError();if(arguments.length>1)bD=arguments[1];else{while(bB>=0&&!(bB in J))--bB;if"
+++"(bB<0)throw TypeError();bD=J[bB--]}for(;bB>=0;--bB)if(bB in J)bD=bA.call(void 0,bD,J[bB],bB,J);return bD}),every:c(fun"
+++"ction every(bA){var J=Object(this),ay=O(J.length),H=arguments[1];if(typeof bA!==\"function\")throw TypeError();for(var"
+++" bB=0;bB<ay;++bB)if(bB in J&&!bA.call(H,J[bB],bB,J))return false;return true}),some:c(function some(bA){var J=Object(t"
+++"his),ay=O(J.length),H=arguments[1];if(typeof bA!==\"function\")throw TypeError();for(var bB=0;bB<ay;++bB)if(bB in J&&b"
+++"A.call(H,J[bB],bB,J))return true;return false})});function bE(){var bF=a.localTimeDifference(14516064e5);var bG=a.loca"
+++"lTimeDifference(14673312e5);return(bF>bG?bF:bG)}function bH(){var bF=a.localTimeDifference(14516064e5);var bG=a.localT"
+++"imeDifference(14673312e5);return(bF<bG?bF:bG)}function bI(bJ){var a2=a.localTimeDifference(bJ);return(d(a2)?bH():a2)}f"
+++"unction bK(bJ){return d(bJ)?bJ:bJ+bI(bJ)}function bL(R){if(i(R,\"class\")!==\"Date\")throw n(\"this is not a Date obje"
+++"ct\")}function bM(R){bL(R);return i(R,\"value\")}function bN(R){return bK(bM(R))}function bO(R,G){bL(R);a.updateDateVa"
+++"lue(R,G);return G}function bP(G){return d(G=bK(G))?\"Invalid Date\":(bQ(G)+' '+bR(G))}function bS(bT,C){return(bT%C+C)"
+++"%C}function bU(bV,bW,bX,bY){return bV*36e5+bW*6e4+bX*1e3+bY}function bZ(bJ){return[bS(f(bJ/36e5),24),bS(f(bJ/6e4),60),"
+++"bS(f(bJ/1e3),60),bS(bJ,1e3)]}function c0(bJ){return d(bJ)?bJ:(bJ-bI(bJ-bE()))}function c1(bJ){return bS(f(bJ/864e5)+4,"
+++"7)}function c2(bJ){return bS(f(bJ/36e5),24)}function c3(bJ){return bS(f(bJ/6e4),60)}function c4(bJ){return bS(f(bJ/1e3"
+++"),60)}function c5(bJ){return bS(bJ,1e3)}function c6(bJ){return(!e(bJ)||abs(bJ)>8.64e15?g:M(bJ))}function c7(bJ){return"
+++" c0(c6(bJ))}function c8(bJ){bJ=f(bJ/864e5)+719468;var c9=M((bJ>=0?bJ:bJ-146096)/146097);var ca=bJ-c9*146097;var cb=M(("
+++"ca-M(ca/1460)+M(ca/36524)-M(ca/146096))/365);var cc=cb+c9*400;var cd=ca-(365*cb+M(cb/4)-M(cb/100));var ce=M((5*cd+2)/1"
+++"53);var aT=ce+(ce<10?2:-10);var cf=cd-M((153*ce+2)/5)+1;return[(cc+(aT<=1)),aT,cf]}function bQ(bJ){var cc,cg=c8(bJ);re"
+++"turn(0<=(cc=cg[0])&&cc<=9999?a1(cc,4):(cc<0?\"-\":\"+\")+a1(abs(cc),6))+\"-\"+a1(cg[1]+1,2)+\"-\"+a1(cg[2],2)}function"
+++" bR(bJ,bY){var ch=bZ(bJ);return a1(ch[0],2)+\":\"+a1(ch[1],2)+\":\"+a1(ch[2],2)+(bY?\".\"+a1($sub(ch[3],0,3),3):\"\")}"
+++"function ci(cj,ck,cl){cj+=f(ck/12)-(bS(ck,12)<=1);var c9=M((cj>=0?cj:cj-399)/400);var cb=cj-c9*400;var cd=M((153*(ck+("
+++"ck>1?-2:10))+2)/5)+cl-1;var ca=cb*365+M(cb/4)-M(cb/100)+cd;return(c9*146097+ca-719468)*864e5}function cm(bJ,C,aM){var "
+++"u,cf=c8(bJ),aN=bS(bJ,864e5);for(u=0;u<aM.length;++u,++C)cf[C]=M(aM[u]);return j(ci,null,cf)+aN}function cn(bJ,C,aM){va"
+++"r u,H=bZ(bJ),aN=f(bJ/864e5)*864e5;for(u=0;u<aM.length;++u,++C)H[C]=M(aM[u]);return j(bU,null,H)+aN}function co(cj,ck,c"
+++"p,cq,cr,cs,bY){var aB=arguments.length;return ci((cj=M(cj))+(0<=cj&&cj<=99?1900:0),M(ck),(aB>2?M(cp):1))+bU(aB>3?M(cq)"
+++":0,aB>4?M(cr):0,aB>5?M(cs):0,aB>6?M(bY):0)}function ct(cf){var bJ;return d(bJ=bM(cf))?null:bQ(bJ)+\"T\"+bR(bJ,true)+\""
+++"Z\"}var cu,Date=a.distinctConstructor(function Date(){return bP(a.getCurrentTime())},function Date(cj,ck,cp,cq,cr,cs,b"
+++"Y){var G,aB;if((aB=arguments.length)>=2&&aB<=7)G=c7(j(co,null,arguments));else if(aB===1)G=c6(typeof(G=a.toPrimitive(c"
+++"j))===\"string\"?cu(G):+G);else G=a.getCurrentTime();return a.createWrapper(\"Date\",G,a.prototypes.Date)});Q(Date,{do"
+++"ntEnum:true,readOnly:true,dontDelete:true},{prototype:a.prototypes.Date});Q(Date,{dontEnum:true},{parse:c(cu=function "
+++"parse(B){var bJ,cc,u,aU,cv,cw,cx,u=0;function cy(ay){var G;for(G=0;--ay>=0;)if(\"0\"<=B[u]&&B[u]<=\"9\")G=G*10+(+B[u++"
+++"]);else return g;return G}bJ=ci(((aU=B[u])===\"+\"||aU===\"-\")&&(++u,cc=cy(6),aU===\"-\"?-cc:cc)||cy(4),B[u]===\"-\"&"
+++"&(++u,cy(2)-1)||0,B[u]===\"-\"&&(++u,cy(2))||1);bJ+=bU(((aU=B[u])===\"T\"||aU===\"t\"||aU===' ')&&(++u,cy(2))||0,B[u]="
+++"==\":\"&&(++u,cy(2))||0,B[u]===\":\"&&(++u,cy(2))||0,B[u]===\".\"&&(++u,cy(3))||0);while((aU=B[u])!==void 0&&aU!==\"Z"
+++"\"&&aU!==\"z\"&&aU!==\"+\"&&aU!==\"-\")++u;if(aU===\"Z\"||aU===\"z\")cv=0;else if(aU===\"+\"||aU===\"-\"){++u,cw=cy(2)"
+++"*36e5,B[u]===\":\"&&++u,cw+=d(cx=cy(2))?0:cx*6e4,d(cw)||(cv=aU===\"-\"?-cw:cw)}return(cv===void 0?c0(bJ):bJ-cv)}),UTC:"
+++"c(function UTC(cj,ck,cp,cq,cr,cs,bY){return c6(co(cj,ck,cp,cq,cr,cs,bY))}),now:c(function now(){return a.getCurrentTim"
+++"e()})});Q(Date.prototype,{dontEnum:true},{constructor:Date,toISOString:c(function toISOString(){var B;if((B=ct(this))="
+++"==null)throw m(\"Invalid time value\");return B}),toUTCString:c(function toUTCString(){var bJ;if(d(bJ=bM(this)))return"
+++"\"Invalid Date\";return(bQ(bJ)+' '+bR(bJ))}),toString:c(function toString(){return bP(bM(this))}),toDateString:c(funct"
+++"ion toDateString(){var a2;if(d(a2=bN(this)))return\"Invalid Date\";return bQ(a2)}),toTimeString:c(function toTimeStrin"
+++"g(){var a2;if(d(a2=bN(this)))return\"Invalid Date\";return bR(a2)}),toLocaleString:Object.prototype.toLocaleString,toL"
+++"ocaleDateString:c(function toLocaleDateString(){return this.toDateString()}),toLocaleTimeString:c(function toLocaleTim"
+++"eString(){return this.toTimeString()}),valueOf:c(function valueOf(){return bM(this)}),getTime:c(function getTime(){ret"
+++"urn bM(this)}),getFullYear:c(function getFullYear(){return c8(bN(this))[0]}),getUTCFullYear:c(function getUTCFullYear("
+++"){return c8(bM(this))[0]}),getMonth:c(function getMonth(){return c8(bN(this))[1]}),getUTCMonth:c(function getUTCMonth("
+++"){return c8(bM(this))[1]}),getDate:c(function getDate(){return c8(bN(this))[2]}),getUTCDate:c(function getUTCDate(){re"
+++"turn c8(bM(this))[2]}),getDay:c(function getDay(){return c1(bN(this))}),getUTCDay:c(function getUTCDay(){return c1(bM("
+++"this))}),getHours:c(function getHours(){return c2(bN(this))}),getUTCHours:c(function getUTCHours(){return c2(bM(this))"
+++"}),getMinutes:c(function getMinutes(){return c3(bN(this))}),getUTCMinutes:c(function getUTCMinutes(){return c3(bM(this"
+++"))}),getSeconds:c(function getSeconds(){return c4(bN(this))}),getUTCSeconds:c(function getUTCSeconds(){return c4(bM(th"
+++"is))}),getMilliseconds:c(function getMilliseconds(){return c5(bN(this))}),getUTCMilliseconds:c(function getUTCMillisec"
+++"onds(){return c5(bM(this))}),getTimezoneOffset:c(function getTimezoneOffset(){var G=bM(this);return(G-bK(G))/6e4}),set"
+++"Time:c(function setTime(time){return bO(c6(+time))}),setMilliseconds:c(function setMilliseconds(bY){return bO(this,c7("
+++"cn(bN(this),3,arguments)))}),setUTCMilliseconds:c(function setUTCMilliseconds(bY){return bO(this,c6(cn(bM(this),3,argu"
+++"ments)))}),setSeconds:c(function setSeconds(B,bY){return bO(this,c7(cn(bN(this),2,arguments)))}),setUTCSeconds:c(funct"
+++"ion setUTCSeconds(B,bY){return bO(this,c6(cn(bM(this),2,arguments)))}),setMinutes:c(function setMinutes(aT,B,bY){retur"
+++"n bO(this,c7(cn(bN(this),1,arguments)))}),setUTCMinutes:c(function setUTCMinutes(aT,B,bY){return bO(this,c6(cn(bM(this"
+++"),1,arguments)))}),setHours:c(function setHours(cz,aT,B,bY){return bO(this,c7(cn(bN(this),0,arguments)))}),setUTCHours"
+++":c(function setUTCHours(cz,aT,B,bY){return bO(this,c6(cn(bM(this),0,arguments)))}),setDate:c(function setDate(cp){retu"
+++"rn bO(this,c7(cm(bN(this),2,arguments)))}),setUTCDate:c(function setUTCDate(cp){return bO(this,c6(cm(bM(this),2,argume"
+++"nts)))}),setMonth:c(function setMonth(ck,cp){return bO(this,c7(cm(bN(this),1,arguments)))}),setUTCMonth:c(function set"
+++"UTCMonth(ck,cp){return bO(this,c6(cm(bM(this),1,arguments)))}),setFullYear:c(function setFullYear(cj,ck,cp){var G;retu"
+++"rn bO(this,c7(cm(d(G=bM(this))?0:bK(G),0,arguments)))}),setUTCFullYear:c(function setUTCFullYear(cj,ck,cp){var G;retur"
+++"n bO(this,c6(cm(d(G=bM(this))?0:G,0,arguments)))}),toJSON:c(function toJSON(){return ct(this)})});var G=1;var cA=G,cB="
+++"(G<<=1),cC=(G<<=1),cD=(G<<=1),cE=(G<<=1),cF=(G<<=1),cG=(G<<=1),cH=(G<<=1),cI=(G<<=1),cJ=(G<<=1),cK=(G<<=1);var CC={};("
+++"function(){function cL(cM,cN){for(var u in cN)CC[cN[u]]|=cM}cL(cI,\"^$.*+?()[]{}|\");cL(cE|cG|cD,\"0123456789\");cL(cG"
+++"|cF|cD,\"abcdefABCDEF\");cL(cF|cD,\"ghijklmnopqrstuvwxyzGHIJKLMNOPQRSTUVWXYZ\");cL(cB|cC,\"\\n\\r\\u2028\\u2029\");cL("
+++"cC,\" \\t\\v\\f\\xA0\");CC['_']|=cD;CC[\"undefined\"]|=cA;CC['']|=cA;cL(cH,\"fnrtv\");for(var u=32;u<=126;++u){var au="
+++"a.fromCharCode(u);if(au!=='\"'&&au!=='\\\\')CC[a.fromCharCode(u)]|=cJ}var cO=[0,48,58,65,91,95,96,97,123,128];for(var "
+++"u=cO.length-2;u>=0;u-=2)for(var b6=cO[u],bB=cO[u+1];b6<bB;++b6)CC[a.fromCharCode(b6)]|=cK})();function regExpCanonical"
+++"ize(B){var H='',au,cf;if(!as)at();for(var u=0,ay=B.length;u<ay;++u)H+=((cf=as[au=B[u]])&&cf.length===1&&(au<'\\x80'||c"
+++"f>='\\x80')?cf:au);return H}function cP(B,cQ,cR){var X=0,cS='',cT=0,cU=0,cV='',cW=0;function cX(cY,cM){return((CC[cY]&"
+++"cM)!==0)}function cZ(B,cM){for(var u=B.length-1;u>=0;--u)if((CC[B[u]]&cM)===0)return false;return true}var d0={'D':[cE"
+++",true],'d':[cE,false],'S':[cC,true],'s':[cC,false],'W':[cD,true],'w':[cD,false],'.':[cB,true]};function d1(d2){var C=d"
+++"2;if(cX(B[X],cE)){C=0;do{C=C*10+(k(B,X)-48);++X}while(cX(B[X],cE))}return C}function d3(){var d4=0,d5=h,d6=true;switch"
+++"(B[X]){case'*':++X;break;case'+':++X;d4=1;break;case'?':++X;d5=1;break;case'{':{var y=X;++X;if((d4=d5=d1(-1))<0){X=y;r"
+++"eturn null}if(B[X]===','){++X;d5=d1(h)}if(B[X]!=='}'){X=y;return null}if(d4>d5){throw l(\"Min greater than max in regu"
+++"lar expression quantifier\")}++X;break}default:return null}if(B[X]==='?'){++X;d6=false}return{d4:d4,d5:d5,d6:d6}}funct"
+++"ion d7(au){if(cX(au,cJ))return au;return(au<='~'?\"\\\\x\":\"\\\\u\")+a1(ad(k(au,0),16),(au<='~'?2:4))}function d8(au)"
+++"{return d7(cQ?regExpCanonicalize(au):au)}function d9(){var da,db,dc;if((da=B[X])==='\\\\'){switch(db=B[X+1]){case'0':{"
+++"if(!cX(B[X+2],cE)){X+=2;return'\\0'}break}case'c':{if(cX(B[X+2],cF)){X+=3;return a.fromCharCode(k(B,X-1)&31)}break}cas"
+++"e'x':case'u':{var C=(db==='x'?2:4);if(cZ(dc=$sub(B,X+2,X+2+C),cG)){X+=2+C;return a.fromCharCode(parseInt(dc,16))}break"
+++"}default:{if(cX(db,cH)){X+=2;return eval('\"\\\\'+db+'\"')}else if(cX(db,cK)){X+=2;return db}break}}}else if(da){++X;r"
+++"eturn da}}function dd(){var de=[],G,C=0;while(!cX(B[X],cI)&&(G=d9()))de[C++]=d8(G);return(de.length?de:null)}function "
+++"df(){var G,dg,au;if((au=B[X])!==']'&&(G=d9()))return G;if(au==='\\\\'){if((au=B[X+1])==='b'){X+=2;return'\\b'}if(dg=d0"
+++"[au]){X+=2;return dg}}}function dh(ba){return(ba===0?'p':((ba<0?'p':'p+')+ba))}function di(de,ba){if(de.length===0)ret"
+++"urn\"true\";else if(de.length===1)return\"s[\"+dh(ba)+']===\"'+de[0]+'\"';else if(de.length===2)return\"s[\"+dh(ba)+']"
+++"===\"'+de[0]+'\" && s['+dh(ba+1)+']===\"'+de[1]+'\"';else{for(var u=0,B='',a2=de.length;u<a2;++u)B+=de[u];return\"$mat"
+++"ch(s,\"+dh(ba)+',\"'+B+'\")'}}function dj(aM,y){switch(aM){case\"false\":return\"false\";case\"true\":return y;default"
+++":return(y===\"true\"?aM:aM+\" && \"+y)}}function dk(aM,y){switch(aM){case\"false\":return y;case\"true\":return\"true"
+++"\";default:return(y===\"false\"?aM:aM+\" || \"+y)}}function dl(name,dm){cS+=\"\\tfunction \"+name+\"(p) { \"+dm+\" }\\"
+++"n\"}function dn(dp,ba,dq,dr,ds,dt){var du='q'+(++cT),dv=(dt?\"var h=\"+dt+\",\":\"var \")+(ds.d4?\"b=p+\"+ds.d4+(dt?\""
+++"*h\":\"\"):\"b=p\")+(ds.d5<h?\",e=p+\"+ds.d5+(dt?\"*h\":\"\"):\"\")+\"; \";if(dt)dv+=\"if (h<=0 || h!==h) return \"+dr"
+++"+\"; \";if(ds.d6){dl(du,dv+\"while (\"+dj((ds.d5<h?\"p<e\":\"true\"),dq)+\") \"+(dt?\"p+=h\":\"++p\")+\"; while (\"+dj"
+++"(\"p>=b\",\"!(\"+dr+\")\")+\") \"+(dt?\"p-=h\":\"--p\")+\"; return p>=b\")}else{dl(du,dv+\"while (\"+dk((ds.d4?\"p<b\""
+++":\"false\"),\"!(\"+dr+\")\")+\") { if (\"+dk((ds.d5<h?\"p>=e\":\"false\"),\"!(\"+dq+\")\")+\") return false; \"+(dt?\""
+++"p+=h\":\"++p\")+\" }; return true\")}return dj(dp,du+\"(\"+dh(ba)+\")\")}function dw(dp,dx,dy,dz){if(dx===null&&dy===d"
+++"z){return\"return \"+dp}else{var dA='',dB='',dC='';if(dx!==null){dA+='r'+dx+\"=c\"+dx;dB='c'+dx+\"=p\";dC='c'+dx+\"=r"
+++"\"+dx}if(dz!==void 0){for(var u=dy;u<dz;++u){var b6=u*2;if(dx!==null||u>dy){dA+=',';dC+=',';if(u===dy){dB+=','}}dA+='r"
+++"'+b6+\"=c\"+b6;dB+='c'+b6+'=';dC+='c'+b6+\"=r\"+b6;if(u===dz-1){dB+=\"void 0\"}}}dp=dB+\", \"+dk(dp,'('+dC+\",false)\""
+++");return\"var \"+dA+\"; return \"+dp}}function dD(aU,dg){return(dg[1]?'!':\"!!\")+\"(CC[\"+aU+\"]&\"+(dg[0]|(dg[1]?cA:"
+++"0))+')'}function dE(ba,dF){var de,ds,dp=\"true\";dG:for(;;){if(de=dd()){if(ds=d3()){var dH=de[de.length-1];--de.length"
+++";return dn(dj(dp,di(de,ba)),ba+de.length,di(dH,0),dE(0,dF),ds)}dp=dj(dp,di(de,ba));ba+=de.length}else{var au,dI,dr,dJ,"
+++"dK;switch(au=B[X]){case'^':{++X;dI=dh(ba)+\"===0\";if(cR)dI='('+dk(dI,\"!!(CC[s[\"+dh(ba-1)+\"]]&\"+cB+')')+')';dp=dj("
+++"dp,dI);break}case'$':{++X;dI=dh(ba)+\"===l\";if(cR)dI='('+dk(dI,\"!!(CC[s[\"+dh(ba)+\"]]&\"+cB+')')+')';dp=dj(dp,dI);b"
+++"reak}case'[':{var dL=false,dM,dN,dO=\"false\";if(B[++X]==='^'){dL=true;++X}while(dM=df()){var y=X;if(B[X]==='-'&&(++X,"
+++"dN=df())){if(typeof dM===\"string\"&&typeof dN===\"string\"&&dM<=dN){if(cQ&&(dM>'~'||dN>'~'||(regExpCanonicalize(dM)!="
+++"=dM)!==(regExpCanonicalize(dN)!==dN))){dM=d7(dM);dN=d7(dN);dO=dk(dO,dj('upperToLower[c]>=\"'+dM+'\"','upperToLower[c]<"
+++"=\"'+dN+'\"'))}else{dM=d8(dM);dN=d8(dN)}dO=dk(dO,dj('c>=\"'+dM+'\"','c<=\"'+dN+'\"'))}else{throw l(\"Invalid character"
+++" class syntax in regular expression\")}}else if(typeof dM===\"string\"){X=y;dO=dk(dO,'c===\"'+d8(dM)+'\"')}else{dO=dk("
+++"dO,dD('c',dM))}}if(B[X]!==']'){throw l(\"Invalid character class syntax in regular expression\")}++X;var du='k'+(++cT)"
+++";dl(du,\"var c=s[p]; return \"+(dL?\"p!==l && !(\"+dO+')':dO));if(ds=d3()){return dn(dp,ba,du+'('+dh(0)+')',dE(0,dF),d"
+++"s)}dp=dj(dp,du+'('+dh(ba)+')');++ba;break}case'\\\\':{var C;++X;if((C=d1(-1))>=0){if(C>cW)cW=C;C=(C-1)*2;ds=d3();var d"
+++"t='c'+(C+1)+\"-c\"+C,dP=\"$match(s,\"+dh(ba)+\",$sub(s, c\"+C+\",c\"+(C+1)+\"))\";dr=dE(0,dF);var dQ='t'+(++cT);dl(dQ,"
+++"\"return \"+dr);return ds?dn(dp,ba,dP,dQ+'('+dh(0)+')',ds,dt):dj(dp,'(c'+C+\"<c\"+(C+1)+\" ? \"+dj(dP,dQ+'('+dh(ba)+'+"
+++"'+dt+')')+\" : \"+dQ+'('+dh(ba)+\"))\")}else if((au=B[X])==='b'||au==='B'){++X;dp=dj(dp,(au==='b'?\"!!((CC[s[\":\"!((C"
+++"C[s[\")+dh(ba-1)+\"]]^CC[s[\"+dh(ba)+\"]])&\"+cD+')');break}}case'.':{var dg;if(!(dg=d0[au]))throw l(\"Invalid escape "
+++"in regular expression\");++X;if(ds=d3()){return dn(dp,ba,dD(\"s[\"+dh(0)+']',dg),dE(0,dF),ds)}dp=dj(dp,dD(\"s[\"+dh(ba"
+++")+']',dg));++ba;break}case'(':{var dR=++cT,dS='g'+dR,dT=dS+'('+dh(ba)+')',dU='j'+dR,dV=dU+'('+dh(ba)+')',dW=true,dX=fa"
+++"lse,dY=false;++X;if(B[X]==='?'){switch(B[X+1]){case'!':dY=true;case'=':dX=true;case':':dW=false;X+=2}}var dZ=null,e0=n"
+++"ull;if(dW){(e0=(dZ=(cU++)*2)+1);cV+=\",c\"+dZ+\",c\"+e0}var e1=cU,e2=e3(0,(dX?void 0:dU)),e4=cU;if((au=B[X])!==')'){th"
+++"row l(au?\"Unterminated group in regular expression\":\"Invalid regular expression\")}++X;ds=(dX?null:d3());dr=dE(0,dF"
+++");dK=e2;var e5='',e6=(ds&&ds.d5>1);if(e6&&(ds.d5<h||ds.d4>1)){cV+=\",n\"+dR+\"=0\";dK=((ds.d5<h)?dj(\"++n\"+dR+\"<=\"+"
+++"ds.d5,dK):\"++n\"+dR+\", \"+dK);if(ds.d4>1){dK=dj(dK,'n'+dR+\">=\"+ds.d4);e5='n'+dR+'<'+ds.d4}dK=dk(dK,\"(--n\"+dR+\","
+++"false)\")}if(dX){dJ=dU+'('+dh(0)+')';if(dY){dK=\"!(\"+dK+')';if(e1<e4){var e7='';for(var u=e1;u<e4;++u)e7+='c'+u*2+'='"
+++";dJ='('+e7+\"void 0, \"+dJ+')'}}dK=dj(dK,dJ)}if(e6){cV+=\",p\"+dR;var e8='p'+dR+\"!=p\";dK=dj(e5?'('+dk(e8,e5)+')':e8,"
+++"\"(p\"+dR+\"=p, \"+dK+')')}dl(dS,dw(dK,dZ,e1,e4));if(e6){var e9=dS+'('+dh(0)+')';dK=(ds.d6?dk(e9,dr):dk(dr,e9));dl(dU,"
+++"dw(dK,e0));dJ=(ds.d4===0?dV:dT);dp=dj(dp,'(p'+dR+\"=void 0,\"+dJ+')')}else{dl(dU,dw(dr,e0));dp=((ds&&ds.d4===0)?dj(dp,"
+++"(ds.d5===0?dV:'('+(ds.d6?dk(dT,dV):dk(dV,dT))+')')):dj(dp,dT))}return dp}default:break dG}}}switch(dF){case void 0:ret"
+++"urn dp;case'':return dj(dp,\"(q=\"+dh(ba)+\",true)\");default:return dj(dp,dF+'('+dh(ba)+')')}}function e3(ba,dF){var "
+++"dp=dE(ba,dF);if(B[X]==='|'){do{++X;dp=dk(dp,dE(ba,dF))}while(B[X]==='|');dp='('+dp+')'}return dp}var e2=e3(0,'');if(X<"
+++"B.length)throw l(\"Invalid regular expression\");if(cW>cU)throw l(\"Invalid back reference in regular expression\");va"
+++"r dp=\"(function(s, p) {\\n\";if(cQ)dp+=\"\\ts=regExpCanonicalize(s)\\n\";dp+=\"\\tvar l=s.length,q\";dp+=cV+\";\\n\"+"
+++"cS+\"\\tif (\"+e2+\") return [p,q\";for(var u=0;u<cU*2;++u)dp+=\",c\"+u;dp+=\"];\\n})\";return dp}var ea={'g':\"global"
+++"\",'i':\"ignoreCase\",'m':\"multiline\"},eb={},ec;function ed(b4,a7){a7=P(a7);var u;if((u=(b4.global?M(b4.lastIndex):0"
+++"))>=0){var aW=i(b4,\"value\"),ay=a7.length,aT;for(;u<=ay;++u)if(aT=aW(a7,u)){if(b4.global)b4.lastIndex=aT[1];return aT"
+++"}}b4.lastIndex=0}function aL(b4,a7){var aT,aM=null;if(aT=ed(b4,a7)){(aM=[]).input=a7;aM.index=aT[0];for(var b6=0;b6<aT"
+++".length;b6+=2)aM[aM.length]=((aT[b6]===void 0)?void 0:$sub(a7,aT[b6],aT[b6+1]))}return aM}function ee(b4){return(b4.gl"
+++"obal?'g':'')+(b4.ignoreCase?'i':'')+(b4.multiline?'m':'')}var RegExp=a.distinctConstructor(function RegExp(ef,eg){retu"
+++"rn(i(ef,\"class\")===\"RegExp\"&&eg===void 0?ef:new a.createRegExp(ef,eg))},a.createRegExp=function RegExp(ef,eg){if(i"
+++"(ef,\"class\")===\"RegExp\"){if(eg!==void 0)throw n(\"Cannot supply flags when constructing one RegExp from another\")"
+++";eg=ee(ef);ef=ef.source}ef=(ef===void 0?'':P(ef));eg=(eg===void 0?'':P(eg));var eh={global:false,ignoreCase:false,mult"
+++"iline:false,source:ef};for(var u=eg.length-1;u>=0;--u){var X;if(!(X=ea[eg[u]])||eh[X])throw l(\"Invalid regular expres"
+++"sion flags\");eh[X]=true}var ei,ej;if(!(ej=eb[ei=ef+','+eh.ignoreCase+','+eh.multiline]))eb[ei]=ej=ah(cP(ef,eh.ignoreC"
+++"ase,eh.multiline));var b4=a.createWrapper(\"RegExp\",ej,ec);Q(b4,{dontEnum:true,readOnly:true,dontDelete:true},eh);Q(b"
+++"4,{dontEnum:true,dontDelete:true},{lastIndex:0});return b4});Q(RegExp,{dontEnum:true,readOnly:true,dontDelete:true},{p"
+++"rototype:ec=RegExp.prototype});Q(RegExp.prototype,{dontEnum:true},{exec:c(function exec(a7){Y(this,\"RegExp\",\"exec\""
+++");return aL(this,a7)}),test:c(function test(a7){Y(this,\"RegExp\",\"test\");return ed(this,a7)!==void 0}),toString:c(f"
+++"unction toString(){Y(this,\"RegExp\",\"toString\");return'/'+this.source+'/'+ee(this)})});Q(b,{dontEnum:true},{Array:A"
+++"rray,Boolean:Boolean,Date:Date,Function:Function,Math:a.createWrapper(\"Math\",void 0),Number:Number,Object:Object,Reg"
+++"Exp:RegExp,String:String,isFinite:c(function isFinite(G){return e(+G)}),isNaN:c(function isNaN(G){return d(+G)}),JSON:"
+++"a.createWrapper(\"JSON\",void 0),eval:a.evalFunction=c(function eval(bT){return a.eval(bT)}),parseFloat:c(function par"
+++"seFloat(a7){return a.parseFloat(P(a7))}),parseInt:c(function parseInt(a7,af){a7=P(a7);var s=r,u=-1,ag=1;while(s[a7[++u"
+++"]]===null);switch(a7[u]){case'-':ag=-1;case'+':++u}if(((af=N(af))===0||af===16)&&(a7[u]==='0'&&a7[u+1]==='x')){u+=2;af"
+++"=16}if(af===0)af=10;else if(af<2||af>36)return g;var G=0,y,aG=a7.length,C;for(y=u;u<aG&&(C=s[a7[u]])!=null&&C<af;++u)G"
+++"=G*af+C;return(y===u?g:G*ag)})});Q(b,{dontEnum:true,dontDelete:true},{NaN:g,Infinity:h,undefined:a.undefined});Q(Math,"
+++"{readOnly:true,dontEnum:true,dontDelete:true},{E:2.718281828459045235360,LN10:2.302585092994045684018,LN2:0.6931471805"
+++"599453094172,LOG10E:0.43429448190325182765113,LOG2E:1.442695040888963407360,PI:3.1415926535897932,SQRT1_2:0.7071067811"
+++"865475244008,SQRT2:1.414213562373095048802});Q(Math,{dontEnum:true},{abs:c(abs=function abs(G){return((G=+G)<0?-G:G)})"
+++",acos:c(function acos(G){return a.acos(+G)}),asin:c(function asin(G){return a.asin(+G)}),atan:c(function atan(G){retur"
+++"n a.atan(+G)}),atan2:c(function atan2(cc,bT){return a.atan2(+cc,+bT)}),ceil:c(function ceil(G){return-f(-G)}),cos:c(fu"
+++"nction cos(G){return a.cos(+G)}),exp:c(function exp(G){return a.exp(+G)}),floor:c(function floor(G){return f(+G)}),log"
+++":c(function log(G){return a.log(+G)}),max:c(function max(bT,cc){var aT=-h,G,ak;for(var u=(ak=arguments).length-1;u>=0;"
+++"--u)if((G=+ak[u])>aT||d(G))aT=G;return aT}),min:c(function min(bT,cc){var aT=h,G,ak;for(var u=(ak=arguments).length-1;"
+++"u>=0;--u)if((G=+ak[u])<aT||d(G))aT=G;return aT}),pow:c(function pow(bT,cc){return a.pow(+bT,+cc)}),random:c(function r"
+++"andom(){return a.random()}),round:c(function round(G){return(G===0.0?G:(G>=-0.5&&G<0.0?-0.0:f(G+0.5)))}),sin:c(functio"
+++"n sin(G){return a.sin(+G)}),sqrt:c(function sqrt(G){return a.sqrt(+G)}),tan:c(function tan(G){return a.tan(+G)})});fun"
+++"ction ek(name,prototype){return function(message){var aG;a.defineProperty(aG=a.createWrapper(\"Error\",name,prototype)"
+++",\"message\",(message!==void 0?P(message):''),false,true,false);return aG}};(function(){var el=[\"Error\",\"EvalError"
+++"\",\"RangeError\",\"ReferenceError\",\"SyntaxError\",\"TypeError\",\"URIError\"];for(var u=el.length;--u>=0;){var C,au"
+++",X;a.defineProperty(b,C=el[u],au=ek(C,X=a.prototypes[C]),false,true,false);au.name=C;Q(au,{dontEnum:true,readOnly:true"
+++",dontDelete:true},{prototype:X});Q(X,{dontEnum:true},{constructor:au});X.name=C}Q(Error.prototype,{dontEnum:true},{mes"
+++"sage:'',toString:c(function toString(){return(this.name===void 0?\"Error\":this.name)+(this.message?(\": \"+this.messa"
+++"ge):'')})});l=SyntaxError;m=RangeError;n=TypeError})();var em={'\\\\':\"\\\\\\\\\",'\"':\"\\\\\\\"\",'\\b':\"\\\\b\",'"
+++"\\f':\"\\\\f\",'\\n':\"\\\\n\",'\\r':\"\\\\r\",'\\t':\"\\\\t\"};var en=61;Q(JSON,{dontEnum:true},{stringify:c(function"
+++" stringify(ae,eo,ep){var eq=[],er=(typeof eo===\"function\"?eo:null),es='',et;if(i(eo,\"class\")===\"Array\"){et={};fo"
+++"r(var u=eo.length;--u>=0;)et[eo[u]]=true}if(typeof ep===\"number\"||(typeof ep===\"object\"&&i(ep,\"class\")===\"Numbe"
+++"r\")){ep=+ep;for(var u=(ep>10?10:ep);--u>=0;)es+=' '}else if(typeof ep===\"string\"||(typeof ep===\"object\"&&i(ep,\"c"
+++"lass\")===\"String\")){es=$sub(P(ep),0,10)}function eu(B){var H='\"',ay=B.length;for(var u=0;u<ay;++u){var aU=B[u],ev;"
+++"H+=((ev=em[aU])?ev:((aU>=' '&&aU<='~')?aU:\"\\\\u\"+a1(ad(k(aU,0),16),4)))}return H+'\"'}function a7(ei,ew,ex){var ae;"
+++"if((ae=ew[ei])&&typeof ae===\"object\"&&typeof ae.toJSON===\"function\")ae=ae.toJSON(ei);if(er)ae=j(er,ew,[ei,ae]);var"
+++" ey=(es?'\\n'+ex:'');if(typeof ae===\"object\"){switch(i(ae,\"class\")){case\"Number\":ae=+ae;break;case\"String\":ae="
+++"P(ae);break;case\"Boolean\":ae=i(ae,\"value\");break}}switch(typeof ae){case\"object\":{if(!ae)return\"null\";var ay,B"
+++"=new x,G;for(var u=(ay=eq.length);--u>=0;){if(eq[u]===ae)throw n(\"Cannot convert circular structure to JSON\")}if(ay>"
+++"en)throw n(\"Structure too deeply nested for JSON conversion\");eq[ay]=ae;if(i(ae,\"class\")===\"Array\"){ay=ae.length"
+++";for(var u=0;u<ay;++u){B.A((u==0?'[':',')+ey+es+(a7(u,ae,ex+es)||\"null\"))}B.A(ay==0?\"[]\":ey+']')}else{var ez=false"
+++";for(var bB in(et?et:ae)){if(a.hasOwnProperty(ae,bB)){if(G=a7(bB,ae,ex+es)){B.A((ez?',':'{')+ey+es+eu(bB)+(es?\": \":'"
+++":')+G);ez=true}}}B.A(ez?ey+'}':\"{}\")}--eq.length;return B.D()}case\"string\":return eu(ae);case\"number\":return(e(a"
+++"e)?P(ae):\"null\");case\"boolean\":return P(ae)}}return a7('',{'':ae},'')}),parse:c(function parse(eA,eB){var eC=0;fun"
+++"ction ep(H,X){var aU;while((aU=H[X])===' '||aU==='\\t'||aU==='\\r'||aU==='\\n')++X;return X}function eD(H,X){var aU;if"
+++"(H[X]==='-')++X;if((aU=H[X])==='0')aU=H[++X];else if(aU>='1'&&aU<='9')do{aU=H[++X]}while(aU>='0'&&aU<='9');else return"
+++";if(aU==='.'){if((aU=H[++X])<'0'||aU>'9')return;while((aU=H[++X])>='0'&&aU<='9')}if(aU==='e'||aU==='E'){if((aU=H[++X])"
+++"==='-'||aU==='+')aU=H[++X];if(aU<'0'||aU>'9')return;while((aU=H[++X])>='0'&&aU<='9')}return X}function a7(H,X){var aU;"
+++"if(H[X]!=='\"')return;++X;while((aU=H[X])!=='\"'&&aU>=' '){if(aU==='\\\\'){switch(H[++X]){default:return;case'\"':case"
+++"'/':case'\\\\':case'b':case'f':case'n':case'r':case't':break;case'u':for(var u=4;--u>=0;)if(!(((aU=H[++X])>='0'&&aU<='"
+++"9')||(aU>='a'&&aU<='f')||(aU>='A'&&aU<='F')))return;break}}++X}if(aU==='\"')return++X}function eE(H,X){if($match(H,X,"
+++"\"true\")||$match(H,X,\"null\"))return X+4;else if($match(H,X,\"false\"))return X+5}function R(H,X){if(eC>en)throw n("
+++"\"Structure too deeply nested for JSON conversion\");++eC;try{var aU,eF=false,eG=H[X],eH=(eG==='['?']':'}');X=ep(H,++X"
+++");while((aU=H[X])!==eH&&aU){if(eF){if(aU!==',')return;X=ep(H,++X)}if(eG==='{'){if(!(X=a7(H,X))||H[X=ep(H,X)]!==':')ret"
+++"urn;X=ep(H,++X)}if(!(eI=eJ[H[X]])||!(X=eI(H,X)))return;X=ep(H,X);eF=true}if(aU===eH)return++X}finally{--eC}}var eJ={'{"
+++"':R,'[':R,'\"':a7,'t':eE,'f':eE,'n':eE,'-':eD,'0':eD,'1':eD,'2':eD,'3':eD,'4':eD,'5':eD,'6':eD,'7':eD,'8':eD,'9':eD};e"
+++"A=P(eA);var X,eI;if((eI=eJ[eA[X=ep(eA,0)]])&&(X=eI(eA,X))&&ep(eA,X)===eA.length){var ae=eval('('+eA+')');if(typeof eB="
+++"==\"function\"){function eK(ew,ei){var bB,G,J;if(typeof(J=ew[ei])===\"object\"&&J){for(bB in J){if(a.hasOwnProperty(J,"
+++"bB)){if((G=eK(J,bB))!==void 0)J[bB]=G;else delete J[bB]}}}return j(eB,ew,[ei,J])}ae=eK({\"\":ae},\"\")}return ae}throw"
+++" l(\"Error parsing JSON\")})});Q(Array,{dontEnum:true},{isArray:c(function isArray(J){return i(J,\"class\")===\"Array"
+++"\"})});Q(Object,{dontEnum:true},{defineProperty:c(function defineProperty(J,X,cf){var bB=P(X);var U=!cf.writable,V=!cf"
+++".enumerable,W=!cf.configurable;if(\"get\"in cf||\"set\"in cf){if(\"value\"in cf||\"writable\"in cf)throw TypeError();v"
+++"ar eL=cf.get;var B=cf.set;if(eL!==undefined&&typeof eL!==\"function\")throw TypeError();if(B!==undefined&&typeof B!=="
+++"\"function\")throw TypeError();a.defineProperty(J,bB,undefined,U,V,W,eL,B)}else{a.defineProperty(J,bB,cf.value,U,V,W)}"
+++"}),getPrototypeOf:c(function getPrototypeOf(J){return i(J,\"prototype\")}),keys:c(function keys(J){if(J===undefined||J"
+++"===null)throw TypeError();var eM=Object(J);var eN=[];var bB;for(bB in eM){if(Object.prototype.hasOwnProperty.call(eM,b"
+++"B))eN[eN.length]=bB}return eN})});if(g.toString()!==\"NaN\")throw Error(\"Internal self test failed. Check C++ compile"
+++"r options concerning IEEE 754 compliance.\")})"
++ ;
++ }
++diff --git a/tests/es5/arrayForEach.io b/tests/es5/arrayForEach.io
++new file mode 100644
++index 000000000..194d30765
++--- /dev/null
+++++ b/tests/es5/arrayForEach.io
++@@ -0,0 +1,19 @@
+++> total = 0;
+++> [1, 2, 3].forEach(function(v){ total += v; });
+++> print(total);
+++< 6
+++-
+++> seen = [];
+++> arr = [ , 5 ];
+++> arr.forEach(function(v,i){ seen.push(i); });
+++> print(seen.length);
+++< 1
+++-
+++> print(seen[0]);
+++< 1
+++-
+++> ctx = { sum: 0 };
+++> [1,2].forEach(function(v){ this.sum += v; }, ctx);
+++> print(ctx.sum);
+++< 3
+++-
++diff --git a/tests/es5/arrayIndexOf.io b/tests/es5/arrayIndexOf.io
++new file mode 100644
++index 000000000..261fda9a1
++--- /dev/null
+++++ b/tests/es5/arrayIndexOf.io
++@@ -0,0 +1,23 @@
+++> var a = [1, 2, 3, 2];
+++-
+++> print(a.indexOf(2));
+++< 1
+++-
+++> print(a.indexOf(2, 2));
+++< 3
+++-
+++> print(a.indexOf(4));
+++< -1
+++-
+++> print(a.lastIndexOf(2));
+++< 3
+++-
+++> print(a.lastIndexOf(2, 2));
+++< 1
+++-
+++> print(a.lastIndexOf(2, -3));
+++< 1
+++-
+++> print(a.lastIndexOf(2, -5));
+++< -1
+++-
++diff --git a/tests/es5/arrayMapFilter.io b/tests/es5/arrayMapFilter.io
++new file mode 100644
++index 000000000..47f314308
++--- /dev/null
+++++ b/tests/es5/arrayMapFilter.io
++@@ -0,0 +1,28 @@
+++> res = [1,2,3].map(function(v){ return v*2; });
+++> print(res.join(','));
+++< 2,4,6
+++-
+++> ctx = { add: 1 };
+++> res = [1,2].map(function(v){ return v + this.add; }, ctx);
+++> print(res[1]);
+++< 3
+++-
+++> src = [ , 5 ];
+++> res = src.map(function(v){ return v; });
+++> print(0 in res);
+++< false
+++-
+++> filtered = [1,2,3,4].filter(function(v){ return v % 2 === 0; });
+++> print(filtered.join(','));
+++< 2,4
+++-
+++> ctx = { max:2 };
+++> filtered = [1,2,3].filter(function(v){ return v > this.max; }, ctx);
+++> print(filtered[0]);
+++< 3
+++-
+++> src = [ ,1,2 ];
+++> filtered = src.filter(function(v){ return true; });
+++> print(filtered.length);
+++< 2
+++-
++diff --git a/tests/es5/arrayReduce.io b/tests/es5/arrayReduce.io
++new file mode 100644
++index 000000000..8af505de1
++--- /dev/null
+++++ b/tests/es5/arrayReduce.io
++@@ -0,0 +1,23 @@
+++> print([1,2,3].reduce(function(a,b){ return a + b; }));
+++< 6
+++-
+++> print([1,2,3].reduce(function(a,b){ return a + b; }, 1));
+++< 7
+++-
+++> print([1,2,3].reduceRight(function(a,b){ return a - b; }));
+++< 0
+++-
+++> print([1,2,3].reduceRight(function(a,b){ return a - b; }, 10));
+++< 4
+++-
+++> calls = 0; arr = [ , 1 ];
+++> arr.reduce(function(acc, v){ calls++; return acc; }, 0);
+++> print(calls);
+++< 1
+++-
+++> try { [].reduce(function(){}); } catch(e){ print(e instanceof TypeError); }
+++< true
+++-
+++> try { [].reduceRight(function(){}); } catch(e){ print(e instanceof TypeError); }
+++< true
+++-
++diff --git a/tests/es5/arraySomeEvery.io b/tests/es5/arraySomeEvery.io
++new file mode 100644
++index 000000000..17f58c1f3
++--- /dev/null
+++++ b/tests/es5/arraySomeEvery.io
++@@ -0,0 +1,21 @@
+++> print([1,2,3].some(function(v){ return v > 2; }));
+++< true
+++-
+++> print([1,2,3].some(function(v){ return v > 5; }));
+++< false
+++-
+++> print([1,2,3].every(function(v){ return v < 4; }));
+++< true
+++-
+++> print([1,2,3].every(function(v){ return v < 3; }));
+++< false
+++-
+++> ctx = { t:2 };
+++> print([1,2,3].some(function(v){ return v > this.t; }, ctx));
+++< true
+++-
+++> calls = 0; arr = [ , 1 ];
+++> arr.every(function(v,i){ calls++; return true; });
+++> print(calls);
+++< 1
+++-
++diff --git a/tests/es5/dateNow.io b/tests/es5/dateNow.io
++new file mode 100644
++index 000000000..9251ce153
++--- /dev/null
+++++ b/tests/es5/dateNow.io
++@@ -0,0 +1,8 @@
+++> print(typeof Date.now);
+++< function
+++-
+++> delta = Math.abs(Date.now() - new Date().getTime());
+++-
+++> print(delta < 10);
+++< true
+++-
++diff --git a/tests/es5/getterSetterProperties.io b/tests/es5/getterSetterProperties.io
++new file mode 100644
++index 000000000..2aed455c3
++--- /dev/null
+++++ b/tests/es5/getterSetterProperties.io
++@@ -0,0 +1,26 @@
+++> obj = { _v: 1, get value() { return this._v; }, set value(v) { this._v = v; }, get double() { return this._v * 2; }, set double(v) { this._v = v / 2; } };
+++-
+++> print(obj.value);
+++< 1
+++-
+++> print(obj.double);
+++< 2
+++-
+++> obj.double = 50;
+++-
+++> print(obj.value);
+++< 25
+++-
+++> obj.value = 15;
+++-
+++> print(obj.double);
+++< 30
+++-
+++> print(obj._v);
+++< 15
+++-
+++> only = { _v: 0, get value() { return this._v; } };
+++> only.value = 5;
+++> print(only.value);
+++< 0
+++-
++diff --git a/tests/es5/objectKeys.io b/tests/es5/objectKeys.io
++new file mode 100644
++index 000000000..bdc0a7f68
++--- /dev/null
+++++ b/tests/es5/objectKeys.io
++@@ -0,0 +1,22 @@
+++> print(Object.keys({a:1,b:2}).sort().join(','));
+++< a,b
+++-
+++> function F(){}
+++> F.prototype.a = 1;
+++> var o = new F();
+++> o.b = 2;
+++> print(Object.keys(o).join(','));
+++< b
+++-
+++> var obj = {};
+++> Object.defineProperty(obj, 'x', { value:1, enumerable:false });
+++> obj.y = 2;
+++> print(Object.keys(obj).join(','));
+++< y
+++-
+++> print(Object.keys('hi').length);
+++< 2
+++-
+++> try { Object.keys(null); } catch(e){ print(e instanceof TypeError); }
+++< true
+++-
++diff --git a/tests/es5/strictArgumentsObject.io b/tests/es5/strictArgumentsObject.io
++new file mode 100644
++index 000000000..da3fb355d
++--- /dev/null
+++++ b/tests/es5/strictArgumentsObject.io
++@@ -0,0 +1,8 @@
+++> function f(a){ "use strict"; arguments[0] = 2; return a === 1 && arguments[0] === 2; }
+++> print(f(1))
+++< true
+++-
+++> function g(a){ "use strict"; a = 3; return arguments[0] === 1; }
+++> print(g(1))
+++< true
+++-
++diff --git a/tests/es5/strictDeleteIdentifier.io b/tests/es5/strictDeleteIdentifier.io
++new file mode 100644
++index 000000000..8d859e9d6
++--- /dev/null
+++++ b/tests/es5/strictDeleteIdentifier.io
++@@ -0,0 +1,7 @@
+++> eval("\"use strict\"; var x = 1; delete x;")
+++! !!!! SyntaxError: Deleting identifier in strict code
+++-
+++> function f(){ "use strict"; var y; delete y; }
+++! !!!! Line: 1
+++! !!!! SyntaxError: Deleting identifier in strict code
+++-
++diff --git a/tests/es5/strictDuplicateParam.io b/tests/es5/strictDuplicateParam.io
++new file mode 100644
++index 000000000..60ae8255e
++--- /dev/null
+++++ b/tests/es5/strictDuplicateParam.io
++@@ -0,0 +1,11 @@
+++> function f(a, a){ "use strict"; }
+++! !!!! Line: 1
+++! !!!! SyntaxError: Duplicate parameter name not allowed in strict code
+++-
+++> function g(a, a){ return a; }
+++> print(g(1))
+++< undefined
+++-
+++> eval("\"use strict\"; function h(a, a){ return a; }")
+++! !!!! SyntaxError: Duplicate parameter name not allowed in strict code
+++-
++diff --git a/tests/es5/strictEvalArgsBinding.io b/tests/es5/strictEvalArgsBinding.io
++new file mode 100644
++index 000000000..72f759752
++--- /dev/null
+++++ b/tests/es5/strictEvalArgsBinding.io
++@@ -0,0 +1,6 @@
+++> eval("\"use strict\"; var eval = 0;")
+++! !!!! SyntaxError: Illegal use of eval or arguments in strict code
+++-
+++> eval("\"use strict\"; function arguments(){}");
+++! !!!! SyntaxError: Illegal use of eval or arguments in strict code
+++-
++diff --git a/tests/es5/strictEvalScope.io b/tests/es5/strictEvalScope.io
++new file mode 100644
++index 000000000..71ea5d58e
++--- /dev/null
+++++ b/tests/es5/strictEvalScope.io
++@@ -0,0 +1,4 @@
+++> function f(){ "use strict"; eval("1"); }
+++! !!!! Line: 1
+++! !!!! SyntaxError: Illegal use of eval or arguments in strict code
+++-
++diff --git a/tests/es5/strictImplicitGlobal.io b/tests/es5/strictImplicitGlobal.io
++new file mode 100644
++index 000000000..39614742d
++--- /dev/null
+++++ b/tests/es5/strictImplicitGlobal.io
++@@ -0,0 +1,7 @@
+++> eval("\"use strict\"; implicit = 1;")
+++! !!!! ReferenceError: implicit is not defined
+++-
+++> f=function(){ "use strict"; implicit2 = 1; }
+++> f()
+++! !!!! ReferenceError: implicit2 is not defined
+++-
++diff --git a/tests/es5/strictThisBinding.io b/tests/es5/strictThisBinding.io
++new file mode 100644
++index 000000000..117112865
++--- /dev/null
+++++ b/tests/es5/strictThisBinding.io
++@@ -0,0 +1,8 @@
+++> f=function(){ "use strict"; return this===undefined; }
+++> print(f())
+++< true
+++-
+++> g=function(){ return this===undefined; }
+++> print(g())
+++< false
+++-
++diff --git a/tests/es5/strictWithStatement.io b/tests/es5/strictWithStatement.io
++new file mode 100644
++index 000000000..362f7bcca
++--- /dev/null
+++++ b/tests/es5/strictWithStatement.io
++@@ -0,0 +1,7 @@
+++> eval("\"use strict\"; with({}){}")
+++! !!!! SyntaxError: "with" is not allowed in strict code
+++-
+++> function f(){ "use strict"; with({}){} }
+++! !!!! Line: 1
+++! !!!! SyntaxError: "with" is not allowed in strict code
+++-
++diff --git a/tests/es5/stringTrim.io b/tests/es5/stringTrim.io
++new file mode 100644
++index 000000000..9ea2d974a
++--- /dev/null
+++++ b/tests/es5/stringTrim.io
++@@ -0,0 +1,6 @@
+++> print(" \tfoo \n".trim())
+++< foo
+++-
+++> print("\u00A0bar\u00A0".trim())
+++< bar
+++-
++diff --git a/tests/es5/stringTrimLeftRight.io b/tests/es5/stringTrimLeftRight.io
++new file mode 100644
++index 000000000..16d13ba3e
++--- /dev/null
+++++ b/tests/es5/stringTrimLeftRight.io
++@@ -0,0 +1,14 @@
+++> var s = " \tfoo \n";
+++-
+++> print(s.trimLeft().charCodeAt(0));
+++< 102
+++-
+++> print(s.trimLeft().charCodeAt(s.trimLeft().length - 1));
+++< 10
+++-
+++> print(s.trimRight().charCodeAt(0));
+++< 32
+++-
+++> print(s.trimRight().charCodeAt(s.trimRight().length - 1));
+++< 111
+++-
+diff --git a/tools/stdlibMinifier.ppeg b/tools/stdlibMinifier.ppeg
+index 122dd41..c96b519 100644
+--- a/tools/stdlibMinifier.ppeg
++++ b/tools/stdlibMinifier.ppeg
+@@ -1,39 +1,46 @@
+ {
+-    $$parser.nextName = '9';
+     $$parser.symbolChars = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
+     $$parser.createNextName => {
++        defaults(@[$$parser.state].nextName, '9');
+         for (; {
+-            for ($nn = $$parser.nextName; {
++            for ($nn = [$$parser.state].nextName; {
+                     $nn !== '' && {
+                         $nc = $$parser.symbolChars{find($$parser.symbolChars, right($nn, 1)) + 1};
+                         $nc === ''
+                     }
+                 }; $nn = chop($nn, 1));
+             if ($nn === '') {
+-                $nn = 'a' # repeat('0', length($$parser.nextName));
++                $nn = 'a' # repeat('0', length([$$parser.state].nextName));
+             } else {
+                 $nn = chop($nn, 1) # $nc;
+-                $nn #= repeat('0', length($$parser.nextName) - length($nn));
++                $nn #= repeat('0', length([$$parser.state].nextName) - length($nn));
+             };
+-            $$parser.nextName = $nn;
+-            exists(@$$parser.preserved[$nn])
++            [$$parser.state].nextName = $nn;
++            exists(@[$$parser.state].preserved[$nn])
+         }; );
+-        ( $$parser.nextName )
++        ( [$$parser.state].nextName )
+     };
+ 
+     $$parser.rename => {
+         args(@$s);
+-        if (!exists(@$$parser.preserved[$s])) {
+-            if (!exists(@$$parser.renames[$s])) {
+-                $$parser.renames[$s] = $$parser.createNextName();
++        if (!exists(@[$$parser.state].preserved[$s])) {
++            if (!exists(@[$$parser.state].renames[$s])) {
++                [$$parser.state].renames[$s] = $$parser.createNextName();
+             };
+-            $s = $$parser.renames[$s];
++            $s = [$$parser.state].renames[$s];
+         };
+         ( $s )
+     };
++
++    $$parser.preserve => {
++        args(@$s);
++        if (exists($r = @[$$parser.state].preserved[$s])) throw('already preserved: ' # $s);
++        if (exists(@[$$parser.state].renames[$s])) throw('preserved word: ' # $s # ' used before preservation');
++        [$r] = true;
++    }
+ }
+ 
+-root            <-                                          { $$ = '' }
++root            <-                                          { $$parser.state = @$$; $$ = '' }
+                     (ws
+ # can't differentiate regexp literal / from two divisions y / x / z without more advanced parsing, so lets not use regexp literals in stdlib
+ #                   / c=(qString / aString / regexp)        { $$ #= $c }
+@@ -43,7 +50,7 @@ root            <-                                          { $$ = '' }
+                         )*
+                     / ';' ws '}'                            { $$ #= '}'}
+                     / c=.                                   { $$ #= $c }
+-                    )* eof
++                    )* eof                                  { [$$parser.state].output = $$ }
+ 
+ token           <-  n=number                                { $$ = $n }
+                     / i=identifier                          { $$ = $$parser.rename($i) }
+@@ -57,7 +64,7 @@ comment         <-  '/*' (preserveList / !'*/' .)* '*/' / "//" (preserveList / !
+ 
+ preserveList    <-  '@preserve:' [ \t]* preserveId ([ \t]* ',' [ \t]* preserveId)*
+ 
+-preserveId      <-  i=identifier                            { $$parser.preserved[$i] = true }
++preserveId      <-  i=identifier                            { $$parser.preserve($i); }
+ 
+ identifier      <-  [$a-zA-Z_0-9]+
+ 
+diff --git a/tools/stdlibToCpp.pika b/tools/stdlibToCpp.pika
+index 7cba475..a2698af 100755
+--- a/tools/stdlibToCpp.pika
++++ b/tools/stdlibToCpp.pika
+@@ -1,7 +1,10 @@
+ #! /usr/local/bin/PikaCmd
+ 
+ include('stdlib.pika');
+-run('./initPPEG.pika');
++include('debug.pika');
++include('systools.pika');
++// Use run.root from systools so paths resolve relative to this script regardless of CWD.
++run(run.root # 'initPPEG.pika');
+ 
+ vargs(@exe,, @inputFile, @outputFile);
+ defaults(@inputFile, 'stdlib.js', @outputFile, 'stdlibJS.cpp');
+@@ -9,30 +12,54 @@ defaults(@inputFile, 'stdlib.js', @outputFile, 'stdlibJS.cpp');
+ print(bake('Loading {inputFile}'));
+ src = load(inputFile);
+ 
++// Probe optional ES5 source next to the base stdlib (no-op unless present).
++baseDir = dirOfPath(inputFile);
++es5path = baseDir # 'stdlibES5.js';
++hasES5 = (try(>es5src = load(es5path)) == void);
++
+ print('Compiling parser');
+ 
+-ok = ppeg.compileFunction(load('./stdlibMinifier.ppeg'), @minifier);
++ok = ppeg.compileFunction(load(run.root # 'stdlibMinifier.ppeg'), @minifier);
+ if (!ok) throw("Error compiling the stdlib parser peg");
+ 
+ print('Shrinking code');
+ 
+-ok = minifier(src, @minified, @i);
++ok = minifier(src, @state, @i);
+ if (!ok) throw("Failed parsing at offset " # i);
++minifiedBase = state.output;
++print(bake('Code shrunk from {length(src)} to {length(minifiedBase)}'));
+ 
+-print(bake('Code shrunk from {length(src)} to {length(minified)}'));
+-
+-code = '';
+-for (offset = 0; offset < length(minified); offset += n) {
+-	for (n = min(length(minified) - offset, 118)
+-			; { line = '"' # (escape("\n" # minified{offset:n}){3:}); length(line) > 120 }
++codeBase = '';
++for (offset = 0; offset < length(minifiedBase); offset += n) {
++	for (n = min(length(minifiedBase) - offset, 118)
++			; { line = '"' # (escape("\n" # minifiedBase{offset:n}){3:}); length(line) > 120 }
+ 			; --n);
+-	code #= line # LF;
++	codeBase #= line # LF;
++};
++
++if (hasES5) {
++	ok = minifier(es5src, @state, @i2);
++	if (!ok) throw("Failed parsing ES5 at offset " # i2);
++	minifiedES5 = state.output;
++	print(bake('ES5 shrunk from {length(es5src)} to {length(minifiedES5)}'));
++
++	codeES5 = '';
++	for (o2 = 0; o2 < length(minifiedES5); o2 += n2) {
++		for (n2 = min(length(minifiedES5) - o2, 118)
++				; { w = '"' # (escape("\n" # minifiedES5{o2:n2}){3:}); length(w) > 120 }
++				; --n2);
++		codeES5 #= w # LF;
++	};
+ };
+ 
+ save(outputFile, bake(
+ 'namespace NuXJS {
+ const char* STDLIB_JS =
+---{code}--;
++--{codeBase}--;
++#if (!defined(NUXJS_ES5) || NUXJS_ES5)
++const char* STDLIB_ES5_JS =
++--{codeES5}--;
++#endif
+ }
+ ', '--{', '}--'));
+ 
diff --git a/README.md b/README.md
index c530f19..e6709b6 100644
--- a/README.md
+++ b/README.md
@@ -108,6 +108,29 @@ Notes:
 
 - The dashboard auto-extracts `externals/test262-master.tar.gz` if `externals/test262-master/` is missing.
 
+## ES3 vs ES5.1 Builds
+
+This branch layers an ES5.1 feature set on top of the stable ES3 core. ES5.1 is controlled by the `NUXJS_ES5` compile‑time switch and is enabled by default.
+
+- Default (ES5.1): run `./build.sh` (or `build.cmd`). All tests, including ES5.1, are executed.
+- ES3-only variant: set `NUXJS_ES5=0` via `CPP_OPTIONS` to disable ES5.1 features and tests.
+  - macOS/Linux: `CPP_OPTIONS='-DNUXJS_ES5=0' ./build.sh`
+  - Windows (PowerShell): `$env:CPP_OPTIONS='/DNUXJS_ES5=0'; ./build.cmd`
+  - Windows (cmd): `SET CPP_OPTIONS=/DNUXJS_ES5=0 && build.cmd`
+
+### Test Both Variants (ES3 and ES5.1)
+
+- Two‑pass mode: set `NUXJS_TEST_ES5_VARIANTS=1` to build and run the full suite twice (first with ES3, then with ES5.1):
+  - `NUXJS_TEST_ES5_VARIANTS=1 ./build.sh`
+- Faster inner loop: when using two‑pass mode during development, skip the release target:
+  - macOS/Linux: `NUXJS_SKIP_RELEASE=1 NUXJS_TEST_ES5_VARIANTS=1 ./tools/buildAndTest.sh beta`
+  - Windows (cmd): `SET NUXJS_SKIP_RELEASE=1 & SET NUXJS_TEST_ES5_VARIANTS=1 & tools\buildAndTest.cmd beta`
+
+Notes:
+
+- In single‑pass builds, ES5 tests run by default. To skip them, compile with `-DNUXJS_ES5=0`.
+- See `docs/ES5.1 Roadmap.md` for current coverage, open items, and semantic notes (e.g. `Function.prototype.bind`, strict mode, accessors, and `Object.create`/`Object.defineProperties`).
+
 ## Example
 
 Here’s a minimal example of embedding NuXJS using the high-level API:
@@ -170,14 +193,20 @@ Each section of every test file is written as a separate entry in the specified
 ## Documentation
 
 - [NuXJS Documentation](docs/NuXJS%20Documentation.md)
+- [Standard Library Guidelines](docs/Standard%20Library%20Guidelines.md)
 - [ECMAScript Compatibility Notes](docs/notes/ECMAScript%20Compatibility%20Notes.md)
 - [TypeScript Compatibility](docs/notes/TypeScript%20Compatibility.md)
+- [ES5.1 Implementation Roadmap](docs/ES5.1%20Roadmap.md)
 
 ## AI Usage
 
 AI tools (such as OpenAI Codex) have occasionally been used to assist with documentation, code comments, test
 generation, and repetitive edits. All core source code has been written and refined by hand over many years.
 
+This ES5.1 branch is an experiment informed by AI-assisted development (tests, porting helpers, and doc
+scaffolding), layered on top of the long‑standing ES3 core. All non-trivial changes are code‑reviewed and
+validated by the test suite.
+
 ## License
 
 This project is released under the [BSD 2-Clause License](LICENSE).
diff --git a/TODO_NuXJS_ES5.md b/TODO_NuXJS_ES5.md
new file mode 100644
index 0000000..1fa4740
--- /dev/null
+++ b/TODO_NuXJS_ES5.md
@@ -0,0 +1,49 @@
+- [x] const String EMPTY_STRING, LENGTH_STRING("length"), NULL_STRING("null"), UNDEFIN
+- [x] const String* Object::getClassName() const { return &O_BJECT_STRING; }
+- [x] Flags Object::getProperty(Runtime& rt, const Value& key, Value* v) const {
+- [x] o = o->getPrototype(rt);
+- [x] return false;
+- [x] bool JSObject::setOwnProperty(Runtime& rt, const Value& key, const Value& v, Fla
+- [x] bool JSObject::setOwnProperty(Runtime& rt, const String* key, const Value& v, Fl
+- [x] bool Function::hasInstance(Runtime& rt, Object* object) const {
+- [x] bool JSArray::setElement(Runtime& rt, UInt32 index, const Value& v) {
+- [x] template<class SUPER> bool LazyJSObject<SUPER>::setOwnProperty(Runtime& rt, cons
+- [x] void Error::updateReflection(Runtime& rt) {
+- [x] Flags Arguments::getOwnProperty(Runtime& rt, const Value& key, Value* v) const {
+- [x] static struct EvalFunction : public Function {
+- [x] const Processor::OpcodeInfo Processor::opcodeInfo[Processor::OP_COUNT] = {
+- [x] void Processor::newOperation(const Int32 argc) {
+- [x] const Object* o = convertToObject(sp[-1], false);
+- [x] pop(1);
+- [x] if (o == 0) {
+- [x] case THIS_OP: push(thisObject != 0 ? Value(thisObject) : UNDEFINED_VALUE); break
+- [x] case THIS_OP: push(thisObject != 0 ? Value(thisObject) : UNDEFINED_VALUE); break
+- [x] Compiler::ExpressionResult Compiler::objectInitialiser() { // FIX : share stuff
+- [x] Compiler::ExpressionResult Compiler::objectInitialiser() { // FIX : share stuff
+- [x] void SeparateConstructorFunction::constructCompleteObject(Runtime& rt) const {
+- [x] struct Support {
+- [x] struct Support {
+- [x] static struct {
+- [x] Var Runtime::eval(const String& expression) {
+- [x] Code* Runtime::compileEvalCode(const String* expression, bool strict) {
+- [x] static Value distinctConstructor(Runtime& rt, Processor&, UInt32 argc, const Value* argv, Object*) {
+- [x] const Flags READ_ONLY_FLAG = 2;
+- [ ] class Table {
+- [ ] class Object : public GCItem {
+- [ ] class JSObject : public Object, public Table {
+- [ ] template<class SUPER> class LazyJSObject : public SUPER {
+- [ ] class JSArray : public LazyJSObject<Object> {
+- [ ] class Code : public Object {
+- [ ] class Code : public Object {
+- [ ] class Function : public Object {
+- [ ] class Function : public Object {
+- [ ] class Accessor : public Object {
+- [ ] class Error : public LazyJSObject<Object> {
+- [x] class Arguments : public LazyJSObject<Object> {
+- [ ] class Runtime : public GCItem {
+- [ ] class Property : public AccessorBase {
+- [ ] class Property : public AccessorBase {
+- [ ] class Property : public AccessorBase {
+ - [x] class Processor : public GCItem {
+ - [ ] class Processor : public GCItem {
+ - [x] tools/NuXJSTest.cpp: testJSON()
diff --git a/docs/ES5-conditionalization-plan.md b/docs/ES5-conditionalization-plan.md
new file mode 100644
index 0000000..93dce29
--- /dev/null
+++ b/docs/ES5-conditionalization-plan.md
@@ -0,0 +1,17 @@
+# ES5 conditionalization plan
+
+The following tasks track ES5-specific changes that need wrapping in `#if (NUXJS_ES5)` blocks so that the code matches upstream `main` when the flag is disabled.
+
+- [x] Global constants `GET_STRING` and `SET_STRING` in `NuXJS.cpp`.
+- [x] Object-literal accessor parsing in `Compiler::objectInitialiser`.
+- [x] `Support::defineProperty` accessor branch guarded by `NUXJS_ES5`.
+- [x] `Object` overloads using `const String*` and `Processor&` plus accessor logic inside `getProperty`/`setProperty`.
+- [x] Additional `setOwnProperty` overloads for `JSObject`, `JSArray`, `LazyJSObject`, `Error`, and `Arguments`.
+- [x] Accessor infrastructure: `ACCESSOR_FLAG` enum value, `Accessor` class definition, and related property-handling code.
+- [x] Strict-mode infrastructure: `Code::strict` field with `isStrict`/`setStrict` methods and propagation through `Runtime::compileEvalCode`, `Processor::enterEvalCode`, and `Processor::isCurrentStrict`.
+- [x] Strict-mode parser restrictions for `eval`/`arguments`, `with`, `delete`, and duplicate parameters.
+ - [x] New opcodes `ADD_GETTER_OP` and `ADD_SETTER_OP` plus extended `OpcodeInfo` flags.
+ - [x] Accessor-aware `Property` helpers (assignment operator and `get()` implementation).
+ - [x] Changes to `Arguments` and `FunctionScope` for strict-mode argument object detachment.
+ - [x] Evaluate remaining diffs to ensure no unguarded ES5 behavior remains.
+ - [x] Build scripts perform ES3 and ES5 double build and test when `NUXJS_TEST_ES5_VARIANTS=1`.
diff --git a/docs/ES5.1 Roadmap.md b/docs/ES5.1 Roadmap.md
new file mode 100644
index 0000000..de4a763
--- /dev/null
+++ b/docs/ES5.1 Roadmap.md	
@@ -0,0 +1,120 @@
+# ES5.1 Implementation Roadmap
+
+## Overview
+NuXJS today is a portable C++03 engine that fully implements ECMAScript 3 with a few ES5 conveniences such as JSON support and indexed string access. Custom property getters and setters are not yet available and `Object.defineProperty` only handles data properties. Built‑in library objects are written directly in JavaScript and omit modern helpers like `Object.assign` or `Array.prototype.map`. The repository already contains a broad test suite, including `tests/from262` for conformance.
+
+All ES5.1 work should be driven by regression tests. Whenever a roadmap item lands, reference its verifying `.io` file in this document.
+ES5‑specific regression tests live in `tests/es5`.
+
+## Current Status
+
+- Build toggle: ES5.1 features are guarded by the `NUXJS_ES5` macro. Default is ES5.1 (`NUXJS_ES5=1`). Use
+  `CPP_OPTIONS='-DNUXJS_ES5=0' ./build.sh` for an ES3-only build. The README documents both modes and a
+  two‑pass variant with `NUXJS_TEST_ES5_VARIANTS=1`.
+ - Test suite (with ES5.1 enabled): all ES5.1 tests pass (`tests/es5/functionBind.io`).
+
+## Roadmap to ES5.1
+
+### Object model & descriptors
+	- Extend the internal property representation to track attributes (`[[Writable]]`, `[[Enumerable]]`, `[[Configurable]]`) and accessor pairs.
+       - `src/NuXJS.h` defines `Object::Table::Bucket`; expand the union to hold either a `Value` or a `{ get, set }` pair and add an `ACCESSOR_FLAG` bit.
+       - Update `Object::getProperty` and `Object::setProperty` in `src/NuXJS.cpp` so that accessor buckets surface the getter or setter function while respecting attribute bits during writes and deletes.
+               - `GET_PROPERTY_OP` in `Processor` already delegates to `Object::getProperty`; when an `ACCESSOR_FLAG` bucket is found, the getter function replaces the original value and the processor invokes it via its standard `invokeFunction` path with the object as `this`, leaving the call result on the stack.
+               - `SET_PROPERTY_OP` similarly uses `Object::setProperty`; when an accessor exists, the processor calls the setter through `invokeFunction` with the provided value and keeps the caller's value as the final result.
+- Implement full `Object.defineProperty`, `Object.defineProperties`, `Object.getOwnPropertyDescriptor`, and `Object.create` in both the C++ core and `src/stdlib.js`.
+    - `Object.defineProperty` supports data and accessor descriptors in `src/stdlib.js`.
+    - `Object.defineProperties` implemented in `src/stdlib.js` (tests/es5/objectCreateDefineProperties.io).
+    - `Object.create` (non-null prototype) implemented in `src/stdlib.js` (tests/es5/objectCreateDefineProperties.io).
+- Replace the legacy `support.defineProperty(o, name, value, readOnly, dontEnum, dontDelete)` with a `PropertyDescriptor` structure that can carry `value`, `get`, `set`, and attribute flags.
+- The runtime helper in `src/NuXJS.cpp` should validate descriptor combinations and install either a data or accessor property in the object's hash table.
+- Expose enumeration helpers like `Object.keys` and `Object.getOwnPropertyNames`.
+        - `Object.keys` implemented in `src/stdlib.js` (`tests/es5/objectKeys.io`).
+        - `Object.getOwnPropertyNames` pending; requires a runtime iterator that can expose non-enumerable properties.
+        - Add support for accessor syntax (`get`/`set` in object literals) and function prototype attributes.
+- Ensure `Object.defineProperty`, `Object.defineProperties`, `Object.create`, and `Object.keys` are not constructable. *(Implemented; `tests/stdlib/checkAllPrototypes.io`)*
+- Extend the parser to recognize `get name(){}` and `set name(v){}` tokens and emit descriptor objects for property creation.
+- Bootstrapping of built‑ins in `src/stdlib.js` can then define getters on prototypes, e.g. for `Function.prototype.name`.
+
+### Strict mode
+- Detect strict directives and propagate mode.
+    - Add a `bool strict` member to `Code` in `src/NuXJS.h`. *(Implemented; `tests/es5/strictThisBinding.io`)*
+   - In `Compiler::compile` and `compileFunction` (`src/NuXJS.cpp`), scan the directive prologue by walking the leading string literals before any other token. A literal whose contents are exactly `use strict` (10 characters, case‑sensitive) toggles `code->strict`. *(Implemented; `tests/es5/strictThisBinding.io`)*
+- Enforce identifier restrictions and parameter checks.
+   - Update `Compiler::identifier` so `eval` and `arguments` trigger a syntax error when the current scope is strict. *(Implemented; `tests/es5/strictEvalArgsBinding.io`)*
+   - During parameter list parsing, reject duplicate names in strict functions. *(Implemented; `tests/es5/strictDuplicateParam.io`)*
+- Preserve `undefined` for unbound `this` values.
+    - Modify `Processor::enter` to skip substituting the global object when `code->strict` is set. *(Implemented; `tests/es5/strictThisBinding.io`)*
+- Reject `with` statements in strict code.
+    - Have `Compiler::withStatement` test the active scope’s `strict` flag and emit a syntax error if encountered. *(Implemented; `tests/es5/strictWithStatement.io`)*
+- Propagate strict mode through `eval` and isolate its environment. *(Implemented; `tests/es5/strictEvalScope.io`)*
+    - Pass the caller’s strict flag to `CALL_EVAL_OP` and down to `Runtime::compileEvalCode` and `Processor::enterEvalCode`. *(Implemented; `tests/es5/strictEvalScope.io`)*
+    - When strict, compile eval code with a fresh variable environment. *(Implemented; `tests/es5/strictEvalScope.io`)*
+- Tighten `delete` semantics.
+    - If `delete` targets a simple identifier in strict mode, emit a syntax error instead of `DELETE_NAMED_OP`. *(Implemented; `tests/es5/strictDeleteIdentifier.io`)*
+- Disallow implicit global variable creation.
+   - When strict code assigns to an undeclared identifier, raise a `ReferenceError` rather than defining a global property. *(Implemented; `tests/es5/strictImplicitGlobal.io`)*
+- Implement strict arguments-object behavior. *(Implemented; `tests/es5/strictArgumentsObject.io`)*
+    - Introduce a non-mapped `ArgumentsObject` variant and construct it in `FunctionScope` when `code->strict`. *(Implemented; `tests/es5/strictArgumentsObject.io`)*
+    - Ensure `arguments` does not alias parameters. *(Implemented; `tests/es5/strictArgumentsObject.io`)*
+
+### Arguments object & function semantics
+- Implement ES5.1 arguments-object behavior (decoupled mapping, `Object.getOwnPropertyDescriptor` support).
+	- Introduce an `ArgumentsObject` class that can either map indices to parameters or, in strict mode, hold a copy without parameter aliases.
+	- `Object.getOwnPropertyDescriptor` on arguments must expose `length`, `callee`, and indexed properties with correct attributes.
+ - Provide `Function.prototype.bind` and ensure correct `.name`, `.length`, and `toString` outputs.
+    - Implemented via runtime `support.bind` helper producing `BoundFunction` with correct constructor behavior and partial application semantics (`tests/es5/functionBind.io`).
+     - Optional: consider `bound` function `.name` as `"bound " + target.name` (not required by ES5.1 but common).
+
+### Spec compliance fixes
+- Align ES5 semantics that differ from the current engine implementation.
+	- Permit `for...in` on `null` or `undefined` to yield an empty iteration instead of throwing.  *(see `docs/notes/ECMAScript Compatibility Notes.md`)*
+	- Make user-defined functions' `prototype` properties non-enumerable and adjust `name`/`length` attributes to match ES5.1.
+	- Update `Object.prototype.toString` so `arguments` objects report `[object Arguments]` and enumerate indexed slots during `for...in`.
+	- Add regression tests for each behaviour in `tests/es5`.
+
+### Array & string methods
+- Add ES5.1 array iteration utilities: `forEach`, `map`, `filter`, `some`, `every`, `reduce`, `reduceRight`, `indexOf`, `lastIndexOf`.
+- These are pure library additions to `src/stdlib.js`; each helper must follow the spec's callback invocation pattern and handle sparse arrays via `Object` property checks rather than simple loops.
+- `Array.prototype.indexOf` and `Array.prototype.lastIndexOf` implemented (`tests/es5/arrayIndexOf.io`).
+- `Array.prototype.forEach` implemented (`tests/es5/arrayForEach.io`).
+- `Array.prototype.map` and `Array.prototype.filter` implemented (`tests/es5/arrayMapFilter.io`).
+- `Array.prototype.some` and `Array.prototype.every` implemented (`tests/es5/arraySomeEvery.io`).
+- `Array.prototype.reduce` and `Array.prototype.reduceRight` implemented (`tests/es5/arrayReduce.io`).
+- Implement string utilities like `trim`, `trimLeft`, `trimRight`, and JSON-related `toJSON` helpers.
+- Extend the string section in `src/stdlib.js` with whitespace tables identical to the spec and expose `String.prototype.trim*` methods.
+ - `String.prototype.trim` implemented (`tests/es5/stringTrim.io`).
+ - `String.prototype.trimLeft` and `trimRight` implemented (`tests/es5/stringTrimLeftRight.io`).
+- Add `Date.prototype.toJSON` and `Number.prototype.toJSON` wrappers that call the internal `toISOString`/conversion paths.
+
+### Object immutability controls
+- Support `Object.preventExtensions`, `Object.seal`, `Object.freeze`, and related predicates (`isExtensible`, `isSealed`, `isFrozen`).
+	- Add an `extensible` flag to the base `Object` class and teach `setProperty`/`setOwnProperty` to honor it, returning false when extensions are blocked.
+	- Implement helpers in `src/stdlib.js` that iterate over `Object.getOwnPropertyNames` descriptors and toggle `[[Configurable]]`/`[[Writable]]` bits as required by `seal` and `freeze`.
+
+### Date and Number extras
+- Finish remaining ES5.1 Date features such as `toISOString`, `toJSON`, and `now`.
+ - `Date.now` implemented using `support.getCurrentTime` (`tests/es5/dateNow.io`).
+- Add a spec‑compliant `toISOString` implementation in JavaScript.
+- Add Number and Math helpers (`isNaN`, `isFinite` refinements, `parseInt`/`parseFloat` alignment).
+	- Refine `support.isNaN`/`isFinite` semantics and expose `Number.isNaN` and `Number.isFinite` shims.
+	- Ensure `parseInt` and `parseFloat` follow ES5.1 whitespace trimming rules and radix handling; update the `Math` object with any missing constants.
+
+### Parser/VM robustness
+- Update grammar to allow reserved words as property keys and recognize accessor definitions.
+	- Expand the lexical grammar in `src/Parser.cpp` to treat keywords as identifiers in object literals and hook into the new accessor creation path.
+- Revisit bytecode generation for new features and enforce ES5.1 evaluation order.
+	- The compiler in `src/NuXJS.cpp` must emit bytecode for accessors, strict arguments, and `bind` calls while guaranteeing left‑to‑right evaluation as mandated by ES5.1.
+
+### Testing & conformance
+- Expand the existing `tests/from262` set with ES5.1 cases from Test262.
+- Import the ES5.1 section of Test262 and hook them into the `tests/from262` runner so failures can be tracked.
+- Introduce regression tests for each new feature and run the full suite (`timeout 180 ./build.sh`) during development.
+ - Add coverage in `tests/es5` for accessor edge cases, strict‑mode violations, and bound function behavior before shipping any change.
+
+### Documentation & tooling
+- Revise compatibility notes and TypeScript guidance to reflect ES5.1 support.
+- Expand `docs/notes/ECMAScript Compatibility Notes.md` once features land and document any intentional deviations.
+- Update examples and `lib.NuXJS.d.ts` to expose new APIs and maintain TypeScript type safety.
+- Regenerate declaration files so that editors pick up getters/setters and newly added methods.
+- Refresh `docs/NuXJS Documentation.md` once features land.
+- The "Partial ES5 features" table currently lists the arguments object as ES3-mapped and `Object.defineProperty` as data-only; rewrite these notes after the new behavior ships.
diff --git a/docs/Standard Library Guidelines.md b/docs/Standard Library Guidelines.md
index ae897fa..7aa7f12 100644
--- a/docs/Standard Library Guidelines.md	
+++ b/docs/Standard Library Guidelines.md	
@@ -1,23 +1,174 @@
 # Standard Library Guidelines
 
-The standard library lives in `src/stdlib.js`. After editing it, run `./build.sh` to regenerate `src/stdlibJS.cpp` and execute the regression tests.
+The standard library lives in `src/stdlib.js`. After editing it, run `./build.sh` to regenerate `src/stdlibJS.cpp` and execute the regression tests. This document combines the previous authoring guide and the general style rules for the standard library.
 
 ## Formatting and style
+
 - Follow repository formatting rules: tabs for indentation, braces on the same line and a 120-character limit.
 - Add identifiers that must survive minification to the `@preserve` block at the top of `src/stdlib.js`.
 
 ## Engine interaction
+
 - Interact with the engine only through the injected `support` object, using helpers like `defineProperty`, `callWithArgs` and `getInternalProperty`.
 - Use `defineProperties` to apply `readOnly`, `dontEnum` and `dontDelete` attributes consistently.
 
+## Support helper reference
+
+The engine injects a `support` object that provides utilities and constants used by the standard library:
+
+- `prototypes.object`, `prototypes.function`, `prototypes.string`, `prototypes.boolean`,
+  `prototypes.number`, `prototypes.date`, `prototypes.array`, `prototypes.error`,
+  `prototypes.evalError`, `prototypes.rangeError`, `prototypes.referenceError`,
+  `prototypes.syntaxError`, `prototypes.typeError`, `prototypes.uriError` – built-in prototypes.
+- `eval(code)`, `evalFunction` – evaluate source code (`evalFunction` is the direct-mode `eval`).
+- `compileFunction(source, name)` – compile a function from a source string.
+- `createWrapper(className, internalValue, prototype)` – wrap a primitive or host value.
+- `distinctConstructor(callImpl[, constructImpl])` – separate call vs `new` behaviour.
+- `callWithArgs(func[, thisArg[, args[, offset]]])` – invoke using an argument array.
+- `defineProperty(o, name, value, readOnly, dontEnum, dontDelete)` – define a data property.
+- `getInternalProperty(o, "class"|"value"|"prototype")` – inspect internal slots.
+- `hasOwnProperty(o, name)`, `isPropertyEnumerable(o, name)` – property queries.
+- `toPrimitiveNumber(o)`, `toPrimitiveString(o)`, `toPrimitive(o)` – convert objects to primitives.
+- `charCodeAt(s, i)`, `fromCharCode(code)`, `substring(s, from, to)`,
+  `submatch(text, offset, match)` – string helpers.
+- `parseFloat(s)`, `isNaN(v)`, `isFinite(v)` – numeric helpers.
+- `pow(x, y)`, `random()`, `acos(x)`, `asin(x)`, `atan(x)`, `atan2(y, x)`,
+  `cos(x)`, `exp(x)`, `floor(x)`, `log(x)`, `sin(x)`, `sqrt(x)`, `tan(x)` – math routines.
+- `maxNumber`, `minNumber` – numeric limits.
+- `getCurrentTime()`, `localTimeDifference(epoch)`, `updateDateValue(o, v)` – date helpers.
+- `createRegExp(pattern, flags)` – construct `RegExp` objects.
+- `undefined`, `NaN`, `Infinity` – primitive constants.
+
 ## Avoid global objects
+
 - Do not rely on global constructors or methods because user code may reassign them.
 - Use the `$`-prefixed helpers or functions on `support` instead of global versions (for example `$charCodeAt`, `$isNaN`).
 
 ## Unconstructable methods
+
 - Wrap functions that must not be invoked with `new` using `unconstructable` (an alias for `support.distinctConstructor`).
 - This removes their `.prototype` property and throws a `TypeError` when construction is attempted.
 
 ## Language constraints
+
 - Target ECMAScript 3 semantics.
 - Avoid engine limitations such as custom getters/setters, non-ES3 evaluation order and unsupported regular expression features.
+
+## Writing and Minifying `src/stdlib.js`
+
+This section explains how the standard library is authored in plain JavaScript and then minified and embedded into the engine. It covers the minification pipeline, naming rules and the constraints you should follow when editing or extending `src/stdlib.js`.
+
+### Overview
+
+- Source of truth: `src/stdlib.js`
+- Build step: the file is parsed and minified by PikaScript (via `PikaCmd`) using a PEG grammar in `tools/stdlibMinifier.ppeg`
+- Emission: `tools/stdlibToCpp.pika` converts the minified code into `src/stdlibJS.cpp` as a C string array that the C++ runtime loads on startup.
+- Trigger: regeneration happens automatically when `src/stdlib.js` is newer than `src/stdlibJS.cpp`.
+
+Relevant files:
+
+- `tools/buildAndTest.sh:14–22, 28–37` – runs PikaCmd and rebuilds `src/stdlibJS.cpp` on demand
+- `tools/stdlibToCpp.pika:1` – orchestrates minification and C++ emission
+- `tools/stdlibMinifier.ppeg:1` – PPEG grammar used for tokenizing and renaming
+
+### Minifier, in a nutshell
+
+The minifier is not a full JS parser. It is a small PEG grammar that:
+
+- Removes comments and collapses whitespace
+- Renames all identifiers unless explicitly preserved
+- Leaves punctuation/operators intact
+- Keeps string and numeric literals as-is
+- Drops a redundant semicolon before a closing brace (`; }` → `}`)
+
+Identifiers are matched by the simple rule `[$a-zA-Z_0-9]+` and then passed through a renamer. The renamer generates short symbols (`a`, `b`, …, `Z`, `a0`, `a1`, …) and skips any name listed as preserved.
+
+Because property names in dot form (e.g. `obj.length`) also match `identifier`, they will be renamed unless preserved. This is why the top of `src/stdlib.js` contains one or more `@preserve:` comment lines enumerating all names that must remain stable at runtime (built-ins, property keys, well-known globals, etc.).
+
+### Authoring rules for `src/stdlib.js`
+
+Follow these to keep the minifier happy and semantics correct:
+
+1. **Preserve externally visible names** – Put every property name and global symbol that must not change under one or more comment lines with the special prefix `@preserve:`. Example from the existing file:
+
+   ```
+   /*
+       @preserve: Array,Boolean,Date,E,Error,Function,Infinity,LN10,LN2,LOG10E,LOG2E,MAX_VALUE,MIN_VALUE,Math
+       @preserve: NEGATIVE_INFINITY,NaN,Number,Object,PI,POSITIVE_INFINITY,RangeError,RegExp,SQRT1_2,SQRT2,String
+       ...
+   */
+   ```
+
+   Typical entries include: method names (`apply`, `call`, `toString`, `valueOf`, …), property names (`length`, `prototype`, `constructor`, …), global values (`Infinity`, `NaN`, `undefined`), and any object keys that are looked up reflectively from C++.
+
+2. **Do not use regular expression literals** – The grammar intentionally disables `/…/flags` because it cannot reliably disambiguate division vs. regex without a full JS parser. Use the constructor instead: `RegExp(pattern, flags)` or the provided `support.createRegExp(pattern, flags)`.
+
+3. **Keep to ES3/ES5.1-era syntax** – No template strings, destructuring, default parameters, arrow functions, classes, etc. String escapes supported by the grammar: `\n`, `\r`, `\t`, `\\`, `\"`, `\'`, `\xNN`, `\uNNNN`.
+
+4. **Assume whitespace is collapsed** – Tokens are re-joined with a single space where needed. Do not rely on line-break-sensitive Automatic Semicolon Insertion tricks. Write explicit semicolons as you would in production code. The minifier removes `;` immediately before `}`; elsewhere your semicolons are kept.
+
+5. **Prefer helper shims for native-like behaviour** – Define methods via `defineProperties(object, attribs, props)` and `support.defineProperty()` to set attributes like read‑only, dont‑enum, and dont‑delete. Example patterns used throughout the library:
+   - Create “unconstructable” functions (callable but not `new`‑able): `unconstructable(function name(...) { ... })`
+   - Create distinct call vs. construct behaviour: `support.distinctConstructor(callImpl, constructImpl)`
+   - Wrap primitives into proper objects: `support.createWrapper(className, internalValue, prototype)`
+
+6. **Be explicit with property keys** – If a property name is not on the `@preserve:` list and you only need it internally, consider bracket access with a string literal (`obj["privateKey"]`) to avoid the renamer touching it.
+
+### What the minifier actually does (details)
+
+`tools/stdlibMinifier.ppeg` defines these key rules:
+
+- `root`: streams the whole file, choosing one of these at each step:
+  - `ws` (whitespace or comments) – discarded except for `@preserve:` handling
+  - `qString` / `aString` – double- or single-quoted strings, kept verbatim (with escapes)
+  - `token` – numbers or identifiers; identifiers go through the renamer
+  - a special `';' ws '}'` case that emits only `}`
+  - any single character `.` (operators and punctuation) appended as-is
+- `token`: `number` or `identifier`
+  - `number`: hex (`0x…`) or decimal with optional fraction and exponent
+  - `identifier`: `[$a-zA-Z_0-9]+` (note: this is simpler than the real ES grammar)
+- `comment`:
+  - `/* … */` and `// …` are stripped; if they contain a `@preserve:` clause then each listed identifier is marked preserved in the parser state and will never be renamed.
+- Renamer: implemented in the `{ … }` preamble block at the top of the PEG file. It generates the sequence `a, b, …, Z, a0, a1, …` while avoiding any `@preserve`d symbol.
+
+`tools/stdlibToCpp.pika` then slices the minified output into quoted C++ lines that stay under 120 columns and writes `src/stdlibJS.cpp` with:
+
+```
+namespace NuXJS {
+const char* STDLIB_JS =
+"…minified and escaped JS…"
+"…continued…"
+;
+#if (NUXJS_ES5)
+const char* STDLIB_ES5_JS =
+"…minified ES5 additions…"
+"…continued…"
+;
+#endif
+}
+```
+
+### Testing your changes
+
+1. Edit `src/stdlib.js`
+2. Run `./build.sh` (or `build.cmd` on Windows). The build checks timestamps and regenerates `src/stdlibJS.cpp` when needed using the local `externals/PikaCmd` tool.
+3. For ES5.1 work, set `CPP_OPTIONS='-DNUXJS_ES5=1'` to enable ES5.1 tests, or set `NUXJS_TEST_ES5_VARIANTS=1` to run both ES3 and ES5.1 passes:
+
+   ```bash
+   CPP_OPTIONS='-DNUXJS_ES5=1' ./build.sh
+   NUXJS_TEST_ES5_VARIANTS=1 ./build.sh
+   ```
+
+### PikaScript reference (why it matters)
+
+The minifier and emitter are written in PikaScript and PPEG (Pika PEG). If you need to tweak the pipeline, consult the upstream documentation:
+
+- PikaScript Documentation (language reference):
+  https://github.com/malstrom72/PikaScript/blob/main/docs/PikaScript%20Documentation.txt
+- PPEG Documentation (parser generator):
+  https://github.com/malstrom72/PikaScript/blob/main/docs/PPEG%20Documentation.txt
+- PikaCmd Documentation (CLI tool):
+  https://github.com/malstrom72/PikaScript/blob/main/docs/PikaCmd%20Documentation.txt
+
+You do not need a system-wide installation; our build uses the checked-in `externals/PikaCmd` tool and the local scripts under `tools/`. If you want to explore or hack on PikaScript itself, refer to the repository above instead of adding it to this tree.
+
diff --git a/docs/getter-setter-attempt.md b/docs/getter-setter-attempt.md
new file mode 100644
index 0000000..bb57cce
--- /dev/null
+++ b/docs/getter-setter-attempt.md
@@ -0,0 +1,13 @@
+# Getter/Setter Work
+
+Initial infrastructure for ES5.1 accessor properties is in place. A new `Accessor` object stores getter and setter pairs in property buckets flagged with `ACCESSOR_FLAG`.
+
+`Object.defineProperty` now accepts descriptor objects containing `get` or `set` and forwards the functions to the runtime without invoking the blocking `Runtime::call` path.
+
+However, accessor properties remain non-functional: the example in `examples/getter_setter_example.cpp` still prints `obj.value = undefined` and leaves `obj._v` unchanged. Further work is needed to wire descriptor plumbing to property lookup and write paths.
+
+Current limitations:
+- Descriptor validation is minimal and object literal `get`/`set` syntax is still unparsed.
+- Redefinition semantics and strict mode error handling remain incomplete.
+- Runtime `support.defineProperty` receives `undefined` for the `get` and `set` slots, indicating argument propagation from the
+  JavaScript wrapper is still broken.
diff --git a/docs/stdlib.js Authoring Guide.md b/docs/stdlib.js Authoring Guide.md
new file mode 100644
index 0000000..f03a3e1
--- /dev/null
+++ b/docs/stdlib.js Authoring Guide.md	
@@ -0,0 +1,154 @@
+# Writing and Minifying `src/stdlib.js`
+
+This guide explains how the standard library is authored in plain JavaScript and then minified and embedded into the
+engine. It covers the minification pipeline (implemented in PikaScript/PPEG), naming rules, and the constraints you
+should follow when editing or extending `src/stdlib.js`.
+
+## Overview
+
+- Source of truth: `src/stdlib.js`
+- Build step: the file is parsed and minified by PikaScript (via `PikaCmd`) using a PEG grammar in
+  `tools/stdlibMinifier.ppeg`
+- Emission: `tools/stdlibToCpp.pika` converts the minified code into `src/stdlibJS.cpp` as a C string array that the
+  C++ runtime loads on startup.
+- Trigger: regeneration happens automatically when `src/stdlib.js` is newer than `src/stdlibJS.cpp`.
+
+Relevant files:
+- `tools/buildAndTest.sh:14–22, 28–37` – runs PikaCmd and rebuilds `src/stdlibJS.cpp` on demand
+- `tools/stdlibToCpp.pika:1` – orchestrates minification and C++ emission
+- `tools/stdlibMinifier.ppeg:1` – PPEG grammar used for tokenizing and renaming
+
+## Minifier, in a nutshell
+
+The minifier is not a full JS parser. It is a small PEG grammar that:
+
+- Removes comments and collapses whitespace
+- Renames all identifiers unless explicitly preserved
+- Leaves punctuation/operators intact
+- Keeps string and numeric literals as-is
+- Drops a redundant semicolon before a closing brace (`; }` → `}`)
+
+Identifiers are matched by the simple rule `[$a-zA-Z_0-9]+` and then passed through a renamer. The renamer generates
+short symbols (`a`, `b`, …, `Z`, `a0`, `a1`, …) and skips any name listed as preserved.
+
+Because property names in dot form (e.g. `obj.length`) also match `identifier`, they will be renamed unless preserved.
+This is why the top of `src/stdlib.js` contains one or more `@preserve:` comment lines enumerating all names that must
+remain stable at runtime (built-ins, property keys, well-known globals, etc.).
+
+## Authoring rules for `src/stdlib.js`
+
+Follow these to keep the minifier happy and semantics correct:
+
+1) Preserve externally visible names
+- Put every property name and global symbol that must not change under one or more comment lines with the special
+  prefix `@preserve:`. Example from the existing file:
+
+  ```
+  /*
+      @preserve: Array,Boolean,Date,E,Error,Function,Infinity,LN10,LN2,LOG10E,LOG2E,MAX_VALUE,MIN_VALUE,Math
+      @preserve: NEGATIVE_INFINITY,NaN,Number,Object,PI,POSITIVE_INFINITY,RangeError,RegExp,SQRT1_2,SQRT2,String
+      ...
+  */
+  ```
+
+- Typical entries include: method names (`apply`, `call`, `toString`, `valueOf`, …), property names (`length`,
+  `prototype`, `constructor`, …), global values (`Infinity`, `NaN`, `undefined`), and any object keys that are looked
+  up reflectively from C++.
+
+2) Do not use regular expression literals
+- The grammar intentionally disables `/…/flags` because it cannot reliably disambiguate division vs. regex without a
+  full JS parser.
+- Use the constructor instead: `RegExp(pattern, flags)` or the provided `support.createRegExp(pattern, flags)`.
+
+3) Keep to ES3/ES5.1-era syntax
+- No template strings, destructuring, default parameters, arrow functions, classes, etc.
+- String escapes supported by the grammar: `\n`, `\r`, `\t`, `\\`, `\"`, `\'`, `\xNN`, `\uNNNN`.
+
+4) Assume whitespace is collapsed
+- Tokens are re-joined with a single space where needed. Do not rely on line-break-sensitive Automatic Semicolon
+  Insertion tricks. Write explicit semicolons as you would in production code.
+- The minifier removes `;` immediately before `}`; elsewhere your semicolons are kept.
+
+5) Prefer helper shims for native-like behaviour
+- Define methods via `defineProperties(object, attribs, props)` and `support.defineProperty()` to set attributes like
+  read‑only, dont‑enum, and dont‑delete. Example patterns used throughout the library:
+
+  - Create “unconstructable” functions (callable but not `new`‑able):
+    `unconstructable(function name(...) { ... })`
+  - Create distinct call vs. construct behaviour:
+    `support.distinctConstructor(callImpl, constructImpl)`
+  - Wrap primitives into proper objects:
+    `support.createWrapper(className, internalValue, prototype)`
+
+6) Be explicit with property keys
+- If a property name is not on the `@preserve:` list and you only need it internally, consider bracket access with a
+  string literal (`obj["privateKey"]`) to avoid the renamer touching it.
+
+## What the minifier actually does (details)
+
+`tools/stdlibMinifier.ppeg` defines these key rules:
+
+- `root`: streams the whole file, choosing one of these at each step:
+  - `ws` (whitespace or comments) – discarded except for `@preserve:` handling
+  - `qString` / `aString` – double- or single-quoted strings, kept verbatim (with escapes)
+  - `token` – numbers or identifiers; identifiers go through the renamer
+  - a special `';' ws '}'` case that emits only `}`
+  - any single character `.` (operators and punctuation) appended as-is
+
+- `token`: `number` or `identifier`
+  - `number`: hex (`0x…`) or decimal with optional fraction and exponent
+  - `identifier`: `[$a-zA-Z_0-9]+` (note: this is simpler than the real ES grammar)
+
+- `comment`:
+  - `/* … */` and `// …` are stripped; if they contain a `@preserve:` clause then each listed identifier is marked
+    preserved in the parser state and will never be renamed.
+
+- Renamer: implemented in the `{ … }` preamble block at the top of the PEG file. It generates the sequence
+  `a, b, …, Z, a0, a1, …` while avoiding any `@preserve`d symbol.
+
+`tools/stdlibToCpp.pika` then slices the minified output into quoted C++ lines that stay under 120 columns and writes
+`src/stdlibJS.cpp` with:
+
+```
+namespace NuXJS {
+const char* STDLIB_JS =
+"…minified and escaped JS…"
+"…continued…"
+;
+#if (NUXJS_ES5)
+const char* STDLIB_ES5_JS =
+"…minified ES5 additions…"
+"…continued…"
+;
+#endif
+}
+```
+
+## Testing your changes
+
+1) Edit `src/stdlib.js`
+2) Run `./build.sh` (or `build.cmd` on Windows). The build checks timestamps and regenerates `src/stdlibJS.cpp` when
+	needed using the local `externals/PikaCmd` tool.
+3) ES5.1 features and tests run by default. To build and test the ES3-only variant, set
+        `CPP_OPTIONS='-DNUXJS_ES5=0'`, or set `NUXJS_TEST_ES5_VARIANTS=1` to run both ES3 and ES5.1 passes:
+
+        ```bash
+        CPP_OPTIONS='-DNUXJS_ES5=0' ./build.sh
+        NUXJS_TEST_ES5_VARIANTS=1 ./build.sh
+        ```
+
+## PikaScript reference (why it matters)
+
+The minifier and emitter are written in PikaScript and PPEG (Pika PEG). If you need to tweak the pipeline, consult the
+upstream documentation:
+
+- PikaScript Documentation (language reference):
+  https://github.com/malstrom72/PikaScript/blob/main/docs/PikaScript%20Documentation.txt
+- PPEG Documentation (parser generator):
+  https://github.com/malstrom72/PikaScript/blob/main/docs/PPEG%20Documentation.txt
+- PikaCmd Documentation (CLI tool):
+  https://github.com/malstrom72/PikaScript/blob/main/docs/PikaCmd%20Documentation.txt
+
+You do not need a system-wide installation; our build uses the checked-in `externals/PikaCmd` tool and the local
+scripts under `tools/`. If you want to explore or hack on PikaScript itself, refer to the repository above instead of
+adding it to this tree.
diff --git a/examples/getter_setter_example.cpp b/examples/getter_setter_example.cpp
new file mode 100644
index 0000000..e3a29b9
--- /dev/null
+++ b/examples/getter_setter_example.cpp
@@ -0,0 +1,57 @@
+/**
+	NuXJS is released under the BSD 2-Clause License.
+
+	Copyright (c) 2018-2025, Magnus Lidström
+
+	Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
+	following conditions are met:
+
+	1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following
+	disclaimer.
+
+	2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
+	disclaimer in the documentation and/or other materials provided with the distribution.
+
+	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+	INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+	DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+	SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+	SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+	WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+	OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**/
+
+#include <iostream>
+#include "../src/NuXJS.h"
+
+using namespace NuXJS;
+
+int main() {
+	Heap heap;
+	Runtime rt(heap);
+	rt.setupStandardLibrary();
+
+	Var globals = rt.getGlobalsVar();
+rt.run(
+"var obj = {\n" \
+"\t_v: 1,\n" \
+"\tget value() { return this._v; },\n" \
+"\tset value(v) { this._v = v; },\n" \
+"\tget double() { return this._v * 2; },\n" \
+"\tset double(v) { this._v = v / 2; }\n" \
+"};\n" \
+"var start = obj.value;\n" \
+"var startDouble = obj.double;\n" \
+"obj.double = 50;\n" \
+"var afterSetDouble = obj.value;\n" \
+"obj.value = 15;\n" \
+"var finalDouble = obj.double;"
+);
+	Var obj = globals["obj"];
+	std::wcout << L"start = " << globals["start"].to<int>() << std::endl;
+	std::wcout << L"startDouble = " << globals["startDouble"].to<int>() << std::endl;
+	std::wcout << L"afterSetDouble = " << globals["afterSetDouble"].to<int>() << std::endl;
+	std::wcout << L"finalDouble = " << globals["finalDouble"].to<int>() << std::endl;
+	std::wcout << L"obj._v = " << obj["_v"].to<int>() << std::endl;
+	return 0;
+}
diff --git a/src/NuXJS.cpp b/src/NuXJS.cpp
index 091635a..ee41b38 100644
--- a/src/NuXJS.cpp
+++ b/src/NuXJS.cpp
@@ -180,6 +180,8 @@ const String A_RGUMENTS_STRING("Arguments"), A_RRAY_STRING("Array"), B_OOLEAN_ST
                 , E_RROR_STRING("Error"), F_UNCTION_STRING("Function"), N_UMBER_STRING("Number"), O_BJECT_STRING("Object")
                 , S_TRING_STRING("String");
 
+const String GET_STRING("get"), SET_STRING("set");
+
 static const String ANONYMOUS_STRING("anonymous"), ARGUMENTS_STRING("arguments")
 		, BRACKET_OBJECT_STRING("[object "), CALLEE_STRING("callee")
 		, CANNOT_CONVERT_TO_OBJECT_STRING("Cannot convert undefined or null to object")
@@ -1277,6 +1279,7 @@ const String* Object::getClassName() const { return &O_BJECT_STRING; }
 Object* Object::getPrototype(Runtime& rt) const { return rt.getObjectPrototype(); }
 Value Object::getInternalValue(Heap&) const { return UNDEFINED_VALUE; }
 Flags Object::getOwnProperty(Runtime&, const Value&, Value*) const { return NONEXISTENT; }
+bool Object::setOwnProperty(Runtime& rt, const String* key, const Value& v, Flags flags) { return setOwnProperty(rt, Value(key), v, flags); }
 bool Object::setOwnProperty(Runtime&, const Value&, const Value&, Flags) { return false; }
 bool Object::deleteOwnProperty(Runtime&, const Value&) { return false; }
 Enumerator* Object::getOwnPropertyEnumerator(Runtime&) const { return &EMPTY_ENUMERATOR; }
@@ -1316,6 +1319,31 @@ Flags Object::getProperty(Runtime& rt, const Value& key, Value* v) const {
 	return NONEXISTENT;
 }
 
+Flags Object::getProperty(Runtime& rt, Processor& processor, const Value& key, Value* v) const {
+const Object* o = this;
+do {
+Value current;
+Flags flags = o->getOwnProperty(rt, key, &current);
+if (flags != NONEXISTENT) {
+if ((flags & ACCESSOR_FLAG) != 0) {
+Accessor* acc = static_cast<Accessor*>(current.asObject());
+Function* getter = (acc != 0 ? acc->getter : 0);
+if (getter != 0) {
+processor.invokeFunction(getter, 0, static_cast<const Value*>(0), const_cast<Object*>(this));
+} else {
+*v = UNDEFINED_VALUE;
+}
+} else {
+*v = current;
+}
+return flags;
+}
+o = o->getPrototype(rt);
+} while (o != 0);
+return NONEXISTENT;
+}
+
+
 bool Object::setProperty(Runtime& rt, const Value& key, const Value& v) {
 	if (updateOwnProperty(rt, key, v)) {
 		return true;
@@ -1330,6 +1358,23 @@ bool Object::setProperty(Runtime& rt, const Value& key, const Value& v) {
 	return setOwnProperty(rt, key, v);
 }
 
+bool Object::setProperty(Runtime& rt, Processor& processor, const Value& key, const Value& v) {
+Value current;
+Flags flags = getProperty(rt, key, &current);
+if (flags != NONEXISTENT && (flags & ACCESSOR_FLAG) != 0) {
+Accessor* acc = static_cast<Accessor*>(current.asObject());
+Function* setter = (acc != 0 ? acc->setter : 0);
+if (setter != 0) {
+Value arg(v);
+processor.invokeFunction(setter, 1, &arg, const_cast<Object*>(this));
+return true;
+}
+return false;
+}
+setProperty(rt, key, v);
+return false;
+}
+
 Enumerator* Object::getPropertyEnumerator(Runtime& rt) const {
 	Heap& heap = rt.getHeap();
 	Enumerator* enumerator = getOwnPropertyEnumerator(rt);
@@ -1479,9 +1524,26 @@ JSObject::JSObject(GCList& gcList, Object* prototype)
 Object* JSObject::getPrototype(Runtime&) const { return prototype; }
 
 bool JSObject::setOwnProperty(Runtime& rt, const Value& key, const Value& v, Flags flags) {
-	return update(insert(key.toString(rt.getHeap())), v, flags);
+	return setOwnProperty(rt, key.toString(rt.getHeap()), v, flags);
 }
 
+bool JSObject::setOwnProperty(Runtime& rt, const String* key, const Value& v, Flags flags) {
+	Table::Bucket* bucket = insert(key);
+	if ((flags & ACCESSOR_FLAG) != 0 && bucket->valueExists() && (bucket->getFlags() & ACCESSOR_FLAG) != 0) {
+	Accessor* acc = static_cast<Accessor*>(bucket->getValue().getObject());
+	Accessor* nv = static_cast<Accessor*>(v.getObject());
+	if (nv->getter != 0) {
+	acc->getter = nv->getter;
+	}
+	if (nv->setter != 0) {
+	acc->setter = nv->setter;
+	}
+	return true;
+	}
+	return update(bucket, v, flags);
+}
+
+
 bool JSObject::updateOwnProperty(Runtime& rt, const Value& key, const Value& v) {
 	Table::Bucket* bucket = lookup(key.toString(rt.getHeap()));
 	return (bucket != 0 && update(bucket, v));
@@ -1495,7 +1557,6 @@ Flags JSObject::getOwnProperty(Runtime& rt, const Value& key, Value* v) const {
 	}
 	return NONEXISTENT;
 }
-
 bool JSObject::deleteOwnProperty(Runtime& rt, const Value& key) {
 	Table::Bucket* bucket = lookup(key.toString(rt.getHeap()));
 	return (bucket == 0 || erase(bucket));
@@ -1553,7 +1614,7 @@ Code::Code(GCList& gcList, Constants* sharedConstants)
 	: super(gcList), codeWords(0, &gcList.getHeap())
 	, constants(sharedConstants ? sharedConstants : new(gcList.getHeap()) Constants(gcList.getHeap().managed()))
 	, nameIndexes(&gcList.getHeap()), varNames(&gcList.getHeap()), argumentNames(&gcList.getHeap()), name(0)
-	, selfName(0), source(0), bloomSet(0), maxStackDepth(0)
+, selfName(0), source(0), bloomSet(0), maxStackDepth(0), strict(false)
 {
 	assert(constants != 0);
 }
@@ -1697,6 +1758,10 @@ bool JSArray::setElement(Runtime& rt, UInt32 index, const Value& v) {
 	return super::setOwnProperty(rt, index, v, STANDARD_FLAGS);
 }
 
+bool JSArray::setOwnProperty(Runtime& rt, const String* key, const Value& v, Flags flags) {
+	return setOwnProperty(rt, Value(key), v, flags);
+}
+
 bool JSArray::setOwnProperty(Runtime& rt, const Value& key, const Value& v, Flags flags) {
 	UInt32 index;
 	if (key.toArrayIndex(index) && index != 0xFFFFFFFFU) {
@@ -1754,6 +1819,10 @@ template<class SUPER> bool LazyJSObject<SUPER>::setOwnProperty(Runtime& rt, cons
 	return getCompleteObject(rt)->setOwnProperty(rt, key, v, flags);
 }
 
+template<class SUPER> bool LazyJSObject<SUPER>::setOwnProperty(Runtime& rt, const String* key, const Value& v, Flags flags) {
+	return getCompleteObject(rt)->setOwnProperty(rt, key, v, flags);
+}
+
 template<class SUPER> bool LazyJSObject<SUPER>::deleteOwnProperty(Runtime& rt, const Value& key) {
 	return getCompleteObject(rt)->deleteOwnProperty(rt, key);
 }
@@ -1828,6 +1897,12 @@ void Error::updateReflection(Runtime& rt) {
 	message = (getProperty(rt, &MESSAGE_STRING, &v) != NONEXISTENT ? v.toString(rt.getHeap()) : 0);
 }
 
+bool Error::setOwnProperty(Runtime& rt, const String* key, const Value& v, Flags flags) {
+	const bool result = super::setOwnProperty(rt, key, v, flags);
+	updateReflection(rt);
+	return result;
+}
+
 bool Error::setOwnProperty(Runtime& rt, const Value& key, const Value& v, Flags flags) {
 	const bool result = super::setOwnProperty(rt, key, v, flags);
 	updateReflection(rt);
@@ -1850,7 +1925,7 @@ void Error::constructCompleteObject(Runtime& rt) const {
 
 Arguments::Arguments(GCList& gcList, const FunctionScope* scope, UInt32 argumentsCount) : super(gcList)
 	, scope(scope), function(scope->function), argumentsCount(argumentsCount)
-	   , deletedArguments(argumentsCount, &gcList.getHeap()), values(0, &gcList.getHeap()) {
+	, deletedArguments(argumentsCount, &gcList.getHeap()), values(0, &gcList.getHeap()), owner(const_cast<FunctionScope*>(scope)) {
 	std::fill(deletedArguments.begin(), deletedArguments.end(), false);
 }
 
@@ -1884,6 +1959,10 @@ Flags Arguments::getOwnProperty(Runtime& rt, const Value& key, Value* v) const {
 	return (p == 0 ? super::getOwnProperty(rt, key, v) : ((void)(*v = *p), (DONT_ENUM_FLAG | EXISTS_FLAG)));
 }
 
+bool Arguments::setOwnProperty(Runtime& rt, const String* key, const Value& v, Flags flags) {
+	return setOwnProperty(rt, Value(key), v, flags);
+}
+
 bool Arguments::setOwnProperty(Runtime& rt, const Value& key, const Value& v, Flags flags) {
 	Value* p = findProperty(key);
 	if (p != 0 && (flags & (READ_ONLY_FLAG | DONT_ENUM_FLAG | DONT_DELETE_FLAG)) != 0) {
@@ -1910,8 +1989,8 @@ void Arguments::constructCompleteObject(Runtime& rt) const {
 }
 
 Arguments::~Arguments() {
-	if (scope != 0) {
-		scope->arguments = 0;
+	if (owner != 0) {
+		owner->arguments = 0;
 	}
 }
 
@@ -1961,13 +2040,28 @@ FunctionScope::FunctionScope(GCList& gcList, JSFunction* function, UInt32 argc,
 	if (code->getArgumentsCount() > argc) {
 		std::fill(e, locals.end(), UNDEFINED_VALUE);
 	}
+#if (NUXJS_ES5)
+	if (code->strict) {
+		Heap& heap = gcList.getHeap();
+		arguments = new(heap) Arguments(heap.managed(), this, passedArgumentsCount);
+		arguments->detach();
+	}
+#endif
+
 }
 
 JSObject* FunctionScope::getDynamicVars(Runtime& rt) const {
 	if (dynamicVars == 0) {
 		Heap& heap = rt.getHeap();
 		dynamicVars = new(heap) JSObject(heap.managed(), 0);
+		if (arguments == 0) {
 			arguments = new(heap) Arguments(heap.managed(), this, passedArgumentsCount);
+		#if (NUXJS_ES5)
+			if (function->code->strict) {
+				arguments->detach();
+			}
+		#endif
+		}
 		dynamicVars->setOwnProperty(rt, &ARGUMENTS_STRING, arguments, DONT_DELETE_FLAG);
 	}
 	return dynamicVars;
@@ -2062,6 +2156,7 @@ void FunctionScope::declareVar(Runtime& rt, const String* name, const Value& ini
 
 FunctionScope::~FunctionScope() {
         if (arguments != 0) {
+                arguments->owner = 0;
                 arguments->detach();
                 arguments = 0;
         }
@@ -2095,7 +2190,12 @@ static struct EvalFunction : public Function {
 
 		Heap& heap = rt.getHeap();
 		const String* expression = argv[0].toString(heap);
-		processor.enterEvalCode(rt.compileEvalCode(expression), direct);
+		#if (NUXJS_ES5)
+			const bool strict = direct && processor.isCurrentStrict();
+		#else
+			const bool strict = false;
+		#endif
+			processor.enterEvalCode(rt.compileEvalCode(expression, strict), direct);
 		return UNDEFINED_VALUE;
 	}
 	bool direct;
@@ -2119,6 +2219,8 @@ const Processor::OpcodeInfo Processor::opcodeInfo[Processor::OP_COUNT] = {
 	{ SET_PROPERTY_OP            , "SET_PROPERTY"            , -2     , 0 },
 	{ SET_PROPERTY_POP_OP        , "SET_PROPERTY_POP"        , -3     , 0 },
 	{ ADD_PROPERTY_OP            , "ADD_PROPERTY"            , -1     , 0 },
+	{ ADD_GETTER_OP            , "ADD_GETTER"             , -1     , 0 },
+	{ ADD_SETTER_OP            , "ADD_SETTER"             , -1     , 0 },
 	{ PUSH_ELEMENTS_OP           , "PUSH_ELEMENTS_OP"        , 0      , OpcodeInfo::POP_OPERAND },
 	{ OBJ_TO_PRIMITIVE_OP        , "OBJ_TO_PRIMITIVE"        , 0      , 0 },
 	{ OBJ_TO_NUMBER_OP           , "OBJ_TO_NUMBER"           , 0      , 0 },
@@ -2202,10 +2304,49 @@ const Processor::OpcodeInfo& Processor::getOpcodeInfo(const Opcode opcode) {
 */
 struct Processor::EvalScope : public Scope {
 		typedef Scope super;
-	EvalScope(GCList& gcList, Scope* parentScope) : super(gcList, parentScope) { }
-	virtual void declareVar(Runtime& rt, const String* name, const Value& initValue, bool) {
+		EvalScope(GCList& gcList, Scope* parentScope, bool isolated) : super(gcList, parentScope), vars(0), isolated(isolated) { }
+		virtual Flags readVar(Runtime& rt, const String* name, Value* v) const {
+			if (isolated && vars != 0) {
+				const Flags flags = vars->getOwnProperty(rt, name, v);
+				if (flags != NONEXISTENT) {
+					return flags;
+				}
+			}
+			return parentScope->readVar(rt, name, v);
+		}
+		virtual void writeVar(Runtime& rt, const String* name, const Value& value) {
+			if (isolated && vars != 0) {
+				Value tmp;
+				if (vars->getOwnProperty(rt, name, &tmp) != NONEXISTENT) {
+					vars->setOwnProperty(rt, name, value);
+					return;
+				}
+			}
+			parentScope->writeVar(rt, name, value);
+		}
+		virtual bool deleteVar(Runtime& rt, const String* name) {
+			if (isolated && vars != 0 && vars->deleteOwnProperty(rt, name)) {
+				return true;
+			}
+			return parentScope->deleteVar(rt, name);
+		}
+		virtual void declareVar(Runtime& rt, const String* name, const Value& initValue, bool dontDelete) {
+			if (isolated) {
+				if (vars == 0) {
+					Heap& heap = rt.getHeap();
+					vars = new(heap) JSObject(heap.managed(), 0);
+				}
+				vars->setOwnProperty(rt, name, initValue.isUndefined() ? UNDEFINED_VALUE : initValue, dontDelete ? DONT_DELETE_FLAG : 0);
+			} else {
 				parentScope->declareVar(rt, name, initValue, false);
 			}
+		}
+		JSObject* vars;
+		bool isolated;
+		virtual void gcMarkReferences(Heap& heap) const {
+			gcMark(heap, vars);
+			super::gcMarkReferences(heap);
+		}
 };
 	
 /*
@@ -2313,7 +2454,8 @@ void Processor::enter(const Code* code, Scope* scope, Object* thisObject) {
 	if (sp + code->getMaxStackDepth() > stack.end()) {
 		ScriptException::throwError(heap, RANGE_ERROR, &STACK_OVERFLOW_STRING); // Notice: we can't use virtual throw here, cause we need to abort any sp changes etc that could happen if we continued execution beyond this point.
 	} else {
-		pushFrame(code, scope, (thisObject == 0 ? rt.getGlobalObject() : thisObject));
+Object* obj = (thisObject == 0 && !code->isStrict() ? rt.getGlobalObject() : thisObject);
+pushFrame(code, scope, obj);
 		ip = code->getCodeWords();
 	}
 }
@@ -2326,14 +2468,16 @@ void Processor::enterGlobalCode(const Code* code) {
 	enter(code, rt.getGlobalScope(), rt.getGlobalObject());
 }
 
-void Processor::enterEvalCode(const Code* code, bool local) {
-	if (local && currentFrame != 0) {
-		enter(code, new(heap) Processor::EvalScope(heap.managed(), currentFrame->scope), currentFrame->thisObject);
+void Processor::enterEvalCode(const Code* code, bool direct) {
+	bool isolate = direct && code->isStrict();
+	if (direct && currentFrame != 0) {
+		enter(code, new(heap) Processor::EvalScope(heap.managed(), currentFrame->scope, isolate), currentFrame->thisObject);
 	} else {
-		enter(code, new(heap) Processor::EvalScope(heap.managed(), rt.getGlobalScope()), rt.getGlobalObject());
+		enter(code, new(heap) Processor::EvalScope(heap.managed(), rt.getGlobalScope(), isolate), rt.getGlobalObject());
 	}
 }
 
+
 void Processor::enterFunctionCode(JSFunction* func, UInt32 argc, const Value* argv, Object* thisObject) {
 	enter(func->code, new(heap) FunctionScope(heap.managed(), func, argc, argv), thisObject);
 }
@@ -2451,42 +2595,80 @@ void Processor::innerRun() {
 				}
 			}
 			break;
-			case WRITE_NAMED_OP:		scope->writeVar(rt, constants[im].getString(), sp[0]); break;
-			case WRITE_NAMED_POP_OP:	scope->writeVar(rt, constants[im].getString(), sp[0]); pop(1); break;
-
+			case WRITE_NAMED_OP: {
+				const String* name = constants[im].getString();
+				if (code->isStrict()) {
+					Value dummy;
+					if (scope->readVar(rt, name, &dummy) == NONEXISTENT) {
+						error(REFERENCE_ERROR, new(heap) String(heap.managed(), *name, IS_NOT_DEFINED_STRING));
+						return;
+					}
+				}
+				scope->writeVar(rt, name, sp[0]);
+			}
+			break;
+			case WRITE_NAMED_POP_OP: {
+				const String* name = constants[im].getString();
+				if (code->isStrict()) {
+					Value dummy;
+					if (scope->readVar(rt, name, &dummy) == NONEXISTENT) {
+						error(REFERENCE_ERROR, new(heap) String(heap.managed(), *name, IS_NOT_DEFINED_STRING));
+						return;
+					}
+				}
+				scope->writeVar(rt, name, sp[0]);
+				pop(1);
+			}
+			break;
 case GET_PROPERTY_OP: {
 const Object* o = convertToObject(sp[-1], false);
 if (o == 0) {
 return;
 }
-				if (o->getProperty(rt, sp[0], sp - 1) == NONEXISTENT) {
+Flags f = o->getProperty(rt, *this, sp[0], sp - 1);
+if (f == NONEXISTENT) {
 sp[-1] = UNDEFINED_VALUE;
+pop(1);
+break;
 }
 pop(1);
+if ((f & ACCESSOR_FLAG) != 0) {
+return;
+}
 break;
 }
 
+			
 case SET_PROPERTY_OP: {
 Object* o = convertToObject(sp[-2], false);
 if (o == 0) {
 return;
 }
-				o->setProperty(rt, sp[-1], sp[0]);
-				sp[-2] = sp[0];
+Value v = sp[0];
+bool acc = o->setProperty(rt, *this, sp[-1], sp[0]);
+sp[-2] = v;
 pop(2);
+if (acc) {
+return;
+}
 break;
 }
 
+			
 case SET_PROPERTY_POP_OP: {
 Object* o = convertToObject(sp[-2], false);
 if (o == 0) {
 return;
 }
-				o->setProperty(rt, sp[-1], sp[0]);
+bool acc = o->setProperty(rt, *this, sp[-1], sp[0]);
 pop(3);
+if (acc) {
+return;
+}
 break;
 }
 
+
 			case OBJ_TO_PRIMITIVE_OP:
 			case OBJ_TO_NUMBER_OP:
 			case OBJ_TO_STRING_OP: {
@@ -2596,7 +2778,7 @@ void Processor::innerRun() {
 			case NEW_ARRAY_OP: push(new(heap) JSArray(heap.managed())); break;
 			case NEW_REG_EXP_OP: invokeFunction(rt.createRegExpFunction, 1, 2); return;
 			case RETURN_OP:	ip = currentFrame->returnIP; popFrame(); return;
-			case THIS_OP: push(thisObject); break;
+case THIS_OP: push(thisObject != 0 ? Value(thisObject) : UNDEFINED_VALUE); break;
 			case VOID_OP: push(UNDEFINED_VALUE); break;
 			
 			case GEN_FUNC_OP: {
@@ -2615,6 +2797,20 @@ void Processor::innerRun() {
 				pop(1);
 				break;
 			}
+			case ADD_GETTER_OP: {
+				Object* o = sp[-1].getObject();
+				Accessor* acc = new(heap) Accessor(heap.managed(), sp[0].asFunction(), 0);
+				o->setOwnProperty(rt, constants[im], acc, ACCESSOR_FLAG);
+				pop(1);
+				break;
+			}
+			case ADD_SETTER_OP: {
+				Object* o = sp[-1].getObject();
+				Accessor* acc = new(heap) Accessor(heap.managed(), 0, sp[0].asFunction());
+				o->setOwnProperty(rt, constants[im], acc, ACCESSOR_FLAG);
+				pop(1);
+				break;
+			}
 
 			case PUSH_ELEMENTS_OP: {
 				Object* o = sp[-im].getObject();
@@ -3123,7 +3319,13 @@ const String* Compiler::identifier(bool required, bool allowKeywords) {
         if (!allowKeywords && findReservedKeyword(parsed.size(), parsed.begin()) >= 0) {
                 error(SYNTAX_ERROR, "Illegal use of keyword");
         }
-	return newHashedString(heap, parsed.begin(), parsed.end());
+        const String* name = newHashedString(heap, parsed.begin(), parsed.end());
+	#if (NUXJS_ES5)
+        if (code->isStrict() && name->isEqualTo(EVAL_STRING)) {
+                error(SYNTAX_ERROR, "Illegal use of eval or arguments in strict code");
+        }
+	#endif
+        return name;
 }
 
 static UInt32 unescapedMaxLength(const Char* p, const Char* e) {
@@ -3367,17 +3569,36 @@ Compiler::ExpressionResult Compiler::objectInitialiser() { // FIX : share stuff
 	
 	white();
 	while (!token("}", false)) {
+		bool handled = false;
 		const Char* b = p;
 		Value key = stringOrNumberConstant();
 		if (p == b) {
-			key = identifier(false, true);
-			if (key.equalsString(EMPTY_STRING)) {
+			const String* id = identifier(false, true);
+			if (id->isEqualTo(EMPTY_STRING)) {
 			error(SYNTAX_ERROR, "Expected property name");
 			}
+			white();
+				if ((id->isEqualTo(GET_STRING) || id->isEqualTo(SET_STRING)) && *p != ':') {
+				bool isGetter = id->isEqualTo(GET_STRING);
+				const Char* b2 = p;
+				Value accKey = stringOrNumberConstant();
+				if (p == b2) {
+				accKey = identifier(true, true);
+				}
+				white();
+				const String* funcName = accKey.toString(heap);
+				functionDefinition(funcName, funcName);
+				emitWithConstant(isGetter ? Processor::ADD_GETTER_OP : Processor::ADD_SETTER_OP, accKey);
+				handled = true;
+			} else {
+			key = id;
+			}
 			}
+		if (!handled) {
 				expectToken(":", true);
 				rvalueExpression(COMMA_PREC);
 				emitWithConstant(Processor::ADD_PROPERTY_OP, key);
+		}
 			if (token("}", true)) {
 				break;
 			}
@@ -3459,8 +3680,23 @@ bool Compiler::preOperate(ExpressionResult& xr, Precedence precedence) {
 				case ExpressionResult::PUSHED_PRIMITIVE: emit(Processor::POP_OP, 1); /* fall through */
 				case ExpressionResult::NONE:
 				case ExpressionResult::CONSTANT: xr = ExpressionResult(ExpressionResult::CONSTANT, true); break;
-				case ExpressionResult::LOCAL: xr = ExpressionResult(ExpressionResult::CONSTANT, false); break;
-				case ExpressionResult::NAMED: emitWithConstant(Processor::DELETE_NAMED_OP, xr.v); xr = ExpressionResult(ExpressionResult::PUSHED_PRIMITIVE); break;
+				case ExpressionResult::LOCAL:
+				#if (NUXJS_ES5)
+					if (code->isStrict()) {
+						error(SYNTAX_ERROR, "Deleting identifier in strict code");
+					}
+				#endif
+					xr = ExpressionResult(ExpressionResult::CONSTANT, false);
+					break;
+				case ExpressionResult::NAMED:
+				#if (NUXJS_ES5)
+					if (code->isStrict()) {
+						error(SYNTAX_ERROR, "Deleting identifier in strict code");
+					}
+				#endif
+					emitWithConstant(Processor::DELETE_NAMED_OP, xr.v);
+					xr = ExpressionResult(ExpressionResult::PUSHED_PRIMITIVE);
+					break;
 				case ExpressionResult::PROPERTY: emit(Processor::DELETE_OP); xr = ExpressionResult(ExpressionResult::PUSHED_PRIMITIVE); break;
 				default: assert(0);
 			}
@@ -3665,6 +3901,7 @@ bool Compiler::postOperate(ExpressionResult& xr, Precedence precedence) {
 void Compiler::functionDefinition(const String* functionName, const String* selfName) {
 	assert(functionName != 0);
 	Code* func = new(heap) Code(heap.managed(), code->constants);
+	func->strict = code->strict;
 	Compiler funcCompiler(heap.roots(), func, Compiler::FOR_FUNCTION, nestCounter);
 	try {
 		p = funcCompiler.compileFunction(p, e, functionName, selfName);
@@ -3819,6 +4056,11 @@ void Compiler::rvalueGroup() {
 
 // FIX : ok, this is serious mess
 Compiler::ExpressionResult Compiler::declareIdentifier(const String* name, bool func) {
+#if (NUXJS_ES5)
+	if (code->isStrict() && (name->isEqualTo(EVAL_STRING) || name->isEqualTo(ARGUMENTS_STRING))) {
+		error(SYNTAX_ERROR, "Illegal use of eval or arguments in strict code");
+	}
+#endif
 	ExpressionResult lxr(ExpressionResult::NAMED, name);
 	if (compilingFor != FOR_FUNCTION) {
 		CodeSection* previousSection = changeSection(&setupSection);
@@ -3974,6 +4216,11 @@ void Compiler::functionStatement() {
 }
 
 void Compiler::withStatement(SemanticScope* currentScope) {
+#if (NUXJS_ES5)
+	if (code->isStrict()) {
+		error(SYNTAX_ERROR, "\"with\" is not allowed in strict code");
+	}
+#endif
 	rvalueGroup();
 	emit(Processor::WITH_SCOPE_OP);
 	{
@@ -4461,6 +4708,38 @@ const Char* Compiler::compile(const Char* b, const Char* e) {
 	p = b;
 	this->e = e;
 	acceptInOperator = true;
+	const Char* directiveStart = p;
+	white();
+#if (NUXJS_ES5)
+	bool foundStrict = false;
+#endif
+#if (NUXJS_ES5)
+	while (p < e && (*p == '"' || *p == '\'')) {
+		Char q = *p++;
+		const Char* litStart = p;
+		while (p < e && *p != q) {
+			++p;
+		}
+		if (p >= e) {
+			break;
+		}
+		if (!foundStrict && p - litStart == 10 && strncmp(litStart, "use strict", 10) == 0) {
+			foundStrict = true;
+		}
+		++p;
+		white();
+		if (p < e && *p == ';') {
+			++p;
+			white();
+			continue;
+		}
+		break;
+	}
+	if (foundStrict) {
+		code->setStrict(true);
+	}
+#endif
+	p = directiveStart;
 	
 	// FIX : not 100% necessary now because we should always start with undefined on top of stack
 	if (compilingFor == FOR_EVAL) {
@@ -4496,6 +4775,7 @@ const Char* Compiler::compileFunction(const Char* b, const Char* e, const String
 	white();
 	Table& nameIndexes = code->nameIndexes;
 	Vector<const String*>& argumentNames = code->argumentNames;
+	bool hasDuplicateParameters = false;
 	while (!token(")", false)) {
 		if (eof()) {
 			error(SYNTAX_ERROR, argumentNames.size() == 0 ? "Expected ')'" : "Expected ',' or ')'");
@@ -4507,6 +4787,17 @@ const Char* Compiler::compileFunction(const Char* b, const Char* e, const String
 			white();
 		}
 			const String* name = identifier(true, false);
+		#if (NUXJS_ES5)
+			if (code->isStrict() && (name->isEqualTo(EVAL_STRING) || name->isEqualTo(ARGUMENTS_STRING))) {
+				error(SYNTAX_ERROR, "Illegal use of eval or arguments in strict code");
+			}
+		#endif
+		for (size_t i = 0; i < argumentNames.size(); ++i) {
+			if (argumentNames[i]->isEqualTo(*name)) {
+				hasDuplicateParameters = true;
+				break;
+			}
+		}
 		nameIndexes.update(nameIndexes.insert(name), static_cast<Int32>(argumentNames.size()));
 		argumentNames.push(name);
 		code->bloomSet |= name->createBloomCode();
@@ -4515,6 +4806,11 @@ const Char* Compiler::compileFunction(const Char* b, const Char* e, const String
 	expectToken("{", true);
 	compile(p, e); // FIX: ugly as it sets p and e again, although it doesn't hurt
 	expectToken("}", false);
+	#if (NUXJS_ES5)
+		if (code->strict && hasDuplicateParameters) {
+			error(SYNTAX_ERROR, "Duplicate parameter name not allowed in strict code");
+		}
+	#endif
 	code->name = functionName;
 	code->selfName = selfName;
 	code->source = String::concatenate(heap, String(heap.roots(), FUNCTION_SPACE, *functionName), String(heap.roots(), b, p));
@@ -4734,11 +5030,17 @@ struct Support {
 		if (argc >= 2) {
 			Object *o = argv[0].asObject();
 			if (o != 0) {
-				success = o->setOwnProperty(rt, argv[1], (argc >= 3 ? argv[2] : UNDEFINED_VALUE)
-						, (argc >= 4 && argv[3].toBool() ? READ_ONLY_FLAG : 0)
-						| (argc >= 5 && argv[4].toBool() ? DONT_ENUM_FLAG : 0)
-						| (argc >= 6 && argv[5].toBool() ? DONT_DELETE_FLAG : 0)
-						| EXISTS_FLAG);
+				Flags flags = (argc >= 4 && argv[3].toBool() ? READ_ONLY_FLAG : 0) |
+				              (argc >= 5 && argv[4].toBool() ? DONT_ENUM_FLAG : 0) |
+				              (argc >= 6 && argv[5].toBool() ? DONT_DELETE_FLAG : 0) | EXISTS_FLAG;
+				if (argc >= 7) {
+					Heap &heap = rt.getHeap();
+					Accessor *acc = new (heap)
+					    Accessor(heap.managed(), argv[6].asFunction(), (argc >= 8 ? argv[7].asFunction() : 0));
+					success = o->setOwnProperty(rt, argv[1], acc, flags | ACCESSOR_FLAG);
+				} else {
+					success = o->setOwnProperty(rt, argv[1], (argc >= 3 ? argv[2] : UNDEFINED_VALUE), flags);
+				}
 			}
 		}
 		return success;
@@ -5058,21 +5360,28 @@ Var Runtime::eval(const String& expression) {
 	return runUntilReturn(processor);
 }
 
-Code* Runtime::compileEvalCode(const String* expression) {
-	const Table::Bucket* bucket = evalCodeCache.lookup(expression);
+Code* Runtime::compileEvalCode(const String* expression, bool strict) {
+	#if !(NUXJS_ES5)
+	strict = false;
+#endif
+	const Table::Bucket* bucket = (strict ? 0 : evalCodeCache.lookup(expression));
 	if (bucket != 0) {
 		Object* o = bucket->getValue().getObject();
 		assert(dynamic_cast<Code*>(o) != 0);
 		return reinterpret_cast<Code*>(o);
 	} else {
 		Code* code = new(heap) Code(heap.managed());
+	#if (NUXJS_ES5)
+		if (strict) { code->setStrict(true); }
+	#endif
 		Compiler compiler(heap.roots(), code, Compiler::FOR_EVAL);
 		compiler.compile(*expression);
-		evalCodeCache.update(evalCodeCache.insert(expression), code);
+		if (!strict) { evalCodeCache.update(evalCodeCache.insert(expression), code); }
 		return code;
 	}
 }
 
+
 Code* Runtime::compileGlobalCode(const String& source, const String* filename) {
 	Code* code = new(heap) Code(heap.managed());
 	Compiler compiler(heap.roots(), code, Compiler::FOR_GLOBAL);
@@ -5094,6 +5403,9 @@ void Runtime::fetchFunction(const Object* supportObject, const char* name, Funct
 }
 
 extern const char* STDLIB_JS;
+#if (NUXJS_ES5)
+extern const char* STDLIB_ES5_JS;
+#endif
 
 double Runtime::getCurrentEpochTime() {
 	std::time_t t;
@@ -5126,6 +5438,7 @@ void Runtime::setupStandardLibrary() {
 	supportObject->setOwnProperty(*this, &UNDEFINED_STRING, UNDEFINED_VALUE);
 	supportObject->setOwnProperty(*this, &NAN_STRING, NAN_VALUE);
 	supportObject->setOwnProperty(*this, &INFINITY_STRING, INFINITY_VALUE);
+
 	supportObject->setOwnProperty(*this, &MAX_NUMBER_STRING, std::numeric_limits<double>::max());
 	supportObject->setOwnProperty(*this, &MIN_NUMBER_STRING, std::numeric_limits<double>::denorm_min());
 
@@ -5138,8 +5451,12 @@ void Runtime::setupStandardLibrary() {
 	}
 	
 	const Var func = eval(*String::allocate(heap, STDLIB_JS));
-	Value argv[1] = { protectedSupportObject };
-	call(func, 1, argv);
+	Value argv[2] = { protectedSupportObject, UNDEFINED_VALUE };
+#if (NUXJS_ES5)
+	const Var es5(*this, String::allocate(heap, STDLIB_ES5_JS));
+	argv[1] = es5;
+#endif
+	call(func, 2, argv);
 	
 	fetchFunction(supportObject, "toPrimitive", toPrimitiveFunctions + 0);
 	fetchFunction(supportObject, "toPrimitiveNumber", toPrimitiveFunctions + 1);
diff --git a/src/NuXJS.h b/src/NuXJS.h
index 98904d6..a3750a0 100644
--- a/src/NuXJS.h
+++ b/src/NuXJS.h
@@ -24,6 +24,17 @@
 #ifndef NuXJS_h
 #define NuXJS_h
 
+// ---------------------------------------------------------------------------
+// ES version toggle
+//
+// NUXJS_ES5 controls ES5 features and semantics. Keep default at 0 so that
+// building without an explicit -DNUXJS_ES5=1 matches legacy ES3 behavior from
+// the main branch exactly.
+// ---------------------------------------------------------------------------
+#ifndef NUXJS_ES5
+#define NUXJS_ES5 1
+#endif
+
 #include "assert.h"
 #include <algorithm>
 #include <string>
@@ -447,11 +458,13 @@ const Flags READ_ONLY_FLAG = 2;
 const Flags DONT_ENUM_FLAG = 4;
 const Flags DONT_DELETE_FLAG = 8;
 const Flags INDEX_TYPE_FLAG = 16;	///< internal index type, only used as an optimization for faster name -> local index lookup
+const Flags ACCESSOR_FLAG = 32;       ///< property stores accessor pair
 const Flags STANDARD_FLAGS = EXISTS_FLAG;	///< use with setOwnProperty()
 const Flags HIDDEN_CONST_FLAGS = READ_ONLY_FLAG | DONT_ENUM_FLAG | DONT_DELETE_FLAG | EXISTS_FLAG;
 const Flags NONEXISTENT = 0;		///< use with getOwnProperty() to check for existence, e.g. getOwnProperty(o, k, v) != NONEXISTENT
 const UInt32 TABLE_BUILT_IN_N = 3; ///< 1 << 3 == 8
 
+class Accessor;
 /**
 	Table implements a hash table for storing object properties. It provides fast lookup and is used internally by JS
 	objects.
@@ -538,13 +551,16 @@ class Object : public GCItem {
 		virtual Object* getPrototype(Runtime& rt) const;		///< Default returns the Object prototype.
 
 		virtual Flags getOwnProperty(Runtime& rt, const Value& key, Value* v) const;								///< Don't touch v if you return NONEXISTENT. Default returns NONEXISTENT.
+		virtual bool setOwnProperty(Runtime& rt, const String* key, const Value& v, Flags flags = STANDARD_FLAGS);	///< Insert a new or update an existing property. Return false if not possible (e.g. read-only property already exists). Default returns false.
 		virtual bool setOwnProperty(Runtime& rt, const Value& key, const Value& v, Flags flags = STANDARD_FLAGS);	///< Insert a new or update an existing property. Return false if not possible (e.g. read-only property already exists). Default returns false.
 		virtual bool updateOwnProperty(Runtime& rt, const Value& key, const Value& v);								///< Update existing property. Return false if it doesn't exist or can't be updated (e.g. read-only property exists). Can be overriden for optimization. (Default implementation checks existence with hasOwnProperty() first.)
 		virtual bool deleteOwnProperty(Runtime& rt, const Value& key);												///< Default returns false.
 		virtual Enumerator* getOwnPropertyEnumerator(Runtime& rt) const;											///< Default returns an empty enumerator.
 
 		Flags getProperty(Runtime& rt, const Value& key, Value* v) const; 	///< Searches prototype chain.
+		Flags getProperty(Runtime& rt, Processor& processor, const Value& key, Value* v) const;
 		bool setProperty(Runtime& rt, const Value& key, const Value& v); 	///< First tries updateOwnProperty(). If that fails, checks prototype chain for read-only property with the same name and returns false if found. Otherwise attempts to insert a new property with setOwnProperty() and returns its outcome.
+		bool setProperty(Runtime& rt, Processor& processor, const Value& key, const Value& v);
 		bool isOwnPropertyEnumerable(Runtime& rt, const Value& key) const;
 		bool hasOwnProperty(Runtime& rt, const Value& key) const; 			///< Checks via getOwnProperty().
 		bool hasProperty(Runtime& rt, const Value& key) const;				///< Checks via getProperty().
@@ -707,6 +723,7 @@ class JSObject : public Object, public Table {
 		JSObject(GCList& gcList, Object* prototype);
 		virtual Object* getPrototype(Runtime& rt) const;
 		virtual Flags getOwnProperty(Runtime& rt, const Value& key, Value* v) const;
+		virtual bool setOwnProperty(Runtime& rt, const String* key, const Value& v, Flags flags = STANDARD_FLAGS);
 		virtual bool setOwnProperty(Runtime& rt, const Value& key, const Value& v, Flags flags = STANDARD_FLAGS);
 		virtual bool updateOwnProperty(Runtime& rt, const Value& key, const Value& v);
 		virtual bool deleteOwnProperty(Runtime& rt, const Value& key);
@@ -742,6 +759,7 @@ template<class SUPER> class LazyJSObject : public SUPER {
 		typedef SUPER super;
 		LazyJSObject(GCList& gcList) : super(gcList), completeObject(0) { }
 		virtual Flags getOwnProperty(Runtime& rt, const Value& key, Value* v) const;
+		virtual bool setOwnProperty(Runtime& rt, const String* key, const Value& v, Flags flags = STANDARD_FLAGS);
 		virtual bool setOwnProperty(Runtime& rt, const Value& key, const Value& v, Flags flags = STANDARD_FLAGS);
 		virtual bool deleteOwnProperty(Runtime& rt, const Value& key);
 		virtual Enumerator* getOwnPropertyEnumerator(Runtime& rt) const;
@@ -773,6 +791,7 @@ class JSArray : public LazyJSObject<Object> {
 		virtual Object* getPrototype(Runtime& rt) const;
 		// FIX : toString too?
 		virtual Flags getOwnProperty(Runtime& rt, const Value& key, Value* v) const;
+		virtual bool setOwnProperty(Runtime& rt, const String* key, const Value& v, Flags flags = STANDARD_FLAGS);
 		virtual bool setOwnProperty(Runtime& rt, const Value& key, const Value& v, Flags flags = STANDARD_FLAGS);
 		virtual bool updateOwnProperty(Runtime& rt, const Value& key, const Value& v);
 		virtual bool deleteOwnProperty(Runtime& rt, const Value& key);
@@ -833,6 +852,8 @@ class Code : public Object {
 		const String* getName() const { return name; }
 		const String* getSource() const { return source; }
 		UInt32 getMaxStackDepth() const { return maxStackDepth; }
+		bool isStrict() const { return strict; }
+		void setStrict(bool v) { strict = v; }
 		UInt32 calcLocalsSize(UInt32 argc) const { return getVarsCount() + std::max(getArgumentsCount(), argc); }
 
 	protected:
@@ -846,6 +867,7 @@ class Code : public Object {
 		const String* source;
 		UInt32 bloomSet;							///< Bloom bits of all local variables, arguments (+ self name and "arguments"). For faster scope resolution.
 		UInt32 maxStackDepth;
+		bool strict;
 
 		virtual void gcMarkReferences(Heap& heap) const {
 			gcMark(heap, constants);
@@ -883,6 +905,20 @@ class Function : public Object {
 		Function(GCList& gcList) : super(gcList) { }
 };
 
+class Accessor : public Object {
+	public:
+		Accessor(GCList& gcList, Function* g, Function* s)
+			: Object(gcList), getter(g), setter(s) { }
+		Function* getter;
+		Function* setter;
+	protected:
+		virtual void gcMarkReferences(Heap& heap) const {
+			gcMark(heap, getter);
+			gcMark(heap, setter);
+			super::gcMarkReferences(heap);
+		}
+};
+
 typedef Value (*NativeFunction)(Runtime&, Processor&, UInt32, const Value*, Object*);
 
 // FIX : overkill?
@@ -983,6 +1019,7 @@ class Error : public LazyJSObject<Object> {
 		virtual const String* toString(Heap& heap) const;
 		virtual Value getInternalValue(Heap& heap) const; // error type name
 		virtual Object* getPrototype(Runtime& rt) const;
+		virtual bool setOwnProperty(Runtime& rt, const String* key, const Value& v, Flags flags = STANDARD_FLAGS);
 		virtual bool setOwnProperty(Runtime& rt, const Value& key, const Value& v, Flags flags = STANDARD_FLAGS);
 		virtual bool deleteOwnProperty(Runtime& rt, const Value& key);
 		ErrorType getErrorType() const;
@@ -1007,12 +1044,14 @@ class FunctionScope;
 class Arguments : public LazyJSObject<Object> {
 	public:
 		typedef LazyJSObject<Object> super;
+		friend class FunctionScope;
 
         Arguments(GCList& gcList, const FunctionScope* scope, UInt32 argumentsCount);
 		virtual const String* getClassName() const;	// &A_RGUMENTS_STRING
 		virtual const String* toString(Heap& heap) const;
 		virtual Object* getPrototype(Runtime& rt) const;
 		virtual Flags getOwnProperty(Runtime& rt, const Value& key, Value* v) const;
+		virtual bool setOwnProperty(Runtime& rt, const String* key, const Value& v, Flags flags = STANDARD_FLAGS);
 		virtual bool setOwnProperty(Runtime& rt, const Value& key, const Value& v, Flags flags = STANDARD_FLAGS);
 		virtual bool deleteOwnProperty(Runtime& rt, const Value& key);
 		virtual Enumerator* getOwnPropertyEnumerator(Runtime& rt) const;
@@ -1027,6 +1066,7 @@ class Arguments : public LazyJSObject<Object> {
 		UInt32 const argumentsCount;
 		Vector<Byte> deletedArguments;
 		Vector<Value> values;	// Contains copied values after the Argument has been detached from its closure.
+		FunctionScope* owner;	// Weak reference to owning FunctionScope for cleanup.
 
 		/**
 			Notice that we do not mark the scope reference, thus creating a "weak" reference that is handled by
@@ -1133,7 +1173,7 @@ class Runtime : public GCItem {
 		JSArray* newJSArray(UInt32 initialLength = 0) const;	///< Convenience routine for `new(heap) JSArray(heap.managed(), initialLength)`
 		const String* newStringConstant(const char* s);
 
-		Code* compileEvalCode(const String* expression);
+		Code* compileEvalCode(const String* expression, bool strict = false);
 		Code* compileGlobalCode(const String& source, const String* filename = 0);
 
 		Var getGlobalsVar();							///< Convenience routine for `Var(rt, rt.getGlobalObject())`
@@ -1338,14 +1378,42 @@ class Property : public AccessorBase {
 	friend class AccessorBase;
 
   public:
-		template<typename T> const Property& operator=(const T& v) const { object->setProperty(rt, key, Var(rt, v)); return *this; }
-		template<typename T> const Property& operator+=(const T& r) const { object->setProperty(rt, key, get().add(rt.getHeap(), makeValue(r))); return *this; }
+	template <typename T> const Property &operator=(const T &v) const {
+		Value current;
+		Flags flags = object->getProperty(rt, key, &current);
+		if (flags != NONEXISTENT && (flags & ACCESSOR_FLAG) != 0) {
+			Accessor *acc = static_cast<Accessor *>(current.asObject());
+			Function *setter = (acc != 0 ? acc->setter : 0);
+			if (setter != 0) {
+				Value arg = Var(rt, v);
+				rt.call(setter, 1, &arg, object);
+				return *this;
+			}
+		}
+		object->setProperty(rt, key, Var(rt, v));
+		return *this;
+	}
+	template <typename T> const Property &operator+=(const T &r) const {
+		object->setProperty(rt, key, get().add(rt.getHeap(), makeValue(r)));
+		return *this;
+	}
 
   protected:
 	typedef AccessorBase super;
 	Property(Runtime &rt, Object *object, const Var &key) : super(rt), object(object), key(key) {}
-		virtual Value get() const { Value v(UNDEFINED_VALUE); object->getProperty(rt, key, &v); return v; }
-		virtual Var call(int argc, const Value* argv) const { return rt.call(*this, argc, argv, object); }
+	virtual Value get() const {
+		Value v(UNDEFINED_VALUE);
+		Flags flags = object->getProperty(rt, key, &v);
+		if (flags != NONEXISTENT && (flags & ACCESSOR_FLAG) != 0) {
+			Accessor *acc = static_cast<Accessor *>(v.asObject());
+			Function *getter = (acc != 0 ? acc->getter : 0);
+			return (getter != 0 ? rt.call(getter, 0, 0, object) : UNDEFINED_VALUE);
+		}
+		return v;
+	}
+	virtual Var call(int argc, const Value *argv) const {
+		return rt.call(*this, argc, argv, object);
+	}
 	Object *const object;
 	const Var key;
 };
@@ -1531,6 +1599,8 @@ class Processor : public GCItem {
 			, SET_PROPERTY_OP								// stack: object, name, value -> value
 			, SET_PROPERTY_POP_OP							// stack: object, name, value ->
 			, ADD_PROPERTY_OP								// operand: const_index (name), stack: object, value -> object
+							, ADD_GETTER_OP						// operand: const_index(name), stack: object, function -> object
+							, ADD_SETTER_OP						// operand: const_index(name), stack: object, function -> object
 			, PUSH_ELEMENTS_OP								// operand: count, stack: object, count * elements ... -> object
 			, OBJ_TO_PRIMITIVE_OP							// stack: value -> primitive_value (no preference)	// these three must be in this exact order
 			, OBJ_TO_NUMBER_OP								// stack: value -> primitive_value (number preferred)
@@ -1585,7 +1655,12 @@ class Processor : public GCItem {
 		};
 	
 		struct OpcodeInfo {
-			enum { TERMINAL = 1, POP_OPERAND = 2, POP_ON_BRANCH = 4, NO_POP_ON_BRANCH = 8 };
+			enum {
+				TERMINAL = 1,			/// instruction ends current basic block
+				POP_OPERAND = 2,	/// pop `operand` values after execution
+				POP_ON_BRANCH = 4,	/// branch path pops the top of stack
+				NO_POP_ON_BRANCH = 8	/// branch path keeps the top of stack
+			};
 			Opcode opcode;
 			const char* mnemonic;
 			Int32 stackUse;
@@ -1600,12 +1675,13 @@ class Processor : public GCItem {
 		Processor(Runtime& rt);
 		void invokeFunction(Function* f, Int32 argc, const Value* argv, Object* thisObject = 0);
 		void enterGlobalCode(const Code* code);
-		void enterEvalCode(const Code* code, bool local = false);
+		void enterEvalCode(const Code* code, bool direct = false);
 		void enterFunctionCode(JSFunction* func, UInt32 argc, const Value* argv, Object* thisObject = 0);
 		void throwVirtualException(const Value& exception);
 		void error(ErrorType errorType, const String* message = 0);
 		bool run(Int32 maxCycles);
 		Value getResult() const;	// make sure you've called run() until it returns false before calling this
+		bool isCurrentStrict() const { return currentFrame != 0 && currentFrame->code->isStrict(); }
 
 	protected:
 		struct Frame : public GCItem {
diff --git a/src/stdlib.js b/src/stdlib.js
index 2c8acff..d0e1415 100644
--- a/src/stdlib.js
+++ b/src/stdlib.js
@@ -61,7 +61,7 @@
 	}
 */
 
-(function(support) {
+(function(support, es5) {
 
 var globals = this;
 var unconstructable = support.distinctConstructor; // these are the same now, but not guaranteed in the future
@@ -130,7 +130,7 @@ function uint32(v) { return int(v) >>> 0; }
 // TODO : what a waste of cycles, could be a simple OBJ_TO_STRING, problem with ''+s is that it uses OBJ_TO_NUMBER which only affects the priority of toString vs valueOf... so subtle!
 function str(o) { return '' + (isPrimitive(o) ? o : support.toPrimitiveString(o)) }
 
-function defineProperties(object, attribs, props) {
+function defProps(object, attribs, props) {
 	var ro = attribs.readOnly, de = attribs.dontEnum, dd = attribs.dontDelete;
 	for (var p in props) support.defineProperty(object, p, props[p], ro, de, dd);
 	return object
@@ -217,8 +217,8 @@ var Object = function Object(v) {
 		case "string": return new String(v);
 	}
 };
-defineProperties(Object, { dontEnum: true, readOnly: true, dontDelete: true }, { prototype: support.prototypes.Object });
-defineProperties(Object.prototype, { dontEnum: true }, {
+defProps(Object, { dontEnum: true, readOnly: true, dontDelete: true }, { prototype: support.prototypes.Object });
+defProps(Object.prototype, { dontEnum: true }, {
 	constructor: Object,
 	valueOf: unconstructable(function valueOf() { return this }),
 	toLocaleString: unconstructable(function toLocaleString() { return this.toString() }),
@@ -248,8 +248,8 @@ var Function = function Function(body) {
 	if (n >= 0) src += argv[n];
 	return support.compileFunction(src + "\n}", "anonymous")
 };
-defineProperties(Function, { dontEnum: true, readOnly: true, dontDelete: true }, { prototype: support.prototypes.Function });
-defineProperties(Function.prototype, { dontEnum: true }, {
+defProps(Function, { dontEnum: true, readOnly: true, dontDelete: true }, { prototype: support.prototypes.Function });
+defProps(Function.prototype, { dontEnum: true }, {
 	constructor: Function,
 	apply: unconstructable(function apply(thisArg, argArray) { // FIX : <- 100% native version in the future I think
 		var theClass;
@@ -275,8 +275,8 @@ var Boolean = support.distinctConstructor(function Boolean(v) {
 }, function Boolean(v) {
 	return support.createWrapper("Boolean", !!v, support.prototypes.Boolean);
 });
-defineProperties(Boolean, { dontEnum: true, readOnly: true, dontDelete: true }, { prototype: support.prototypes.Boolean });
-defineProperties(Boolean.prototype, { dontEnum: true }, {
+defProps(Boolean, { dontEnum: true, readOnly: true, dontDelete: true }, { prototype: support.prototypes.Boolean });
+defProps(Boolean.prototype, { dontEnum: true }, {
 	constructor: Boolean,
 	valueOf: unconstructable(function valueOf() {
 		checkClass(this, "Boolean", "valueOf");
@@ -300,15 +300,15 @@ var Number = support.distinctConstructor(function Number(v) {
 }, function Number(v) {
 	return support.createWrapper("Number", arguments.length ? +v : 0, support.prototypes.Number);
 });
-defineProperties(Number, { dontEnum: true, readOnly: true, dontDelete: true }, { prototype: support.prototypes.Number });
-defineProperties(Number, { dontEnum: true, readOnly: true, dontDelete: true }, {
+defProps(Number, { dontEnum: true, readOnly: true, dontDelete: true }, { prototype: support.prototypes.Number });
+defProps(Number, { dontEnum: true, readOnly: true, dontDelete: true }, {
 	MAX_VALUE: support.maxNumber,
 	MIN_VALUE: support.minNumber,
 	NaN: $NaN,
 	NEGATIVE_INFINITY: -$Infinity,
 	POSITIVE_INFINITY: $Infinity
 });
-defineProperties(Number.prototype, { dontEnum: true }, {
+defProps(Number.prototype, { dontEnum: true }, {
 	constructor: Number,
 	valueOf: unconstructable(function valueOf() { return getInternalNumber(this, "valueOf") }),
 	toLocaleString: Object.prototype.toLocaleString,
@@ -426,12 +426,12 @@ var String = support.distinctConstructor(function String(v) {
 	return (arguments.length ? str(v) : '');
 }, function String(v) {
 	var s;
-	return defineProperties(
+	return defProps(
 			support.createWrapper("String", (s = (arguments.length ? str(v) : '')), support.prototypes.String)
 			,  { readOnly: true, dontEnum: true, dontDelete: true }, { length: s.length });
 });
-defineProperties(String, { dontEnum: true, readOnly: true, dontDelete: true }, { prototype: support.prototypes.String });
-defineProperties(String, { dontEnum: true }, {
+defProps(String, { dontEnum: true, readOnly: true, dontDelete: true }, { prototype: support.prototypes.String });
+defProps(String, { dontEnum: true }, {
 	fromCharCode: unconstructable(function fromCharCode(v) {
 		var argc, argv;
 		if ((argc = (argv = arguments).length) === 1) return support.fromCharCode(v & 65535);
@@ -439,7 +439,7 @@ defineProperties(String, { dontEnum: true }, {
 		return s;
 	})
 });
-defineProperties(String.prototype, { dontEnum: true }, {
+defProps(String.prototype, { dontEnum: true }, {
 	constructor: String,
 	charAt: unconstructable(function charAt(pos) {
 		var s;
@@ -611,8 +611,8 @@ var Array = function Array(v) {
 	}
 	return a
 };
-defineProperties(Array, { dontEnum: true, readOnly: true, dontDelete: true }, { prototype: support.prototypes.Array });
-defineProperties(Array.prototype, { dontEnum: true }, {
+defProps(Array, { dontEnum: true, readOnly: true, dontDelete: true }, { prototype: support.prototypes.Array });
+defProps(Array.prototype, { dontEnum: true }, {
 	constructor: Array,
 	concat: unconstructable(function concat(item1) {
 		var a = [ ], argv, argc = (argv = arguments).length, n = 0, v = this;
@@ -873,8 +873,8 @@ var parseDate, Date = support.distinctConstructor(function Date() {
 	return support.createWrapper("Date", v, support.prototypes.Date);
 });
 
-defineProperties(Date, { dontEnum: true, readOnly: true, dontDelete: true }, { prototype: support.prototypes.Date });
-defineProperties(Date, { dontEnum: true }, {
+defProps(Date, { dontEnum: true, readOnly: true, dontDelete: true }, { prototype: support.prototypes.Date });
+defProps(Date, { dontEnum: true }, {
 	parse: unconstructable(parseDate = function parse(s) {
 		var z, y, i, ch, tz, tzh, tzm, i = 0;
 		function readPart(len) {
@@ -907,7 +907,7 @@ defineProperties(Date, { dontEnum: true }, {
 	})
 });
 
-defineProperties(Date.prototype, { dontEnum: true }, {
+defProps(Date.prototype, { dontEnum: true }, {
 	constructor: Date,
 	toISOString: unconstructable(function toISOString() {
 		var s;
@@ -1514,13 +1514,13 @@ var RegExp = support.distinctConstructor(function RegExp(pattern, flags) {
 	if (!(func = regExpCache[key = pattern + ',' + template.ignoreCase + ',' + template.multiline]))
 		regExpCache[key] = func = evalThere(compileRegExp(pattern, template.ignoreCase, template.multiline));
 	var re = support.createWrapper("RegExp", func, regExpPrototype);
-	defineProperties(re, { dontEnum: true, readOnly: true, dontDelete: true }, template);
-	defineProperties(re, { dontEnum: true, dontDelete: true }, { lastIndex: 0 });
+	defProps(re, { dontEnum: true, readOnly: true, dontDelete: true }, template);
+	defProps(re, { dontEnum: true, dontDelete: true }, { lastIndex: 0 });
 	return re;
 });
 
-defineProperties(RegExp, { dontEnum: true, readOnly: true, dontDelete: true }, { prototype: regExpPrototype = RegExp.prototype });
-defineProperties(RegExp.prototype, { dontEnum: true }, {
+defProps(RegExp, { dontEnum: true, readOnly: true, dontDelete: true }, { prototype: regExpPrototype = RegExp.prototype });
+defProps(RegExp.prototype, { dontEnum: true }, {
 	exec: unconstructable(function exec(string) { checkClass(this, "RegExp", "exec"); return regExpExecMethod(this, string); }),
 	test: unconstructable(function test(string) { checkClass(this, "RegExp", "test"); return execRegExp(this, string) !== void 0; }),
 	toString: unconstructable(function toString() {
@@ -1531,7 +1531,7 @@ defineProperties(RegExp.prototype, { dontEnum: true }, {
 
 /* --- Set up globals --- */
 
-defineProperties(globals, { dontEnum: true }, {
+defProps(globals, { dontEnum: true }, {
 	Array: Array,
 	Boolean: Boolean,
 	Date: Date,
@@ -1566,13 +1566,13 @@ defineProperties(globals, { dontEnum: true }, {
 	})
 });
 
-defineProperties(globals, { dontEnum: true, dontDelete: true }, {
+defProps(globals, { dontEnum: true, dontDelete: true }, {
 	NaN: $NaN, Infinity: $Infinity, undefined: support.undefined
 });
 
 /* --- Math --- */
 
-defineProperties(Math, { readOnly: true, dontEnum: true, dontDelete: true }, {
+defProps(Math, { readOnly: true, dontEnum: true, dontDelete: true }, {
 	E: 2.718281828459045235360,
 	LN10: 2.302585092994045684018,
 	LN2: 0.6931471805599453094172,
@@ -1583,7 +1583,7 @@ defineProperties(Math, { readOnly: true, dontEnum: true, dontDelete: true }, {
 	SQRT2: 1.414213562373095048802
 });
 
-defineProperties(Math, { dontEnum: true }, {
+defProps(Math, { dontEnum: true }, {
 	abs: unconstructable(abs = function abs(v) { return ((v = +v) < 0 ? -v : v) }),
 	acos: unconstructable(function acos(v) { return support.acos(+v) }),
 	asin: unconstructable(function asin(v) { return support.asin(+v) }),
@@ -1623,12 +1623,12 @@ function createErrorConstructor(name, prototype) {
 		support.defineProperty(globals, n = ERROR_NAMES[i], c = createErrorConstructor(n, p = support.prototypes[n])
 				, false, true, false);
 		c.name = n;	// Notice: from ES6 and upwards "name" is read-only (and you would have to delete it to modify here), but it isn't in this implementation
-		defineProperties(c, { dontEnum: true, readOnly: true, dontDelete: true }, { prototype: p });
-		defineProperties(p, { dontEnum: true }, { constructor: c });
+		defProps(c, { dontEnum: true, readOnly: true, dontDelete: true }, { prototype: p });
+		defProps(p, { dontEnum: true }, { constructor: c });
 		p.name = n;
 	}
 
-	defineProperties(Error.prototype, { dontEnum: true }, {
+	defProps(Error.prototype, { dontEnum: true }, {
 		message: '',
 		toString: unconstructable(function toString() {
 			return (this.name === void 0 ? "Error" : this.name) + (this.message ? (": " + this.message) : '');
@@ -1648,7 +1648,7 @@ var JSON_ESCAPE_SEQUENCES = { '\\': "\\\\", '"': "\\\"", '\b': "\\b", '\f': "\\f
 var MAX_JSON_DEPTH = 61;	// compiler internal recursion limit is 64 (as of 20180610), we must stick under this for eval() to work and 61 gives us enough margin
 
 // TODO : use StringBuilder?
-defineProperties(JSON, { dontEnum: true }, {
+defProps(JSON, { dontEnum: true }, {
 	stringify: unconstructable(function stringify(val, replacer, space) {
 		var stack = [ ], replacerFunction = (typeof replacer === "function" ? replacer : null), gap = '', includeProps;
 
@@ -1832,17 +1832,26 @@ defineProperties(JSON, { dontEnum: true }, {
 	})
 });
 
-defineProperties(Array, { dontEnum: true }, {
+defProps(Array, { dontEnum: true }, {
 	isArray: unconstructable(function isArray(o) { return $getInternalProperty(o, "class") === "Array"; })
 });
 
-defineProperties(Object, { dontEnum: true }, {
+defProps(Object, { dontEnum: true }, {
 	defineProperty: unconstructable(function defineProperty(o, p, d) {
 		support.defineProperty(o, str(p), d.value, !d.writable, !d.enumerable, !d.configurable);
 	}),
 	getPrototypeOf: unconstructable(function getPrototypeOf(o) { return $getInternalProperty(o, "prototype"); })
 });
 
+// Evaluate ES5 add-ons only when explicitly enabled; bracket form avoids minifier renaming
+if (es5) {
+	// At the time of this call, the "recognized" direct eval function is support.eval, not support.evalFunction
+	// support.evalFunction will be recognized after stdlib is setup
+	eval = support.eval;
+	eval(es5);
+	eval = support.evalFunction;
+}
+
 if ($NaN.toString() !== "NaN") throw Error("Internal self test failed. Check C++ compiler options concerning IEEE 754 compliance.");
 
 })
diff --git a/src/stdlibES5.js b/src/stdlibES5.js
new file mode 100644
index 0000000..0b34bec
--- /dev/null
+++ b/src/stdlibES5.js
@@ -0,0 +1,171 @@
+/*
+    ES5 additions to the standard library.
+    This file is "included" with an eval at the end of stdlib.js if ES5 support is enabled.
+
+    @preserve: trim,trimLeft,trimRight,forEach,map,filter,reduce,reduceRight,every,some
+    @preserve: get,set
+    @preserve: now,create,keys,bind
+	@preserve: defineProperties
+*/
+
+// Use helpers provided by the base stdlib: defProps, int, uint32, str
+
+// String.prototype.trim*
+defProps(String.prototype, { dontEnum: true }, {
+	trimLeft: function trimLeft() {
+		var s = str(this), i = 0, j = s.length, c;
+		for (; i < j; ++i) {
+			c = s.charCodeAt(i);
+			if (c !== 0x20 && (c < 0x09 || c > 0x0D) && c !== 0xA0 && c !== 0x2028 && c !== 0x2029 && c !== 0xFEFF) break;
+		}
+		return s.substring(i, j);
+	},
+	trimRight: function trimRight() {
+		var s = str(this), j = s.length, c;
+		for (; j > 0; --j) {
+			c = s.charCodeAt(j - 1);
+			if (c !== 0x20 && (c < 0x09 || c > 0x0D) && c !== 0xA0 && c !== 0x2028 && c !== 0x2029 && c !== 0xFEFF) break;
+		}
+		return s.substring(0, j);
+	},
+	trim: function trim() {
+		var s = str(this), i = 0, j = s.length, c;
+		for (; i < j; ++i) {
+			c = s.charCodeAt(i);
+			if (c !== 0x20 && (c < 0x09 || c > 0x0D) && c !== 0xA0 && c !== 0x2028 && c !== 0x2029 && c !== 0xFEFF) break;
+		}
+		for (; j > i; --j) {
+			c = s.charCodeAt(j - 1);
+			if (c !== 0x20 && (c < 0x09 || c > 0x0D) && c !== 0xA0 && c !== 0x2028 && c !== 0x2029 && c !== 0xFEFF) break;
+		}
+		return s.substring(i, j);
+	}
+});
+
+// Array.prototype iteration and search methods
+defProps(Array.prototype, { dontEnum: true }, {
+	forEach: function forEach(callbackfn) {
+		var o = Object(this), len = uint32(o.length), t = arguments[1];
+		if (typeof callbackfn !== "function") throw TypeError();
+		for (var k = 0; k < len; ++k) if (k in o) callbackfn.call(t, o[k], k, o);
+	},
+	map: function map(callbackfn) {
+		var o = Object(this), len = uint32(o.length), t = arguments[1], a = new Array(len);
+		if (typeof callbackfn !== "function") throw TypeError();
+		for (var k = 0; k < len; ++k) if (k in o) a[k] = callbackfn.call(t, o[k], k, o);
+		return a;
+	},
+	filter: function filter(callbackfn) {
+		var o = Object(this), len = uint32(o.length), t = arguments[1], a = [], to = 0;
+		if (typeof callbackfn !== "function") throw TypeError();
+		for (var k = 0; k < len; ++k) if (k in o) { var v = o[k]; if (callbackfn.call(t, v, k, o)) a[to++] = v; }
+		a.length = to;
+		return a;
+	},
+	indexOf: function indexOf(searchElement) {
+		var len = uint32(this.length), i = arguments[1];
+		if (len === 0) return -1;
+		i = int(i);
+		if (i < 0) { i += len; if (i < 0) i = 0; }
+		for (; i < len; ++i) if (i in this && this[i] === searchElement) return i;
+		return -1;
+	},
+	lastIndexOf: function lastIndexOf(searchElement) {
+		var len = uint32(this.length), i = arguments[1];
+		if (len === 0) return -1;
+		if (i === void 0) i = len - 1; else { i = int(i); if (i < 0) i += len; if (i >= len) i = len - 1; }
+		for (; i >= 0; --i) if (i in this && this[i] === searchElement) return i;
+		return -1;
+	},
+	reduce: function reduce(callbackfn) {
+		var o = Object(this), len = uint32(o.length), k = 0, acc;
+		if (typeof callbackfn !== "function") throw TypeError();
+		if (arguments.length > 1) acc = arguments[1]; else {
+			while (k < len && !(k in o)) ++k;
+			if (k >= len) throw TypeError();
+			acc = o[k++];
+		}
+		for (; k < len; ++k) if (k in o) acc = callbackfn.call(void 0, acc, o[k], k, o);
+		return acc;
+	},
+	reduceRight: function reduceRight(callbackfn) {
+		var o = Object(this), len = uint32(o.length), k = len - 1, acc;
+		if (typeof callbackfn !== "function") throw TypeError();
+		if (arguments.length > 1) acc = arguments[1]; else {
+			while (k >= 0 && !(k in o)) --k;
+			if (k < 0) throw TypeError();
+			acc = o[k--];
+		}
+		for (; k >= 0; --k) if (k in o) acc = callbackfn.call(void 0, acc, o[k], k, o);
+		return acc;
+	},
+	every: function every(callbackfn) {
+		var o = Object(this), len = uint32(o.length), t = arguments[1];
+		if (typeof callbackfn !== "function") throw TypeError();
+		for (var k = 0; k < len; ++k) if (k in o && !callbackfn.call(t, o[k], k, o)) return false;
+		return true;
+	},
+	some: function some(callbackfn) {
+		var o = Object(this), len = uint32(o.length), t = arguments[1];
+		if (typeof callbackfn !== "function") throw TypeError();
+		for (var k = 0; k < len; ++k) if (k in o && callbackfn.call(t, o[k], k, o)) return true;
+		return false;
+	}
+});
+
+// Date.now
+defProps(Date, { dontEnum: true }, {
+	now: function now() { return new Date().getTime(); }
+});
+
+// Object helpers: defineProperty (accessors), defineProperties, create, keys
+defProps(Object, { dontEnum: true }, {
+	defineProperty: unconstructable(function defineProperty(o, p, d) {
+		var k = str(p);
+		var ro = !d.writable, de = !d.enumerable, dd = !d.configurable;
+		if ("get" in d || "set" in d) {
+			if ("value" in d || "writable" in d) throw TypeError();
+			var g = d["get"]; var s = d["set"];
+			if (g !== undefined && typeof g !== "function") throw TypeError();
+			if (s !== undefined && typeof s !== "function") throw TypeError();
+			// Use host support to create accessor properties
+			support.defineProperty(o, k, undefined, ro, de, dd, g, s);
+		} else {
+			// Data descriptor
+			support.defineProperty(o, k, d.value, ro, de, dd);
+		}
+	}),
+	defineProperties: unconstructable(function defineProperties(o, props) {
+		if (o === undefined || o === null) throw TypeError();
+		var obj = Object(o);
+		for (var k in props) if (Object.prototype.hasOwnProperty.call(props, k)) Object.defineProperty(obj, k, props[k]);
+		return obj;
+	}),
+	create: unconstructable(function create(proto, properties) {
+		if (proto === null) throw TypeError();
+		var t = typeof proto;
+		if (t !== "object" && t !== "function") throw TypeError();
+		function F() {}
+		F.prototype = proto;
+		var o = new F();
+		if (properties !== void 0) Object.defineProperties(o, Object(properties));
+		return o;
+	}),
+	keys: unconstructable(function keys(o) {
+		if (o === undefined || o === null) throw TypeError();
+		var obj = Object(o), res = [], k;
+		for (k in obj) if (Object.prototype.hasOwnProperty.call(obj, k)) res[res.length] = k;
+		return res;
+	})
+});
+
+// Function.prototype.bind (minimal, declared with one formal parameter)
+defProps(Function.prototype, { dontEnum: true }, {
+	bind: function bind(thisArg) {
+		var target = this;
+		if (typeof target !== 'function') throw TypeError();
+		var args = [target, thisArg];
+		for (var i = 1; i < arguments.length; ++i) args[args.length] = arguments[i];
+		return support.bind.apply(null, args);
+	}
+});
diff --git a/src/stdlibJS.cpp b/src/stdlibJS.cpp
index 8754846..8f8b089 100644
--- a/src/stdlibJS.cpp
+++ b/src/stdlibJS.cpp
@@ -1,78 +1,78 @@
 namespace NuXJS {
 const char* STDLIB_JS =
-"(function(a){var b=this;var c=a.distinctConstructor;var d=a.isNaN,e=a.isFinite,f=a.floor,g=a.NaN,h=a.Infinity,$match=a"
-".submatch,$sub=a.substring,i=a.getInternalProperty,j=a.callWithArgs,k=a.charCodeAt,abs,l,m,n,o=\"0123456789abcdefghijk"
-"lmnopqrstuvwxyz\",p=\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\",q=\" \\f\\n\\r\\t\\v\\xA0\\u2028\\u2029\";var r=(function"
-"(){var s={},t=q;for(var u=t.length-1;u>=0;--u){s[t[u]]=null}var v=o,w=p;for(var u=v.length-1;u>=0;--u){s[v[u]]=u;s[w[u"
-"]]=u}return s})();function x(){var u=20,y=this.z=[];do{y[--u]=''}while(u>0)}x.prototype.A=function A(B){for(var u=0,C="
-"256,y=this.z;(y[u]+=B).length>=C&&u<20;C<<=1,++u){B=y[u];y[u]=''}return this};x.prototype.D=function D(){var u,y,B=(y="
-"this.z)[u=19];do{B+=y[--u]}while(u>0);return B};function F(G){var G,H;return(((H=typeof G)!==\"object\"||G===null)&&H!"
-"==\"function\")}function I(J,K,L){var G;if((typeof(J[K])!==\"function\"||!F(G=J[K]()))&&(typeof(J[L])!==\"function\"||"
-"!F(G=J[L]()))){throw n(\"Error converting object to primitive type\")}return G}a.toPrimitiveNumber=function(J){return "
-"I(J,\"valueOf\",\"toString\")};a.toPrimitiveString=function(J){return I(J,\"toString\",\"valueOf\")};a.toPrimitive=fun"
-"ction(J){return a[i(J,\"class\")===\"Date\"?\"toPrimitiveString\":\"toPrimitiveNumber\"](J)};function M(G){return d(G="
-"+G)?0:(!e(G)?G:(G<0?-f(-G):f(G)))}function N(G){return M(G)|0}function O(G){return M(G)>>>0}function P(J){return''+(F("
-"J)?J:a.toPrimitiveString(J))}function Q(R,S,T){var U=S.readOnly,V=S.dontEnum,W=S.dontDelete;for(var X in T)a.definePro"
-"perty(R,X,T[X],U,V,W);return R}function Y(R,Z,a0){if(i(R,\"class\")!==Z){throw n(Z+\".prototype.\"+a0+\" is not generi"
-"c\")}}function a1(B,a2){var C=(B=\"00000000000000000000\"+B).length;return $sub(B,C-a2,C)}function a3(a4,a5,a6){var a7"
-"='';if(a4<0){a4=-a4;a7='-'}var a8=0,a9=0,aa;if(a4!==0){if(a4<1e-323){a9=-324;a8=a4/1e-323*10.0}else{if((a9=f(a.log(a4)"
-"*0.43429448190325182765113))<-323)a9=-323;if(a4>=(aa=a.pow(10,a9))*10.0){aa*=10.0;++a9}a8=a4/aa}}if(a5===void 0)a7+=a8"
-";else{aa=a.pow(10,a5);var ab=f(a8),ac=f((a8-ab)*aa+0.5);ab+=(ac>=aa?1:0);if(ab>=10){ab=1;++a9}if(a9>=a6&&a9<=a5){a5-=a"
-"9;aa=a.pow(10,a5);ab=f(a4);ac=f((a4-ab)*aa+0.5);if(ac>=aa)++ab;a9=null}a7+=ab;if(a5>0)a7+='.'+a1(ac,a5)}if(a9!==null)a"
-"7+=(a9>=0?\"e+\":'e')+a9;return a7}function ad(ae,af){var ag='',B='';if((ae=M(ae))<0){ae=-ae;ag='-'}do{B=o[ae%af]+B}wh"
-"ile((ae=f(ae/af))>0);return ag+B}function ah(B){var ai=eval;eval=a.evalFunction;try{return eval(B)}finally{eval=ai}}va"
-"r Object=function Object(G){switch(typeof G){case\"object\":case\"function\":if(G!==null)return G;case\"undefined\":re"
-"turn{};case\"boolean\":return new Boolean(G);case\"number\":return new Number(G);case\"string\":return new String(G)}}"
-";Q(Object,{dontEnum:true,readOnly:true,dontDelete:true},{prototype:a.prototypes.Object});Q(Object.prototype,{dontEnum:"
-"true},{constructor:Object,valueOf:c(function valueOf(){return this}),toLocaleString:c(function toLocaleString(){return"
-" this.toString()}),toString:c(function toString(){var B;return\"[object \"+(((B=i(this,\"class\"))===\"Arguments\")?\""
-"Object\":B)+']'}),hasOwnProperty:c(function hasOwnProperty(name){return a.hasOwnProperty(this,P(name))}),propertyIsEnu"
-"merable:c(function propertyIsEnumerable(name){return a.isPropertyEnumerable(this,P(name))}),isPrototypeOf:c(function i"
-"sPrototypeOf(G){while(G=i(G,\"prototype\")){if(G===this)return true}return false})});var Function=function Function(aj"
-"){var ak,al='(',C=(ak=arguments).length-1;for(var u=0;u<C;++u){al+=ak[u];if(u<C-1)al+=','}al+=\") {\\n\";if(C>=0)al+=a"
-"k[C];return a.compileFunction(al+\"\\n}\",\"anonymous\")};Q(Function,{dontEnum:true,readOnly:true,dontDelete:true},{pr"
-"ototype:a.prototypes.Function});Q(Function.prototype,{dontEnum:true},{constructor:Function,apply:c(function apply(am,a"
-"n){var ao;if(an==null)an=[];else if((ao=i(an,\"class\"))!==\"Array\"&&ao!==\"Arguments\"){throw n(\"Argument list has "
-"wrong type\")};return j(this,am,an)}),call:c(function call(am){return j(this,am,arguments,1)}),toString:c(function toS"
-"tring(){Y(this,\"Function\",\"toString\");return i(this,\"value\")})});var Boolean=a.distinctConstructor(function Bool"
-"ean(G){return!!G},function Boolean(G){return a.createWrapper(\"Boolean\",!!G,a.prototypes.Boolean)});Q(Boolean,{dontEn"
-"um:true,readOnly:true,dontDelete:true},{prototype:a.prototypes.Boolean});Q(Boolean.prototype,{dontEnum:true},{construc"
-"tor:Boolean,valueOf:c(function valueOf(){Y(this,\"Boolean\",\"valueOf\");return i(this,\"value\")}),toString:c(functio"
-"n toString(){Y(this,\"Boolean\",\"toString\");return''+i(this,\"value\")})});function ap(R,a0){Y(R,\"Number\",a0);retu"
-"rn i(R,\"value\")}var Number=a.distinctConstructor(function Number(G){return(arguments.length?+G:0)},function Number(G"
-"){return a.createWrapper(\"Number\",arguments.length?+G:0,a.prototypes.Number)});Q(Number,{dontEnum:true,readOnly:true"
-",dontDelete:true},{prototype:a.prototypes.Number});Q(Number,{dontEnum:true,readOnly:true,dontDelete:true},{MAX_VALUE:a"
-".maxNumber,MIN_VALUE:a.minNumber,NaN:g,NEGATIVE_INFINITY:-h,POSITIVE_INFINITY:h});Q(Number.prototype,{dontEnum:true},{"
-"constructor:Number,valueOf:c(function valueOf(){return ap(this,\"valueOf\")}),toLocaleString:Object.prototype.toLocale"
-"String,toString:c(function toString(af){var ae=ap(this,\"toString\");if(af===void 0||!e(ae))return''+ae;else if((af=M("
-"af))<2||af>36)throw m(\"Illegal radix for toString()\");else return ad(ae,af)}),toExponential:c(function toExponential"
-"(aq){var ae,a5;if(!e(ae=ap(this,\"toExponential\")))return ae;else if(aq===void 0)return a3(ae,void 0,h);else{if((a5=M"
-"(aq))<0||a5>20){throw m(\"Illegal fractionDigits argument for toExponential()\")}return a3(ae,a5,h)}}),toFixed:c(funct"
-"ion toFixed(aq){var ae,a5;if((a5=M(aq))<0||a5>20){throw m(\"Illegal fractionDigits argument for toFixed()\")}if(d(ae=a"
-"p(this,\"toFixed\"))||ae<=-1e21||ae>=1e21)return''+ae;else{var B='';if(ae<0){ae=-ae;B='-'}var aa=a.pow(10,a5);var ab=f"
-"(ae);var ac=f((ae-ab)*aa+0.5);B+=ab+(ac>=aa?1:0);if(a5>0){B+='.'+a1(ac,a5)}return B}}),toPrecision:c(function toPrecis"
-"ion(ar){var ae=ap(this,\"toPrecision\"),a5;if(ar===void 0||!e(ae))return ae;else{if((a5=M(ar)-1)<0||a5>20){throw m(\"I"
-"llegal precision argument for toPrecision()\")}return a3(ae,a5,-6)}})});var as,upperToLower;function at(){as={\"\\xdf"
-"\":\"SS\",\"\\u0131\":\"I\",\"\\u0149\":\"\\u02bcn\",\"\\u017f\":\"S\",\"\\u01c5\":\"\\u01c4\",\"\\u01c8\":\"\\u01c7\""
-",\"\\u01cb\":\"\\u01ca\",\"\\u01f0\":\"j\\u030c\",\"\\u01f2\":\"\\u01f1\",\"\\u0345\":\"\\u0399\",\"\\u0390\":\"\\u03b"
-"9\\u0308\\u030d\",\"\\u03b0\":\"\\u03c5\\u0308\\u030d\",\"\\u03c2\":\"\\u03a3\",\"\\u03d0\":\"\\u0392\",\"\\u03d1\":\""
-"\\u0398\",\"\\u03d5\":\"\\u03a6\",\"\\u03d6\":\"\\u03a0\",\"\\u03f0\":\"\\u039a\",\"\\u03f1\":\"\\u03a1\",\"\\u03f2\":"
-"\"\\u03a3\",\"\\u0587\":\"\\u0535\\u0552\",\"\\u1e96\":\"h\\u0331\",\"\\u1e97\":\"t\\u0308\",\"\\u1e98\":\"w\\u030a\","
-"\"\\u1e99\":\"y\\u030a\",\"\\u1e9a\":\"a\\u02be\",\"\\u1e9b\":\"\\u1e60\",\"\\u1f50\":\"\\u03c5\\u0313\",\"\\u1f52\":"
-"\"\\u03c5\\u0313\\u0300\",\"\\u1f54\":\"\\u03c5\\u0313\\u0301\",\"\\u1f56\":\"\\u03c5\\u0313\\u0342\",\"\\u1f80\":\"\\"
-"u1f08\\u03b9\",\"\\u1f81\":\"\\u1f09\\u03b9\",\"\\u1f82\":\"\\u1f0a\\u03b9\",\"\\u1f83\":\"\\u1f0b\\u03b9\",\"\\u1f84"
-"\":\"\\u1f0c\\u03b9\",\"\\u1f85\":\"\\u1f0d\\u03b9\",\"\\u1f86\":\"\\u1f0e\\u03b9\",\"\\u1f87\":\"\\u1f0f\\u03b9\",\""
-"\\u1f88\":\"\\u1f08\\u03b9\",\"\\u1f90\":\"\\u1f28\\u03b9\",\"\\u1f91\":\"\\u1f29\\u03b9\",\"\\u1f92\":\"\\u1f2a\\u03b"
-"9\",\"\\u1f93\":\"\\u1f2b\\u03b9\",\"\\u1f94\":\"\\u1f2c\\u03b9\",\"\\u1f95\":\"\\u1f2d\\u03b9\",\"\\u1f96\":\"\\u1f2e"
-"\\u03b9\",\"\\u1f97\":\"\\u1f2f\\u03b9\",\"\\u1fa0\":\"\\u1f68\\u03b9\",\"\\u1fa1\":\"\\u1f69\\u03b9\",\"\\u1fa2\":\""
-"\\u1f6a\\u03b9\",\"\\u1fa3\":\"\\u1f6b\\u03b9\",\"\\u1fa4\":\"\\u1f6c\\u03b9\",\"\\u1fa5\":\"\\u1f6d\\u03b9\",\"\\u1fa"
-"6\":\"\\u1f6e\\u03b9\",\"\\u1fa7\":\"\\u1f6f\\u03b9\",\"\\u1fb2\":\"\\u1f70\\u03b9\",\"\\u1fb3\":\"\\u0391\\u03b9\",\""
-"\\u1fb4\":\"\\u1f71\\u03b9\",\"\\u1fb6\":\"\\u03b1\\u0342\",\"\\u1fb7\":\"\\u1fb6\\u03b9\",\"\\u1fbe\":\"\\u0399\",\""
-"\\u1fc2\":\"\\u1f74\\u03b9\",\"\\u1fc3\":\"\\u0397\\u03b9\",\"\\u1fc4\":\"\\u1f75\\u03b9\",\"\\u1fc6\":\"\\u03b7\\u034"
-"2\",\"\\u1fc7\":\"\\u1fc6\\u03b9\",\"\\u1fd2\":\"\\u03b9\\u0308\\u0300\",\"\\u1fd3\":\"\\u03b9\\u0308\\u0301\",\"\\u1f"
-"d6\":\"\\u03b9\\u0342\",\"\\u1fd7\":\"\\u03b9\\u0308\\u0342\",\"\\u1fe2\":\"\\u03c5\\u0308\\u0300\",\"\\u1fe3\":\"\\u0"
-"3c5\\u0308\\u0301\",\"\\u1fe4\":\"\\u03c1\\u0313\",\"\\u1fe6\":\"\\u03c5\\u0342\",\"\\u1fe7\":\"\\u03c5\\u0308\\u0342"
-"\",\"\\u1ff2\":\"\\u1f7c\\u03b9\",\"\\u1ff3\":\"\\u03a9\\u03b9\",\"\\u1ff4\":\"\\u1f7d\\u03b9\",\"\\u1ff6\":\"\\u03c9"
+"(function(a,b){var c=this;var d=a.distinctConstructor;var e=a.isNaN,f=a.isFinite,g=a.floor,h=a.NaN,i=a.Infinity,$match"
+"=a.submatch,$sub=a.substring,j=a.getInternalProperty,k=a.callWithArgs,l=a.charCodeAt,abs,m,n,o,p=\"0123456789abcdefghi"
+"jklmnopqrstuvwxyz\",q=\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\",r=\" \\f\\n\\r\\t\\v\\xA0\\u2028\\u2029\";var s=(functi"
+"on(){var t={},u=r;for(var v=u.length-1;v>=0;--v){t[u[v]]=null}var w=p,x=q;for(var v=w.length-1;v>=0;--v){t[w[v]]=v;t[x"
+"[v]]=v}return t})();function y(){var v=20,z=this.A=[];do{z[--v]=''}while(v>0)}y.prototype.B=function B(C){for(var v=0,"
+"D=256,z=this.A;(z[v]+=C).length>=D&&v<20;D<<=1,++v){C=z[v];z[v]=''}return this};y.prototype.F=function F(){var v,z,C=("
+"z=this.A)[v=19];do{C+=z[--v]}while(v>0);return C};function G(H){var H,I;return(((I=typeof H)!==\"object\"||H===null)&&"
+"I!==\"function\")}function J(K,L,M){var H;if((typeof(K[L])!==\"function\"||!G(H=K[L]()))&&(typeof(K[M])!==\"function\""
+"||!G(H=K[M]()))){throw o(\"Error converting object to primitive type\")}return H}a.toPrimitiveNumber=function(K){retur"
+"n J(K,\"valueOf\",\"toString\")};a.toPrimitiveString=function(K){return J(K,\"toString\",\"valueOf\")};a.toPrimitive=f"
+"unction(K){return a[j(K,\"class\")===\"Date\"?\"toPrimitiveString\":\"toPrimitiveNumber\"](K)};function N(H){return e("
+"H=+H)?0:(!f(H)?H:(H<0?-g(-H):g(H)))}function O(H){return N(H)|0}function P(H){return N(H)>>>0}function Q(K){return''+("
+"G(K)?K:a.toPrimitiveString(K))}function R(S,T,U){var V=T.readOnly,W=T.dontEnum,X=T.dontDelete;for(var Y in U)a.defineP"
+"roperty(S,Y,U[Y],V,W,X);return S}function Z(S,a0,a1){if(j(S,\"class\")!==a0){throw o(a0+\".prototype.\"+a1+\" is not g"
+"eneric\")}}function a2(C,a3){var D=(C=\"00000000000000000000\"+C).length;return $sub(C,D-a3,D)}function a4(a5,a6,a7){v"
+"ar a8='';if(a5<0){a5=-a5;a8='-'}var a9=0,aa=0,ab;if(a5!==0){if(a5<1e-323){aa=-324;a9=a5/1e-323*10.0}else{if((aa=g(a.lo"
+"g(a5)*0.43429448190325182765113))<-323)aa=-323;if(a5>=(ab=a.pow(10,aa))*10.0){ab*=10.0;++aa}a9=a5/ab}}if(a6===void 0)a"
+"8+=a9;else{ab=a.pow(10,a6);var ac=g(a9),ad=g((a9-ac)*ab+0.5);ac+=(ad>=ab?1:0);if(ac>=10){ac=1;++aa}if(aa>=a7&&aa<=a6){"
+"a6-=aa;ab=a.pow(10,a6);ac=g(a5);ad=g((a5-ac)*ab+0.5);if(ad>=ab)++ac;aa=null}a8+=ac;if(a6>0)a8+='.'+a2(ad,a6)}if(aa!==n"
+"ull)a8+=(aa>=0?\"e+\":'e')+aa;return a8}function ae(af,ag){var ah='',C='';if((af=N(af))<0){af=-af;ah='-'}do{C=p[af%ag]"
+"+C}while((af=g(af/ag))>0);return ah+C}function ai(C){var aj=eval;eval=a.evalFunction;try{return eval(C)}finally{eval=a"
+"j}}var Object=function Object(H){switch(typeof H){case\"object\":case\"function\":if(H!==null)return H;case\"undefined"
+"\":return{};case\"boolean\":return new Boolean(H);case\"number\":return new Number(H);case\"string\":return new String"
+"(H)}};R(Object,{dontEnum:true,readOnly:true,dontDelete:true},{prototype:a.prototypes.Object});R(Object.prototype,{dont"
+"Enum:true},{constructor:Object,valueOf:d(function valueOf(){return this}),toLocaleString:d(function toLocaleString(){r"
+"eturn this.toString()}),toString:d(function toString(){var C;return\"[object \"+(((C=j(this,\"class\"))===\"Arguments"
+"\")?\"Object\":C)+']'}),hasOwnProperty:d(function hasOwnProperty(name){return a.hasOwnProperty(this,Q(name))}),propert"
+"yIsEnumerable:d(function propertyIsEnumerable(name){return a.isPropertyEnumerable(this,Q(name))}),isPrototypeOf:d(func"
+"tion isPrototypeOf(H){while(H=j(H,\"prototype\")){if(H===this)return true}return false})});var Function=function Funct"
+"ion(ak){var al,am='(',D=(al=arguments).length-1;for(var v=0;v<D;++v){am+=al[v];if(v<D-1)am+=','}am+=\") {\\n\";if(D>=0"
+")am+=al[D];return a.compileFunction(am+\"\\n}\",\"anonymous\")};R(Function,{dontEnum:true,readOnly:true,dontDelete:tru"
+"e},{prototype:a.prototypes.Function});R(Function.prototype,{dontEnum:true},{constructor:Function,apply:d(function appl"
+"y(an,ao){var ap;if(ao==null)ao=[];else if((ap=j(ao,\"class\"))!==\"Array\"&&ap!==\"Arguments\"){throw o(\"Argument lis"
+"t has wrong type\")};return k(this,an,ao)}),call:d(function call(an){return k(this,an,arguments,1)}),toString:d(functi"
+"on toString(){Z(this,\"Function\",\"toString\");return j(this,\"value\")})});var Boolean=a.distinctConstructor(functio"
+"n Boolean(H){return!!H},function Boolean(H){return a.createWrapper(\"Boolean\",!!H,a.prototypes.Boolean)});R(Boolean,{"
+"dontEnum:true,readOnly:true,dontDelete:true},{prototype:a.prototypes.Boolean});R(Boolean.prototype,{dontEnum:true},{co"
+"nstructor:Boolean,valueOf:d(function valueOf(){Z(this,\"Boolean\",\"valueOf\");return j(this,\"value\")}),toString:d(f"
+"unction toString(){Z(this,\"Boolean\",\"toString\");return''+j(this,\"value\")})});function aq(S,a1){Z(S,\"Number\",a1"
+");return j(S,\"value\")}var Number=a.distinctConstructor(function Number(H){return(arguments.length?+H:0)},function Nu"
+"mber(H){return a.createWrapper(\"Number\",arguments.length?+H:0,a.prototypes.Number)});R(Number,{dontEnum:true,readOnl"
+"y:true,dontDelete:true},{prototype:a.prototypes.Number});R(Number,{dontEnum:true,readOnly:true,dontDelete:true},{MAX_V"
+"ALUE:a.maxNumber,MIN_VALUE:a.minNumber,NaN:h,NEGATIVE_INFINITY:-i,POSITIVE_INFINITY:i});R(Number.prototype,{dontEnum:t"
+"rue},{constructor:Number,valueOf:d(function valueOf(){return aq(this,\"valueOf\")}),toLocaleString:Object.prototype.to"
+"LocaleString,toString:d(function toString(ag){var af=aq(this,\"toString\");if(ag===void 0||!f(af))return''+af;else if("
+"(ag=N(ag))<2||ag>36)throw n(\"Illegal radix for toString()\");else return ae(af,ag)}),toExponential:d(function toExpon"
+"ential(ar){var af,a6;if(!f(af=aq(this,\"toExponential\")))return af;else if(ar===void 0)return a4(af,void 0,i);else{if"
+"((a6=N(ar))<0||a6>20){throw n(\"Illegal fractionDigits argument for toExponential()\")}return a4(af,a6,i)}}),toFixed:d"
+"(function toFixed(ar){var af,a6;if((a6=N(ar))<0||a6>20){throw n(\"Illegal fractionDigits argument for toFixed()\")}if("
+"e(af=aq(this,\"toFixed\"))||af<=-1e21||af>=1e21)return''+af;else{var C='';if(af<0){af=-af;C='-'}var ab=a.pow(10,a6);va"
+"r ac=g(af);var ad=g((af-ac)*ab+0.5);C+=ac+(ad>=ab?1:0);if(a6>0){C+='.'+a2(ad,a6)}return C}}),toPrecision:d(function to"
+"Precision(as){var af=aq(this,\"toPrecision\"),a6;if(as===void 0||!f(af))return af;else{if((a6=N(as)-1)<0||a6>20){throw"
+" n(\"Illegal precision argument for toPrecision()\")}return a4(af,a6,-6)}})});var at,upperToLower;function au(){at={\""
+"\\xdf\":\"SS\",\"\\u0131\":\"I\",\"\\u0149\":\"\\u02bcn\",\"\\u017f\":\"S\",\"\\u01c5\":\"\\u01c4\",\"\\u01c8\":\"\\u0"
+"1c7\",\"\\u01cb\":\"\\u01ca\",\"\\u01f0\":\"j\\u030c\",\"\\u01f2\":\"\\u01f1\",\"\\u0345\":\"\\u0399\",\"\\u0390\":\""
+"\\u03b9\\u0308\\u030d\",\"\\u03b0\":\"\\u03c5\\u0308\\u030d\",\"\\u03c2\":\"\\u03a3\",\"\\u03d0\":\"\\u0392\",\"\\u03d"
+"1\":\"\\u0398\",\"\\u03d5\":\"\\u03a6\",\"\\u03d6\":\"\\u03a0\",\"\\u03f0\":\"\\u039a\",\"\\u03f1\":\"\\u03a1\",\"\\u0"
+"3f2\":\"\\u03a3\",\"\\u0587\":\"\\u0535\\u0552\",\"\\u1e96\":\"h\\u0331\",\"\\u1e97\":\"t\\u0308\",\"\\u1e98\":\"w\\u0"
+"30a\",\"\\u1e99\":\"y\\u030a\",\"\\u1e9a\":\"a\\u02be\",\"\\u1e9b\":\"\\u1e60\",\"\\u1f50\":\"\\u03c5\\u0313\",\"\\u1f"
+"52\":\"\\u03c5\\u0313\\u0300\",\"\\u1f54\":\"\\u03c5\\u0313\\u0301\",\"\\u1f56\":\"\\u03c5\\u0313\\u0342\",\"\\u1f80\""
+":\"\\u1f08\\u03b9\",\"\\u1f81\":\"\\u1f09\\u03b9\",\"\\u1f82\":\"\\u1f0a\\u03b9\",\"\\u1f83\":\"\\u1f0b\\u03b9\",\"\\u"
+"1f84\":\"\\u1f0c\\u03b9\",\"\\u1f85\":\"\\u1f0d\\u03b9\",\"\\u1f86\":\"\\u1f0e\\u03b9\",\"\\u1f87\":\"\\u1f0f\\u03b9\""
+",\"\\u1f88\":\"\\u1f08\\u03b9\",\"\\u1f90\":\"\\u1f28\\u03b9\",\"\\u1f91\":\"\\u1f29\\u03b9\",\"\\u1f92\":\"\\u1f2a\\u"
+"03b9\",\"\\u1f93\":\"\\u1f2b\\u03b9\",\"\\u1f94\":\"\\u1f2c\\u03b9\",\"\\u1f95\":\"\\u1f2d\\u03b9\",\"\\u1f96\":\"\\u1"
+"f2e\\u03b9\",\"\\u1f97\":\"\\u1f2f\\u03b9\",\"\\u1fa0\":\"\\u1f68\\u03b9\",\"\\u1fa1\":\"\\u1f69\\u03b9\",\"\\u1fa2\":"
+"\"\\u1f6a\\u03b9\",\"\\u1fa3\":\"\\u1f6b\\u03b9\",\"\\u1fa4\":\"\\u1f6c\\u03b9\",\"\\u1fa5\":\"\\u1f6d\\u03b9\",\"\\u1"
+"fa6\":\"\\u1f6e\\u03b9\",\"\\u1fa7\":\"\\u1f6f\\u03b9\",\"\\u1fb2\":\"\\u1f70\\u03b9\",\"\\u1fb3\":\"\\u0391\\u03b9\","
+"\"\\u1fb4\":\"\\u1f71\\u03b9\",\"\\u1fb6\":\"\\u03b1\\u0342\",\"\\u1fb7\":\"\\u1fb6\\u03b9\",\"\\u1fbe\":\"\\u0399\","
+"\"\\u1fc2\":\"\\u1f74\\u03b9\",\"\\u1fc3\":\"\\u0397\\u03b9\",\"\\u1fc4\":\"\\u1f75\\u03b9\",\"\\u1fc6\":\"\\u03b7\\u0"
+"342\",\"\\u1fc7\":\"\\u1fc6\\u03b9\",\"\\u1fd2\":\"\\u03b9\\u0308\\u0300\",\"\\u1fd3\":\"\\u03b9\\u0308\\u0301\",\"\\u"
+"1fd6\":\"\\u03b9\\u0342\",\"\\u1fd7\":\"\\u03b9\\u0308\\u0342\",\"\\u1fe2\":\"\\u03c5\\u0308\\u0300\",\"\\u1fe3\":\"\\"
+"u03c5\\u0308\\u0301\",\"\\u1fe4\":\"\\u03c1\\u0313\",\"\\u1fe6\":\"\\u03c5\\u0342\",\"\\u1fe7\":\"\\u03c5\\u0308\\u034"
+"2\",\"\\u1ff2\":\"\\u1f7c\\u03b9\",\"\\u1ff3\":\"\\u03a9\\u03b9\",\"\\u1ff4\":\"\\u1f7d\\u03b9\",\"\\u1ff6\":\"\\u03c9"
 "\\u0342\",\"\\u1ff7\":\"\\u1ff6\\u03b9\",\"\\ufb00\":\"FF\",\"\\ufb01\":\"FI\",\"\\ufb02\":\"FL\",\"\\ufb03\":\"FFI\","
 "\"\\ufb04\":\"FFL\",\"\\ufb05\":\"ST\",\"\\ufb06\":\"ST\",\"\\ufb13\":\"\\u0544\\u0546\",\"\\ufb14\":\"\\u0544\\u0535"
 "\",\"\\ufb15\":\"\\u0544\\u053b\",\"\\ufb16\":\"\\u054e\\u0546\",\"\\ufb17\":\"\\u0544\\u053d\"};upperToLower={\"\\u01"
@@ -90,7 +90,7 @@ const char* STDLIB_JS =
 "\"\\u1f93\",\"\\u1f9c\":\"\\u1f94\",\"\\u1f9d\":\"\\u1f95\",\"\\u1f9e\":\"\\u1f96\",\"\\u1f9f\":\"\\u1f97\",\"\\u1fa8"
 "\":\"\\u1fa0\",\"\\u1fa9\":\"\\u1fa1\",\"\\u1faa\":\"\\u1fa2\",\"\\u1fab\":\"\\u1fa3\",\"\\u1fac\":\"\\u1fa4\",\"\\u1f"
 "ad\":\"\\u1fa5\",\"\\u1fae\":\"\\u1fa6\",\"\\u1faf\":\"\\u1fa7\",\"\\u1fbc\":\"\\u1fb3\",\"\\u1fcc\":\"\\u1fc3\",\"\\u"
-"1ffc\":\"\\u1ff3\"};var au,av={'A':\"a\",'B':\"b\",'C':\"c\",'D':\"d\",'E':\"e\",'F':\"f\",'G':\"g\",'H':\"h\",'I':\"i"
+"1ffc\":\"\\u1ff3\"};var av,aw={'A':\"a\",'B':\"b\",'C':\"c\",'D':\"d\",'E':\"e\",'F':\"f\",'G':\"g\",'H':\"h\",'I':\"i"
 "\",'J':\"j\",'K':\"k\",'L':\"l\",'M':\"m\",'N':\"n\",'O':\"o\",'P':\"p\",'Q':\"q\",'R':\"r\",'S':\"s\",'T':\"t\",'U':"
 "\"u\",'V':\"v\",'W':\"w\",'X':\"x\",'Y':\"y\",'Z':\"z\",\"\\xc0\":\"\\xe0\",\"\\xc1\":\"\\xe1\",\"\\xc2\":\"\\xe2\",\""
 "\\xc3\":\"\\xe3\",\"\\xc4\":\"\\xe4\",\"\\xc5\":\"\\xe5\",\"\\xc6\":\"\\xe6\",\"\\xc7\":\"\\xe7\",\"\\xc8\":\"\\xe8\","
@@ -215,277 +215,321 @@ const char* STDLIB_JS =
 "47\",\"\\uff28\":\"\\uff48\",\"\\uff29\":\"\\uff49\",\"\\uff2a\":\"\\uff4a\",\"\\uff2b\":\"\\uff4b\",\"\\uff2c\":\"\\u"
 "ff4c\",\"\\uff2d\":\"\\uff4d\",\"\\uff2e\":\"\\uff4e\",\"\\uff2f\":\"\\uff4f\",\"\\uff30\":\"\\uff50\",\"\\uff31\":\""
 "\\uff51\",\"\\uff32\":\"\\uff52\",\"\\uff33\":\"\\uff53\",\"\\uff34\":\"\\uff54\",\"\\uff35\":\"\\uff55\",\"\\uff36\":"
-"\"\\uff56\",\"\\uff37\":\"\\uff57\",\"\\uff38\":\"\\uff58\",\"\\uff39\":\"\\uff59\",\"\\uff3a\":\"\\uff5a\"};for(au in"
-" av)as[upperToLower[au]=av[au]]=au};function aw(a7,ax){var u=-1,ay=a7.length,B='',H,au;while(++u<ay)B+=(H=ax[au=a7[u]]"
-")?H:au;return B}function az(J){if(!as)at();return aw(P(J),upperToLower)}function aA(J){if(!as)at();return aw(P(J),as)}"
-"var String=a.distinctConstructor(function String(G){return(arguments.length?P(G):'')},function String(G){var B;return "
-"Q(a.createWrapper(\"String\",(B=(arguments.length?P(G):'')),a.prototypes.String),{readOnly:true,dontEnum:true,dontDele"
-"te:true},{length:B.length})});Q(String,{dontEnum:true,readOnly:true,dontDelete:true},{prototype:a.prototypes.String});"
-"Q(String,{dontEnum:true},{fromCharCode:c(function fromCharCode(G){var aB,ak;if((aB=(ak=arguments).length)===1)return a"
-".fromCharCode(G&65535);for(var u=0,B='';u<aB;++u)B+=a.fromCharCode(ak[u]&65535);return B})});Q(String.prototype,{dontE"
-"num:true},{constructor:String,charAt:c(function charAt(aC){var B;return(((aC=M(aC))<0||aC>=(B=P(this)).length)?'':B[aC"
-"])}),charCodeAt:c(function charCodeAt(aC){return k(P(this),+aC)}),concat:c(function concat(aD){var aE,C=(aE=arguments)"
-".length,B=P(this);for(var u=0;u<C;++u)B+=P(aE[u]);return B}),indexOf:c(function indexOf(aF){var B,u,aG=(B=P(this)).len"
-"gth-(aF=P(aF)).length,aC=arguments[1];if((u=M(aC))<0)u=0;for(;u<=aG;++u)if($match(B,u,aF))return u;return-1}),lastInde"
-"xOf:c(function lastIndexOf(aF){var B,u,aG=(B=P(this)).length-(aF=P(aF)).length,aC=arguments[1];if(d(aC=+aC)||(u=M(aC))"
-">aG)u=aG;for(;u>=0;--u)if($match(B,u,aF))return u;return-1}),localeCompare:c(function localeCompare(aH){var aI,aJ;retu"
-"rn((aI=P(this))===(aJ=P(aH))?0:(aI<aJ?-1:1))}),match:c(function match(aK){if(i(aK,\"class\")!==\"RegExp\")aK=new RegEx"
-"p(aK);var B=P(this);if(!aK.global)return aL(aK,B);var u=aK.lastIndex=0,aM=[],aN;do{if(!(aN=aL(aK,B)))return(u===0?null"
-":aM);if(!(aM[u++]=aN[0]))++aK.lastIndex}while(true)}),replace:c(function replace(aO,aP){var B,aQ=(B=P(this)).length,aR"
-"=aP,aS,u,X,H,a2,aG;if(typeof aR!==\"function\"){var aN=P(aP);for(u=aN.length;--u>=0&&aN[u]!='$';);aR=(u<0?function(){r"
-"eturn aN}:function(aT){var H='',X,aU,aV,au,C;for(X=0;aU=aN[X];++X){if(aU!=='$')H+=aU;else switch(aU=aN[++X]){case(void"
-" 0):case'$':H+='$';break;case'&':H+=aT;break;case'`':H+=$sub(B,0,arguments[arguments.length-2]);break;case\"'\":H+=$su"
-"b(B,arguments[arguments.length-2]+aT.length,aQ);break;default:{if(aU>='0'&&aU<='9'){if(!(aV=aN[X+1])||aV<'0'||aV>'9')a"
-"V='';if((C=+(aU+aV))>=1&&C<arguments.length-2){H+=((au=arguments[C])===void 0?'':au);X+=aV.length;break}}H+='$'+aU;bre"
-"ak}}}return H})};if(i(aO,\"class\")===\"RegExp\"){X=0;H=new x;if(aO.global)aO.lastIndex=0;while(aS=aL(aO,B)){aS[u=aS.l"
-"ength]=aS.index;aS[u+1]=B;H.A($sub(B,X,aS.index)+P(j(aR,null,aS)));X=aS.index+(a2=aS[0].length);if(!aO.global)break;if"
-"(a2===0)++aO.lastIndex}return(H.A($sub(B,X,aQ))).D()}else{aG=aQ-(a2=(H=P(aO)).length);for(var X=0;!$match(B,X,H);++X)i"
-"f(X>=aG)return B;return $sub(B,0,X)+P(j(aR,null,[H,X,B]))+$sub(B,X+a2,aQ)}}),search:c(function search(aK){if(i(aK,\"cl"
-"ass\")!==\"RegExp\")aK=new RegExp(aK);var B,ay=(B=P(this)).length,aW=i(aK,\"value\");for(var u=0;u<=ay;++u)if(aW(B,u))"
-"return u;return-1}),slice:c(function slice(aX,aY){var B=P(this);if((aX=M(aX))<0)aX+=B.length;if(aY===void 0)aY=h;else "
-"if((aY=M(aY))<0)aY+=B.length;return $sub(B,aX,aY)}),split:c(function split(aZ,b0){var B,aQ=(B=P(this)).length,aM=[],b1"
-"=0,b2;if(!(b0=((b0===void 0)?0xFFFFFFFF:O(b0))))return aM;if(aZ===void 0)return[B];if(i(aZ,\"class\")!==\"RegExp\"){va"
-"r b3=(aZ=P(aZ)).length;b2=function(X){if($match(B,X,aZ))return[X,X+b3]}}else{var b4=i(aZ,\"value\");b2=function(X){ret"
-"urn b4(B,X)}}if(!aQ)return(b2(0)?aM:[B]);var X,y=X=0,aT,aG;while(X!==aQ){if(!(aT=b2(X))||(aG=aT[1])===y)++X;else{aT[0]"
-"=y;aT[1]=X;X=y=aG;for(var u=0;u<aT.length;u+=2){aM[b1]=(aT[u]===void 0?void 0:$sub(B,aT[u],aT[u+1]));if(++b1===b0)retu"
-"rn aM}}}aM[b1]=$sub(B,y,aQ);return aM}),substr:c(function substr(aX,length){var B=P(this);if((aX=M(aX))<0)aX=B.length+"
-"aX;return $sub(B,aX,(length===void 0?h:aX+M(length)))}),substring:c(function substring(aX,aY){aX=M(aX);if(aY===void 0)"
-"aY=h;else if((aY=M(aY))<aX){var b5=aX;aX=aY;aY=b5}return $sub(P(this),aX,aY)}),toUpperCase:c(function toUpperCase(){re"
-"turn aA(this)}),toLocaleUpperCase:c(function toLocaleUpperCase(){return aA(this)}),toLowerCase:c(function toLowerCase("
-"){return az(this)}),toLocaleLowerCase:c(function toLocaleLowerCase(){return az(this)}),valueOf:c(function valueOf(){Y("
-"this,\"String\",\"valueOf\");return i(this,\"value\")}),toString:c(function toString(){Y(this,\"String\",\"toString\")"
-";return i(this,\"value\")})});var Array=function Array(G){var aM=[],ak,aB;if((aB=(ak=arguments).length)===1&&typeof G="
-"==\"number\"){if((G>>>0)!==G)throw m(\"Invalid array length\");aM.length=G}else{for(var u=0;u<aB;++u)aM[u]=ak[u]}retur"
-"n aM};Q(Array,{dontEnum:true,readOnly:true,dontDelete:true},{prototype:a.prototypes.Array});Q(Array.prototype,{dontEnu"
-"m:true},{constructor:Array,concat:c(function concat(b6){var aM=[],ak,aB=(ak=arguments).length,C=0,G=this;for(var u=-1;"
-"u<aB;G=ak[++u]){if(i(G,\"class\")!==\"Array\"){aM[C++]=G}else{for(var b7=0,aG=G.length;b7<aG;++b7)if(b7 in G)aM[C+b7]="
-"G[b7];aM.length=(C+=b7)}}return aM}),join:c(function join(aZ){var B=new x,b8,ay=O(this.length);aZ=(aZ===void 0?',':P(a"
-"Z));for(var u=0;u<ay;++u){if(u>0)B.A(aZ);if((b8=this[u])!=null)B.A(P(b8))}return B.D()}),pop:c(function pop(){var G=vo"
-"id 0,ay;if((ay=O(this.length))>0)G=this[--ay];this.length=ay;return G}),push:c(function push(b9){var ak,ba=O(this.leng"
-"th),aY=(ak=arguments).length+ba;for(var u=ba;u<aY;++u)this[u]=ak[u-ba];return(this.length=aY)}),reverse:c(function rev"
-"erse(){var ay,bb=f((ay=O(this.length))/2);--ay;for(var bc=0;bc<bb;++bc){var bd=ay-bc;var be=(bd in this),bf=this[bd];i"
-"f(bc in this)this[bd]=this[bc];else delete this[bd];if(be)this[bc]=bf;else delete this[bc]}return this}),shift:c(funct"
-"ion shift(){var ay,bg;if(ay=O(this.length)){bg=this[0];for(var u=1;u<ay;++u){if(u in this)this[u-1]=this[u];else delet"
-"e this[u-1]}--ay};this.length=ay;return bg}),slice:c(function slice(aX,aY){var aM=[],ay=O(this.length);if((aX=M(aX))<0"
-"){aX+=ay;if(aX<0)aX=0}if(aY===void 0||(aY=M(aY))>ay)aY=ay;else if(aY<0)aY+=ay;for(var u=aX,b7=0;u<aY;++u,++b7)if(u in "
-"this)aM[b7]=this[u];aM.length=b7;return aM}),sort:c(function sort(bh){var bi=this;function b5(bj,bk,bl){var bm=(bk in "
-"bj),bn=bj[bk];if(bl in bj)bj[bk]=bj[bl];else delete bj[bk];if(bm)bj[bl]=bn;else delete bj[bl]};function bo(bj,bk,bl){i"
-"f(!(bk in bj)&&!(bl in bj))return 0;else if(!(bk in bj))return 1;else if(!(bl in bj))return-1;else{var aM=bj[bk];var y"
-"=bj[bl];if(aM===void 0&&y===void 0)return 0;else if(aM===void 0)return 1;else if(y===void 0)return-1;else return bh(aM"
-",y)}};function bp(bq,br){var bs=b5,bt=bo,bj=bi,bb,bu;for(--br;bq+1<br;bq=bu){var bv=br;bu=bq;bb=f((bu+bv)/2);while(bu<"
-"bv){while(bu<=bv&&bt(bj,bu,bb)<=0&&bt(bj,bv,bb)>=0){++bu;--bv}while(bu<=bv&&bt(bj,bv,bb)>0)--bv;while(bu<=bv&&bt(bj,bu"
-",bb)<0)++bu;if(bb===bu||bb===bv)bb^=bv^bu;if(bu<bv)bs(bj,bu,bv)}bp(bq,bu)}if(bq<br&&bt(bj,bq,br)>0)bs(bj,bq,br)};if(bh"
-"===void 0){bh=function(aM,y){return((aM=P(aM))<(y=P(y))?-1:(aM>y?1:0))}};bp(0,this.length>>>0);return this}),splice:c("
-"function splice(aX,bw){var aM=[],ay=O(this.length),ak,aB=(ak=arguments).length,aY,bx,by;if((aX=M(aX))<0){aX+=ay;if(aX<"
-"0)aX=0}else if(aX>ay)aX=ay;if(aB==1||(aY=aX+M(bw))>ay)aY=ay;else if(aY<aX)aY=aX;for(var u=aX,b7=0;u<aY;++u,++b7)if(u i"
-"n this)aM[b7]=this[u];aM.length=b7;if((bx=aB-2)<0)bx=0;if((by=aX+bx-aY)!==0){var bz=1,b7=aY;if(by>0){bz=-1;b7=ay-1}for"
-"(u=ay-aY;--u>=0;b7+=bz){if(b7 in this)this[b7+by]=this[b7];else delete this[b7+by]}for(u=ay;--u>=ay+by;)delete this[u]"
-"}for(u=2,b7=aX;u<aB;++u,++b7)this[b7]=ak[u];this.length=ay+by;return aM}),toLocaleString:Object.prototype.toLocaleStri"
-"ng,toString:c(function toString(){Y(this,\"Array\",\"toString\");return this.join()}),unshift:c(function unshift(b6){v"
-"ar ay,ak,C=(ak=arguments).length;if(ay=O(this.length)){for(var u=ay;--u>=0;){if(u in this)this[u+C]=this[u];else delet"
-"e this[u+C]}}for(var u=0;u<C;++u)this[u]=ak[u];return(this.length=ay+C)})});function bA(){var bB=a.localTimeDifference"
-"(14516064e5);var bC=a.localTimeDifference(14673312e5);return(bB>bC?bB:bC)}function bD(){var bB=a.localTimeDifference(1"
-"4516064e5);var bC=a.localTimeDifference(14673312e5);return(bB<bC?bB:bC)}function bE(bF){var a2=a.localTimeDifference(b"
-"F);return(d(a2)?bD():a2)}function bG(bF){return d(bF)?bF:bF+bE(bF)}function bH(R){if(i(R,\"class\")!==\"Date\")throw n"
-"(\"this is not a Date object\")}function bI(R){bH(R);return i(R,\"value\")}function bJ(R){return bG(bI(R))}function bK"
-"(R,G){bH(R);a.updateDateValue(R,G);return G}function bL(G){return d(G=bG(G))?\"Invalid Date\":(bM(G)+' '+bN(G))}functi"
-"on bO(bP,C){return(bP%C+C)%C}function bQ(bR,bS,bT,bU){return bR*36e5+bS*6e4+bT*1e3+bU}function bV(bF){return[bO(f(bF/3"
-"6e5),24),bO(f(bF/6e4),60),bO(f(bF/1e3),60),bO(bF,1e3)]}function bW(bF){return d(bF)?bF:(bF-bE(bF-bA()))}function bX(bF"
-"){return bO(f(bF/864e5)+4,7)}function bY(bF){return bO(f(bF/36e5),24)}function bZ(bF){return bO(f(bF/6e4),60)}function"
-" c0(bF){return bO(f(bF/1e3),60)}function c1(bF){return bO(bF,1e3)}function c2(bF){return(!e(bF)||abs(bF)>8.64e15?g:M(b"
-"F))}function c3(bF){return bW(c2(bF))}function c4(bF){bF=f(bF/864e5)+719468;var c5=M((bF>=0?bF:bF-146096)/146097);var "
-"c6=bF-c5*146097;var c7=M((c6-M(c6/1460)+M(c6/36524)-M(c6/146096))/365);var c8=c7+c5*400;var c9=c6-(365*c7+M(c7/4)-M(c7"
-"/100));var ca=M((5*c9+2)/153);var aT=ca+(ca<10?2:-10);var cb=c9-M((153*ca+2)/5)+1;return[(c8+(aT<=1)),aT,cb]}function "
-"bM(bF){var c8,cc=c4(bF);return(0<=(c8=cc[0])&&c8<=9999?a1(c8,4):(c8<0?\"-\":\"+\")+a1(abs(c8),6))+\"-\"+a1(cc[1]+1,2)+"
-"\"-\"+a1(cc[2],2)}function bN(bF,bU){var cd=bV(bF);return a1(cd[0],2)+\":\"+a1(cd[1],2)+\":\"+a1(cd[2],2)+(bU?\".\"+a1"
-"($sub(cd[3],0,3),3):\"\")}function ce(cf,cg,ch){cf+=f(cg/12)-(bO(cg,12)<=1);var c5=M((cf>=0?cf:cf-399)/400);var c7=cf-"
-"c5*400;var c9=M((153*(cg+(cg>1?-2:10))+2)/5)+ch-1;var c6=c7*365+M(c7/4)-M(c7/100)+c9;return(c5*146097+c6-719468)*864e5"
-"}function ci(bF,C,aM){var u,cb=c4(bF),aN=bO(bF,864e5);for(u=0;u<aM.length;++u,++C)cb[C]=M(aM[u]);return j(ce,null,cb)+"
-"aN}function cj(bF,C,aM){var u,H=bV(bF),aN=f(bF/864e5)*864e5;for(u=0;u<aM.length;++u,++C)H[C]=M(aM[u]);return j(bQ,null"
-",H)+aN}function ck(cf,cg,cl,cm,cn,co,bU){var aB=arguments.length;return ce((cf=M(cf))+(0<=cf&&cf<=99?1900:0),M(cg),(aB"
-">2?M(cl):1))+bQ(aB>3?M(cm):0,aB>4?M(cn):0,aB>5?M(co):0,aB>6?M(bU):0)}function cp(cb){var bF;return d(bF=bI(cb))?null:b"
-"M(bF)+\"T\"+bN(bF,true)+\"Z\"}var cq,Date=a.distinctConstructor(function Date(){return bL(a.getCurrentTime())},functio"
-"n Date(cf,cg,cl,cm,cn,co,bU){var G,aB;if((aB=arguments.length)>=2&&aB<=7)G=c3(j(ck,null,arguments));else if(aB===1)G=c"
-"2(typeof(G=a.toPrimitive(cf))===\"string\"?cq(G):+G);else G=a.getCurrentTime();return a.createWrapper(\"Date\",G,a.pro"
-"totypes.Date)});Q(Date,{dontEnum:true,readOnly:true,dontDelete:true},{prototype:a.prototypes.Date});Q(Date,{dontEnum:t"
-"rue},{parse:c(cq=function parse(B){var bF,c8,u,aU,cr,cs,ct,u=0;function cu(ay){var G;for(G=0;--ay>=0;)if(\"0\"<=B[u]&&"
-"B[u]<=\"9\")G=G*10+(+B[u++]);else return g;return G}bF=ce(((aU=B[u])===\"+\"||aU===\"-\")&&(++u,c8=cu(6),aU===\"-\"?-c"
-"8:c8)||cu(4),B[u]===\"-\"&&(++u,cu(2)-1)||0,B[u]===\"-\"&&(++u,cu(2))||1);bF+=bQ(((aU=B[u])===\"T\"||aU===\"t\"||aU==="
-"' ')&&(++u,cu(2))||0,B[u]===\":\"&&(++u,cu(2))||0,B[u]===\":\"&&(++u,cu(2))||0,B[u]===\".\"&&(++u,cu(3))||0);while((aU"
-"=B[u])!==void 0&&aU!==\"Z\"&&aU!==\"z\"&&aU!==\"+\"&&aU!==\"-\")++u;if(aU===\"Z\"||aU===\"z\")cr=0;else if(aU===\"+\"|"
-"|aU===\"-\"){++u,cs=cu(2)*36e5,B[u]===\":\"&&++u,cs+=d(ct=cu(2))?0:ct*6e4,d(cs)||(cr=aU===\"-\"?-cs:cs)}return(cr===vo"
-"id 0?bW(bF):bF-cr)}),UTC:c(function UTC(cf,cg,cl,cm,cn,co,bU){return c2(ck(cf,cg,cl,cm,cn,co,bU))})});Q(Date.prototype"
-",{dontEnum:true},{constructor:Date,toISOString:c(function toISOString(){var B;if((B=cp(this))===null)throw m(\"Invalid"
-" time value\");return B}),toUTCString:c(function toUTCString(){var bF;if(d(bF=bI(this)))return\"Invalid Date\";return("
-"bM(bF)+' '+bN(bF))}),toString:c(function toString(){return bL(bI(this))}),toDateString:c(function toDateString(){var a"
-"2;if(d(a2=bJ(this)))return\"Invalid Date\";return bM(a2)}),toTimeString:c(function toTimeString(){var a2;if(d(a2=bJ(th"
-"is)))return\"Invalid Date\";return bN(a2)}),toLocaleString:Object.prototype.toLocaleString,toLocaleDateString:c(functi"
-"on toLocaleDateString(){return this.toDateString()}),toLocaleTimeString:c(function toLocaleTimeString(){return this.to"
-"TimeString()}),valueOf:c(function valueOf(){return bI(this)}),getTime:c(function getTime(){return bI(this)}),getFullYe"
-"ar:c(function getFullYear(){return c4(bJ(this))[0]}),getUTCFullYear:c(function getUTCFullYear(){return c4(bI(this))[0]"
-"}),getMonth:c(function getMonth(){return c4(bJ(this))[1]}),getUTCMonth:c(function getUTCMonth(){return c4(bI(this))[1]"
-"}),getDate:c(function getDate(){return c4(bJ(this))[2]}),getUTCDate:c(function getUTCDate(){return c4(bI(this))[2]}),g"
-"etDay:c(function getDay(){return bX(bJ(this))}),getUTCDay:c(function getUTCDay(){return bX(bI(this))}),getHours:c(func"
-"tion getHours(){return bY(bJ(this))}),getUTCHours:c(function getUTCHours(){return bY(bI(this))}),getMinutes:c(function"
-" getMinutes(){return bZ(bJ(this))}),getUTCMinutes:c(function getUTCMinutes(){return bZ(bI(this))}),getSeconds:c(functi"
-"on getSeconds(){return c0(bJ(this))}),getUTCSeconds:c(function getUTCSeconds(){return c0(bI(this))}),getMilliseconds:c"
-"(function getMilliseconds(){return c1(bJ(this))}),getUTCMilliseconds:c(function getUTCMilliseconds(){return c1(bI(this"
-"))}),getTimezoneOffset:c(function getTimezoneOffset(){var G=bI(this);return(G-bG(G))/6e4}),setTime:c(function setTime("
-"time){return bK(c2(+time))}),setMilliseconds:c(function setMilliseconds(bU){return bK(this,c3(cj(bJ(this),3,arguments)"
-"))}),setUTCMilliseconds:c(function setUTCMilliseconds(bU){return bK(this,c2(cj(bI(this),3,arguments)))}),setSeconds:c("
-"function setSeconds(B,bU){return bK(this,c3(cj(bJ(this),2,arguments)))}),setUTCSeconds:c(function setUTCSeconds(B,bU){"
-"return bK(this,c2(cj(bI(this),2,arguments)))}),setMinutes:c(function setMinutes(aT,B,bU){return bK(this,c3(cj(bJ(this)"
-",1,arguments)))}),setUTCMinutes:c(function setUTCMinutes(aT,B,bU){return bK(this,c2(cj(bI(this),1,arguments)))}),setHo"
-"urs:c(function setHours(cv,aT,B,bU){return bK(this,c3(cj(bJ(this),0,arguments)))}),setUTCHours:c(function setUTCHours("
-"cv,aT,B,bU){return bK(this,c2(cj(bI(this),0,arguments)))}),setDate:c(function setDate(cl){return bK(this,c3(ci(bJ(this"
-"),2,arguments)))}),setUTCDate:c(function setUTCDate(cl){return bK(this,c2(ci(bI(this),2,arguments)))}),setMonth:c(func"
-"tion setMonth(cg,cl){return bK(this,c3(ci(bJ(this),1,arguments)))}),setUTCMonth:c(function setUTCMonth(cg,cl){return b"
-"K(this,c2(ci(bI(this),1,arguments)))}),setFullYear:c(function setFullYear(cf,cg,cl){var G;return bK(this,c3(ci(d(G=bI("
-"this))?0:bG(G),0,arguments)))}),setUTCFullYear:c(function setUTCFullYear(cf,cg,cl){var G;return bK(this,c2(ci(d(G=bI(t"
-"his))?0:G,0,arguments)))}),toJSON:c(function toJSON(){return cp(this)})});var G=1;var cw=G,cx=(G<<=1),cy=(G<<=1),cz=(G"
-"<<=1),cA=(G<<=1),cB=(G<<=1),cC=(G<<=1),cD=(G<<=1),cE=(G<<=1),cF=(G<<=1),cG=(G<<=1);var CC={};(function(){function cH(c"
-"I,cJ){for(var u in cJ)CC[cJ[u]]|=cI}cH(cE,\"^$.*+?()[]{}|\");cH(cA|cC|cz,\"0123456789\");cH(cC|cB|cz,\"abcdefABCDEF\")"
-";cH(cB|cz,\"ghijklmnopqrstuvwxyzGHIJKLMNOPQRSTUVWXYZ\");cH(cx|cy,\"\\n\\r\\u2028\\u2029\");cH(cy,\" \\t\\v\\f\\xA0\");"
-"CC['_']|=cz;CC[\"undefined\"]|=cw;CC['']|=cw;cH(cD,\"fnrtv\");for(var u=32;u<=126;++u){var au=a.fromCharCode(u);if(au!"
-"=='\"'&&au!=='\\\\')CC[a.fromCharCode(u)]|=cF}var cK=[0,48,58,65,91,95,96,97,123,128];for(var u=cK.length-2;u>=0;u-=2)"
-"for(var b7=cK[u],cL=cK[u+1];b7<cL;++b7)CC[a.fromCharCode(b7)]|=cG})();function regExpCanonicalize(B){var H='',au,cb;if"
-"(!as)at();for(var u=0,ay=B.length;u<ay;++u)H+=((cb=as[au=B[u]])&&cb.length===1&&(au<'\\x80'||cb>='\\x80')?cb:au);retur"
-"n H}function cM(B,cN,cO){var X=0,cP='',cQ=0,cR=0,cS='',cT=0;function cU(cV,cI){return((CC[cV]&cI)!==0)}function cW(B,c"
-"I){for(var u=B.length-1;u>=0;--u)if((CC[B[u]]&cI)===0)return false;return true}var cX={'D':[cA,true],'d':[cA,false],'S"
-"':[cy,true],'s':[cy,false],'W':[cz,true],'w':[cz,false],'.':[cx,true]};function cY(cZ){var C=cZ;if(cU(B[X],cA)){C=0;do"
-"{C=C*10+(k(B,X)-48);++X}while(cU(B[X],cA))}return C}function d0(){var d1=0,d2=h,d3=true;switch(B[X]){case'*':++X;break"
-";case'+':++X;d1=1;break;case'?':++X;d2=1;break;case'{':{var y=X;++X;if((d1=d2=cY(-1))<0){X=y;return null}if(B[X]===','"
-"){++X;d2=cY(h)}if(B[X]!=='}'){X=y;return null}if(d1>d2){throw l(\"Min greater than max in regular expression quantifie"
-"r\")}++X;break}default:return null}if(B[X]==='?'){++X;d3=false}return{d1:d1,d2:d2,d3:d3}}function d4(au){if(cU(au,cF))"
-"return au;return(au<='~'?\"\\\\x\":\"\\\\u\")+a1(ad(k(au,0),16),(au<='~'?2:4))}function d5(au){return d4(cN?regExpCano"
-"nicalize(au):au)}function d6(){var d7,d8,d9;if((d7=B[X])==='\\\\'){switch(d8=B[X+1]){case'0':{if(!cU(B[X+2],cA)){X+=2;"
-"return'\\0'}break}case'c':{if(cU(B[X+2],cB)){X+=3;return a.fromCharCode(k(B,X-1)&31)}break}case'x':case'u':{var C=(d8="
-"=='x'?2:4);if(cW(d9=$sub(B,X+2,X+2+C),cC)){X+=2+C;return a.fromCharCode(parseInt(d9,16))}break}default:{if(cU(d8,cD)){"
-"X+=2;return eval('\"\\\\'+d8+'\"')}else if(cU(d8,cG)){X+=2;return d8}break}}}else if(d7){++X;return d7}}function da(){"
-"var db=[],G,C=0;while(!cU(B[X],cE)&&(G=d6()))db[C++]=d5(G);return(db.length?db:null)}function dc(){var G,dd,au;if((au="
-"B[X])!==']'&&(G=d6()))return G;if(au==='\\\\'){if((au=B[X+1])==='b'){X+=2;return'\\b'}if(dd=cX[au]){X+=2;return dd}}}f"
-"unction de(ba){return(ba===0?'p':((ba<0?'p':'p+')+ba))}function df(db,ba){if(db.length===0)return\"true\";else if(db.l"
-"ength===1)return\"s[\"+de(ba)+']===\"'+db[0]+'\"';else if(db.length===2)return\"s[\"+de(ba)+']===\"'+db[0]+'\" && s['+"
-"de(ba+1)+']===\"'+db[1]+'\"';else{for(var u=0,B='',a2=db.length;u<a2;++u)B+=db[u];return\"$match(s,\"+de(ba)+',\"'+B+'"
-"\")'}}function dg(aM,y){switch(aM){case\"false\":return\"false\";case\"true\":return y;default:return(y===\"true\"?aM:"
-"aM+\" && \"+y)}}function dh(aM,y){switch(aM){case\"false\":return y;case\"true\":return\"true\";default:return(y===\"f"
-"alse\"?aM:aM+\" || \"+y)}}function di(name,dj){cP+=\"\\tfunction \"+name+\"(p) { \"+dj+\" }\\n\"}function dk(dl,ba,dm,"
-"dn,dp,dq){var dr='q'+(++cQ),ds=(dq?\"var h=\"+dq+\",\":\"var \")+(dp.d1?\"b=p+\"+dp.d1+(dq?\"*h\":\"\"):\"b=p\")+(dp.d"
-"2<h?\",e=p+\"+dp.d2+(dq?\"*h\":\"\"):\"\")+\"; \";if(dq)ds+=\"if (h<=0 || h!==h) return \"+dn+\"; \";if(dp.d3){di(dr,d"
-"s+\"while (\"+dg((dp.d2<h?\"p<e\":\"true\"),dm)+\") \"+(dq?\"p+=h\":\"++p\")+\"; while (\"+dg(\"p>=b\",\"!(\"+dn+\")\""
-")+\") \"+(dq?\"p-=h\":\"--p\")+\"; return p>=b\")}else{di(dr,ds+\"while (\"+dh((dp.d1?\"p<b\":\"false\"),\"!(\"+dn+\")"
-"\")+\") { if (\"+dh((dp.d2<h?\"p>=e\":\"false\"),\"!(\"+dm+\")\")+\") return false; \"+(dq?\"p+=h\":\"++p\")+\" }; ret"
-"urn true\")}return dg(dl,dr+\"(\"+de(ba)+\")\")}function dt(dl,du,dv,dw){if(du===null&&dv===dw){return\"return \"+dl}e"
-"lse{var dx='',dy='',dz='';if(du!==null){dx+='r'+du+\"=c\"+du;dy='c'+du+\"=p\";dz='c'+du+\"=r\"+du}if(dw!==void 0){for("
-"var u=dv;u<dw;++u){var b7=u*2;if(du!==null||u>dv){dx+=',';dz+=',';if(u===dv){dy+=','}}dx+='r'+b7+\"=c\"+b7;dy+='c'+b7+"
-"'=';dz+='c'+b7+\"=r\"+b7;if(u===dw-1){dy+=\"void 0\"}}}dl=dy+\", \"+dh(dl,'('+dz+\",false)\");return\"var \"+dx+\"; re"
-"turn \"+dl}}function dA(aU,dd){return(dd[1]?'!':\"!!\")+\"(CC[\"+aU+\"]&\"+(dd[0]|(dd[1]?cw:0))+')'}function dB(ba,dC)"
-"{var db,dp,dl=\"true\";dD:for(;;){if(db=da()){if(dp=d0()){var dE=db[db.length-1];--db.length;return dk(dg(dl,df(db,ba)"
-"),ba+db.length,df(dE,0),dB(0,dC),dp)}dl=dg(dl,df(db,ba));ba+=db.length}else{var au,dF,dn,dG,dH;switch(au=B[X]){case'^'"
-":{++X;dF=de(ba)+\"===0\";if(cO)dF='('+dh(dF,\"!!(CC[s[\"+de(ba-1)+\"]]&\"+cx+')')+')';dl=dg(dl,dF);break}case'$':{++X;"
-"dF=de(ba)+\"===l\";if(cO)dF='('+dh(dF,\"!!(CC[s[\"+de(ba)+\"]]&\"+cx+')')+')';dl=dg(dl,dF);break}case'[':{var dI=false"
-",dJ,dK,dL=\"false\";if(B[++X]==='^'){dI=true;++X}while(dJ=dc()){var y=X;if(B[X]==='-'&&(++X,dK=dc())){if(typeof dJ==="
-"\"string\"&&typeof dK===\"string\"&&dJ<=dK){if(cN&&(dJ>'~'||dK>'~'||(regExpCanonicalize(dJ)!==dJ)!==(regExpCanonicaliz"
-"e(dK)!==dK))){dJ=d4(dJ);dK=d4(dK);dL=dh(dL,dg('upperToLower[c]>=\"'+dJ+'\"','upperToLower[c]<=\"'+dK+'\"'))}else{dJ=d5"
-"(dJ);dK=d5(dK)}dL=dh(dL,dg('c>=\"'+dJ+'\"','c<=\"'+dK+'\"'))}else{throw l(\"Invalid character class syntax in regular "
-"expression\")}}else if(typeof dJ===\"string\"){X=y;dL=dh(dL,'c===\"'+d5(dJ)+'\"')}else{dL=dh(dL,dA('c',dJ))}}if(B[X]!="
-"=']'){throw l(\"Invalid character class syntax in regular expression\")}++X;var dr='k'+(++cQ);di(dr,\"var c=s[p]; retu"
-"rn \"+(dI?\"p!==l && !(\"+dL+')':dL));if(dp=d0()){return dk(dl,ba,dr+'('+de(0)+')',dB(0,dC),dp)}dl=dg(dl,dr+'('+de(ba)"
-"+')');++ba;break}case'\\\\':{var C;++X;if((C=cY(-1))>=0){if(C>cT)cT=C;C=(C-1)*2;dp=d0();var dq='c'+(C+1)+\"-c\"+C,dM="
-"\"$match(s,\"+de(ba)+\",$sub(s, c\"+C+\",c\"+(C+1)+\"))\";dn=dB(0,dC);var dN='t'+(++cQ);di(dN,\"return \"+dn);return d"
-"p?dk(dl,ba,dM,dN+'('+de(0)+')',dp,dq):dg(dl,'(c'+C+\"<c\"+(C+1)+\" ? \"+dg(dM,dN+'('+de(ba)+'+'+dq+')')+\" : \"+dN+'('"
-"+de(ba)+\"))\")}else if((au=B[X])==='b'||au==='B'){++X;dl=dg(dl,(au==='b'?\"!!((CC[s[\":\"!((CC[s[\")+de(ba-1)+\"]]^CC"
-"[s[\"+de(ba)+\"]])&\"+cz+')');break}}case'.':{var dd;if(!(dd=cX[au]))throw l(\"Invalid escape in regular expression\")"
-";++X;if(dp=d0()){return dk(dl,ba,dA(\"s[\"+de(0)+']',dd),dB(0,dC),dp)}dl=dg(dl,dA(\"s[\"+de(ba)+']',dd));++ba;break}ca"
-"se'(':{var dO=++cQ,dP='g'+dO,dQ=dP+'('+de(ba)+')',dR='j'+dO,dS=dR+'('+de(ba)+')',dT=true,dU=false,dV=false;++X;if(B[X]"
-"==='?'){switch(B[X+1]){case'!':dV=true;case'=':dU=true;case':':dT=false;X+=2}}var dW=null,dX=null;if(dT){(dX=(dW=(cR++"
-")*2)+1);cS+=\",c\"+dW+\",c\"+dX}var dY=cR,dZ=e0(0,(dU?void 0:dR)),e1=cR;if((au=B[X])!==')'){throw l(au?\"Unterminated "
-"group in regular expression\":\"Invalid regular expression\")}++X;dp=(dU?null:d0());dn=dB(0,dC);dH=dZ;var e2='',e3=(dp"
-"&&dp.d2>1);if(e3&&(dp.d2<h||dp.d1>1)){cS+=\",n\"+dO+\"=0\";dH=((dp.d2<h)?dg(\"++n\"+dO+\"<=\"+dp.d2,dH):\"++n\"+dO+\","
-" \"+dH);if(dp.d1>1){dH=dg(dH,'n'+dO+\">=\"+dp.d1);e2='n'+dO+'<'+dp.d1}dH=dh(dH,\"(--n\"+dO+\",false)\")}if(dU){dG=dR+'"
-"('+de(0)+')';if(dV){dH=\"!(\"+dH+')';if(dY<e1){var e4='';for(var u=dY;u<e1;++u)e4+='c'+u*2+'=';dG='('+e4+\"void 0, \"+"
-"dG+')'}}dH=dg(dH,dG)}if(e3){cS+=\",p\"+dO;var e5='p'+dO+\"!=p\";dH=dg(e2?'('+dh(e5,e2)+')':e5,\"(p\"+dO+\"=p, \"+dH+')"
-"')}di(dP,dt(dH,dW,dY,e1));if(e3){var e6=dP+'('+de(0)+')';dH=(dp.d3?dh(e6,dn):dh(dn,e6));di(dR,dt(dH,dX));dG=(dp.d1===0"
-"?dS:dQ);dl=dg(dl,'(p'+dO+\"=void 0,\"+dG+')')}else{di(dR,dt(dn,dX));dl=((dp&&dp.d1===0)?dg(dl,(dp.d2===0?dS:'('+(dp.d3"
-"?dh(dQ,dS):dh(dS,dQ))+')')):dg(dl,dQ))}return dl}default:break dD}}}switch(dC){case void 0:return dl;case'':return dg("
-"dl,\"(q=\"+de(ba)+\",true)\");default:return dg(dl,dC+'('+de(ba)+')')}}function e0(ba,dC){var dl=dB(ba,dC);if(B[X]==='"
-"|'){do{++X;dl=dh(dl,dB(ba,dC))}while(B[X]==='|');dl='('+dl+')'}return dl}var dZ=e0(0,'');if(X<B.length)throw l(\"Inval"
-"id regular expression\");if(cT>cR)throw l(\"Invalid back reference in regular expression\");var dl=\"(function(s, p) {"
-"\\n\";if(cN)dl+=\"\\ts=regExpCanonicalize(s)\\n\";dl+=\"\\tvar l=s.length,q\";dl+=cS+\";\\n\"+cP+\"\\tif (\"+dZ+\") re"
-"turn [p,q\";for(var u=0;u<cR*2;++u)dl+=\",c\"+u;dl+=\"];\\n})\";return dl}var e7={'g':\"global\",'i':\"ignoreCase\",'m"
-"':\"multiline\"},e8={},e9;function ea(b4,a7){a7=P(a7);var u;if((u=(b4.global?M(b4.lastIndex):0))>=0){var aW=i(b4,\"val"
-"ue\"),ay=a7.length,aT;for(;u<=ay;++u)if(aT=aW(a7,u)){if(b4.global)b4.lastIndex=aT[1];return aT}}b4.lastIndex=0}functio"
-"n aL(b4,a7){var aT,aM=null;if(aT=ea(b4,a7)){(aM=[]).input=a7;aM.index=aT[0];for(var b7=0;b7<aT.length;b7+=2)aM[aM.leng"
-"th]=((aT[b7]===void 0)?void 0:$sub(a7,aT[b7],aT[b7+1]))}return aM}function eb(b4){return(b4.global?'g':'')+(b4.ignoreC"
-"ase?'i':'')+(b4.multiline?'m':'')}var RegExp=a.distinctConstructor(function RegExp(ec,ed){return(i(ec,\"class\")===\"R"
-"egExp\"&&ed===void 0?ec:new a.createRegExp(ec,ed))},a.createRegExp=function RegExp(ec,ed){if(i(ec,\"class\")===\"RegEx"
-"p\"){if(ed!==void 0)throw n(\"Cannot supply flags when constructing one RegExp from another\");ed=eb(ec);ec=ec.source}"
-"ec=(ec===void 0?'':P(ec));ed=(ed===void 0?'':P(ed));var ee={global:false,ignoreCase:false,multiline:false,source:ec};f"
-"or(var u=ed.length-1;u>=0;--u){var X;if(!(X=e7[ed[u]])||ee[X])throw l(\"Invalid regular expression flags\");ee[X]=true"
-"}var ef,eg;if(!(eg=e8[ef=ec+','+ee.ignoreCase+','+ee.multiline]))e8[ef]=eg=ah(cM(ec,ee.ignoreCase,ee.multiline));var b"
-"4=a.createWrapper(\"RegExp\",eg,e9);Q(b4,{dontEnum:true,readOnly:true,dontDelete:true},ee);Q(b4,{dontEnum:true,dontDel"
-"ete:true},{lastIndex:0});return b4});Q(RegExp,{dontEnum:true,readOnly:true,dontDelete:true},{prototype:e9=RegExp.proto"
-"type});Q(RegExp.prototype,{dontEnum:true},{exec:c(function exec(a7){Y(this,\"RegExp\",\"exec\");return aL(this,a7)}),t"
-"est:c(function test(a7){Y(this,\"RegExp\",\"test\");return ea(this,a7)!==void 0}),toString:c(function toString(){Y(thi"
-"s,\"RegExp\",\"toString\");return'/'+this.source+'/'+eb(this)})});Q(b,{dontEnum:true},{Array:Array,Boolean:Boolean,Dat"
+"\"\\uff56\",\"\\uff37\":\"\\uff57\",\"\\uff38\":\"\\uff58\",\"\\uff39\":\"\\uff59\",\"\\uff3a\":\"\\uff5a\"};for(av in"
+" aw)at[upperToLower[av]=aw[av]]=av};function ax(a8,ay){var v=-1,az=a8.length,C='',I,av;while(++v<az)C+=(I=ay[av=a8[v]]"
+")?I:av;return C}function aA(K){if(!at)au();return ax(Q(K),upperToLower)}function aB(K){if(!at)au();return ax(Q(K),at)}"
+"var String=a.distinctConstructor(function String(H){return(arguments.length?Q(H):'')},function String(H){var C;return "
+"R(a.createWrapper(\"String\",(C=(arguments.length?Q(H):'')),a.prototypes.String),{readOnly:true,dontEnum:true,dontDele"
+"te:true},{length:C.length})});R(String,{dontEnum:true,readOnly:true,dontDelete:true},{prototype:a.prototypes.String});"
+"R(String,{dontEnum:true},{fromCharCode:d(function fromCharCode(H){var aC,al;if((aC=(al=arguments).length)===1)return a"
+".fromCharCode(H&65535);for(var v=0,C='';v<aC;++v)C+=a.fromCharCode(al[v]&65535);return C})});R(String.prototype,{dontE"
+"num:true},{constructor:String,charAt:d(function charAt(aD){var C;return(((aD=N(aD))<0||aD>=(C=Q(this)).length)?'':C[aD"
+"])}),charCodeAt:d(function charCodeAt(aD){return l(Q(this),+aD)}),concat:d(function concat(aE){var aF,D=(aF=arguments)"
+".length,C=Q(this);for(var v=0;v<D;++v)C+=Q(aF[v]);return C}),indexOf:d(function indexOf(aG){var C,v,aH=(C=Q(this)).len"
+"gth-(aG=Q(aG)).length,aD=arguments[1];if((v=N(aD))<0)v=0;for(;v<=aH;++v)if($match(C,v,aG))return v;return-1}),lastInde"
+"xOf:d(function lastIndexOf(aG){var C,v,aH=(C=Q(this)).length-(aG=Q(aG)).length,aD=arguments[1];if(e(aD=+aD)||(v=N(aD))"
+">aH)v=aH;for(;v>=0;--v)if($match(C,v,aG))return v;return-1}),localeCompare:d(function localeCompare(aI){var aJ,aK;retu"
+"rn((aJ=Q(this))===(aK=Q(aI))?0:(aJ<aK?-1:1))}),match:d(function match(aL){if(j(aL,\"class\")!==\"RegExp\")aL=new RegEx"
+"p(aL);var C=Q(this);if(!aL.global)return aM(aL,C);var v=aL.lastIndex=0,aN=[],aO;do{if(!(aO=aM(aL,C)))return(v===0?null"
+":aN);if(!(aN[v++]=aO[0]))++aL.lastIndex}while(true)}),replace:d(function replace(aP,aQ){var C,aR=(C=Q(this)).length,aS"
+"=aQ,aT,v,Y,I,a3,aH;if(typeof aS!==\"function\"){var aO=Q(aQ);for(v=aO.length;--v>=0&&aO[v]!='$';);aS=(v<0?function(){r"
+"eturn aO}:function(aU){var I='',Y,aV,aW,av,D;for(Y=0;aV=aO[Y];++Y){if(aV!=='$')I+=aV;else switch(aV=aO[++Y]){case(void"
+" 0):case'$':I+='$';break;case'&':I+=aU;break;case'`':I+=$sub(C,0,arguments[arguments.length-2]);break;case\"'\":I+=$su"
+"b(C,arguments[arguments.length-2]+aU.length,aR);break;default:{if(aV>='0'&&aV<='9'){if(!(aW=aO[Y+1])||aW<'0'||aW>'9')a"
+"W='';if((D=+(aV+aW))>=1&&D<arguments.length-2){I+=((av=arguments[D])===void 0?'':av);Y+=aW.length;break}}I+='$'+aV;bre"
+"ak}}}return I})};if(j(aP,\"class\")===\"RegExp\"){Y=0;I=new y;if(aP.global)aP.lastIndex=0;while(aT=aM(aP,C)){aT[v=aT.l"
+"ength]=aT.index;aT[v+1]=C;I.B($sub(C,Y,aT.index)+Q(k(aS,null,aT)));Y=aT.index+(a3=aT[0].length);if(!aP.global)break;if"
+"(a3===0)++aP.lastIndex}return(I.B($sub(C,Y,aR))).F()}else{aH=aR-(a3=(I=Q(aP)).length);for(var Y=0;!$match(C,Y,I);++Y)i"
+"f(Y>=aH)return C;return $sub(C,0,Y)+Q(k(aS,null,[I,Y,C]))+$sub(C,Y+a3,aR)}}),search:d(function search(aL){if(j(aL,\"cl"
+"ass\")!==\"RegExp\")aL=new RegExp(aL);var C,az=(C=Q(this)).length,aX=j(aL,\"value\");for(var v=0;v<=az;++v)if(aX(C,v))"
+"return v;return-1}),slice:d(function slice(aY,aZ){var C=Q(this);if((aY=N(aY))<0)aY+=C.length;if(aZ===void 0)aZ=i;else "
+"if((aZ=N(aZ))<0)aZ+=C.length;return $sub(C,aY,aZ)}),split:d(function split(b0,b1){var C,aR=(C=Q(this)).length,aN=[],b2"
+"=0,b3;if(!(b1=((b1===void 0)?0xFFFFFFFF:P(b1))))return aN;if(b0===void 0)return[C];if(j(b0,\"class\")!==\"RegExp\"){va"
+"r b4=(b0=Q(b0)).length;b3=function(Y){if($match(C,Y,b0))return[Y,Y+b4]}}else{var b5=j(b0,\"value\");b3=function(Y){ret"
+"urn b5(C,Y)}}if(!aR)return(b3(0)?aN:[C]);var Y,z=Y=0,aU,aH;while(Y!==aR){if(!(aU=b3(Y))||(aH=aU[1])===z)++Y;else{aU[0]"
+"=z;aU[1]=Y;Y=z=aH;for(var v=0;v<aU.length;v+=2){aN[b2]=(aU[v]===void 0?void 0:$sub(C,aU[v],aU[v+1]));if(++b2===b1)retu"
+"rn aN}}}aN[b2]=$sub(C,z,aR);return aN}),substr:d(function substr(aY,length){var C=Q(this);if((aY=N(aY))<0)aY=C.length+"
+"aY;return $sub(C,aY,(length===void 0?i:aY+N(length)))}),substring:d(function substring(aY,aZ){aY=N(aY);if(aZ===void 0)"
+"aZ=i;else if((aZ=N(aZ))<aY){var b6=aY;aY=aZ;aZ=b6}return $sub(Q(this),aY,aZ)}),toUpperCase:d(function toUpperCase(){re"
+"turn aB(this)}),toLocaleUpperCase:d(function toLocaleUpperCase(){return aB(this)}),toLowerCase:d(function toLowerCase("
+"){return aA(this)}),toLocaleLowerCase:d(function toLocaleLowerCase(){return aA(this)}),valueOf:d(function valueOf(){Z("
+"this,\"String\",\"valueOf\");return j(this,\"value\")}),toString:d(function toString(){Z(this,\"String\",\"toString\")"
+";return j(this,\"value\")})});var Array=function Array(H){var aN=[],al,aC;if((aC=(al=arguments).length)===1&&typeof H="
+"==\"number\"){if((H>>>0)!==H)throw n(\"Invalid array length\");aN.length=H}else{for(var v=0;v<aC;++v)aN[v]=al[v]}retur"
+"n aN};R(Array,{dontEnum:true,readOnly:true,dontDelete:true},{prototype:a.prototypes.Array});R(Array.prototype,{dontEnu"
+"m:true},{constructor:Array,concat:d(function concat(b7){var aN=[],al,aC=(al=arguments).length,D=0,H=this;for(var v=-1;"
+"v<aC;H=al[++v]){if(j(H,\"class\")!==\"Array\"){aN[D++]=H}else{for(var b8=0,aH=H.length;b8<aH;++b8)if(b8 in H)aN[D+b8]="
+"H[b8];aN.length=(D+=b8)}}return aN}),join:d(function join(b0){var C=new y,b9,az=P(this.length);b0=(b0===void 0?',':Q(b"
+"0));for(var v=0;v<az;++v){if(v>0)C.B(b0);if((b9=this[v])!=null)C.B(Q(b9))}return C.F()}),pop:d(function pop(){var H=vo"
+"id 0,az;if((az=P(this.length))>0)H=this[--az];this.length=az;return H}),push:d(function push(ba){var al,bb=P(this.leng"
+"th),aZ=(al=arguments).length+bb;for(var v=bb;v<aZ;++v)this[v]=al[v-bb];return(this.length=aZ)}),reverse:d(function rev"
+"erse(){var az,bc=g((az=P(this.length))/2);--az;for(var bd=0;bd<bc;++bd){var be=az-bd;var bf=(be in this),bg=this[be];i"
+"f(bd in this)this[be]=this[bd];else delete this[be];if(bf)this[bd]=bg;else delete this[bd]}return this}),shift:d(funct"
+"ion shift(){var az,bh;if(az=P(this.length)){bh=this[0];for(var v=1;v<az;++v){if(v in this)this[v-1]=this[v];else delet"
+"e this[v-1]}--az};this.length=az;return bh}),slice:d(function slice(aY,aZ){var aN=[],az=P(this.length);if((aY=N(aY))<0"
+"){aY+=az;if(aY<0)aY=0}if(aZ===void 0||(aZ=N(aZ))>az)aZ=az;else if(aZ<0)aZ+=az;for(var v=aY,b8=0;v<aZ;++v,++b8)if(v in "
+"this)aN[b8]=this[v];aN.length=b8;return aN}),sort:d(function sort(bi){var bj=this;function b6(bk,bl,bm){var bn=(bl in "
+"bk),bo=bk[bl];if(bm in bk)bk[bl]=bk[bm];else delete bk[bl];if(bn)bk[bm]=bo;else delete bk[bm]};function bp(bk,bl,bm){i"
+"f(!(bl in bk)&&!(bm in bk))return 0;else if(!(bl in bk))return 1;else if(!(bm in bk))return-1;else{var aN=bk[bl];var z"
+"=bk[bm];if(aN===void 0&&z===void 0)return 0;else if(aN===void 0)return 1;else if(z===void 0)return-1;else return bi(aN"
+",z)}};function bq(br,bs){var bt=b6,bu=bp,bk=bj,bc,bv;for(--bs;br+1<bs;br=bv){var bw=bs;bv=br;bc=g((bv+bw)/2);while(bv<"
+"bw){while(bv<=bw&&bu(bk,bv,bc)<=0&&bu(bk,bw,bc)>=0){++bv;--bw}while(bv<=bw&&bu(bk,bw,bc)>0)--bw;while(bv<=bw&&bu(bk,bv"
+",bc)<0)++bv;if(bc===bv||bc===bw)bc^=bw^bv;if(bv<bw)bt(bk,bv,bw)}bq(br,bv)}if(br<bs&&bu(bk,br,bs)>0)bt(bk,br,bs)};if(bi"
+"===void 0){bi=function(aN,z){return((aN=Q(aN))<(z=Q(z))?-1:(aN>z?1:0))}};bq(0,this.length>>>0);return this}),splice:d("
+"function splice(aY,bx){var aN=[],az=P(this.length),al,aC=(al=arguments).length,aZ,by,bz;if((aY=N(aY))<0){aY+=az;if(aY<"
+"0)aY=0}else if(aY>az)aY=az;if(aC==1||(aZ=aY+N(bx))>az)aZ=az;else if(aZ<aY)aZ=aY;for(var v=aY,b8=0;v<aZ;++v,++b8)if(v i"
+"n this)aN[b8]=this[v];aN.length=b8;if((by=aC-2)<0)by=0;if((bz=aY+by-aZ)!==0){var bA=1,b8=aZ;if(bz>0){bA=-1;b8=az-1}for"
+"(v=az-aZ;--v>=0;b8+=bA){if(b8 in this)this[b8+bz]=this[b8];else delete this[b8+bz]}for(v=az;--v>=az+bz;)delete this[v]"
+"}for(v=2,b8=aY;v<aC;++v,++b8)this[b8]=al[v];this.length=az+bz;return aN}),toLocaleString:Object.prototype.toLocaleStri"
+"ng,toString:d(function toString(){Z(this,\"Array\",\"toString\");return this.join()}),unshift:d(function unshift(b7){v"
+"ar az,al,D=(al=arguments).length;if(az=P(this.length)){for(var v=az;--v>=0;){if(v in this)this[v+D]=this[v];else delet"
+"e this[v+D]}}for(var v=0;v<D;++v)this[v]=al[v];return(this.length=az+D)})});function bB(){var bC=a.localTimeDifference"
+"(14516064e5);var bD=a.localTimeDifference(14673312e5);return(bC>bD?bC:bD)}function bE(){var bC=a.localTimeDifference(1"
+"4516064e5);var bD=a.localTimeDifference(14673312e5);return(bC<bD?bC:bD)}function bF(bG){var a3=a.localTimeDifference(b"
+"G);return(e(a3)?bE():a3)}function bH(bG){return e(bG)?bG:bG+bF(bG)}function bI(S){if(j(S,\"class\")!==\"Date\")throw o"
+"(\"this is not a Date object\")}function bJ(S){bI(S);return j(S,\"value\")}function bK(S){return bH(bJ(S))}function bL"
+"(S,H){bI(S);a.updateDateValue(S,H);return H}function bM(H){return e(H=bH(H))?\"Invalid Date\":(bN(H)+' '+bO(H))}functi"
+"on bP(bQ,D){return(bQ%D+D)%D}function bR(bS,bT,bU,bV){return bS*36e5+bT*6e4+bU*1e3+bV}function bW(bG){return[bP(g(bG/3"
+"6e5),24),bP(g(bG/6e4),60),bP(g(bG/1e3),60),bP(bG,1e3)]}function bX(bG){return e(bG)?bG:(bG-bF(bG-bB()))}function bY(bG"
+"){return bP(g(bG/864e5)+4,7)}function bZ(bG){return bP(g(bG/36e5),24)}function c0(bG){return bP(g(bG/6e4),60)}function"
+" c1(bG){return bP(g(bG/1e3),60)}function c2(bG){return bP(bG,1e3)}function c3(bG){return(!f(bG)||abs(bG)>8.64e15?h:N(b"
+"G))}function c4(bG){return bX(c3(bG))}function c5(bG){bG=g(bG/864e5)+719468;var c6=N((bG>=0?bG:bG-146096)/146097);var "
+"c7=bG-c6*146097;var c8=N((c7-N(c7/1460)+N(c7/36524)-N(c7/146096))/365);var c9=c8+c6*400;var ca=c7-(365*c8+N(c8/4)-N(c8"
+"/100));var cb=N((5*ca+2)/153);var aU=cb+(cb<10?2:-10);var cc=ca-N((153*cb+2)/5)+1;return[(c9+(aU<=1)),aU,cc]}function "
+"bN(bG){var c9,cd=c5(bG);return(0<=(c9=cd[0])&&c9<=9999?a2(c9,4):(c9<0?\"-\":\"+\")+a2(abs(c9),6))+\"-\"+a2(cd[1]+1,2)+"
+"\"-\"+a2(cd[2],2)}function bO(bG,bV){var ce=bW(bG);return a2(ce[0],2)+\":\"+a2(ce[1],2)+\":\"+a2(ce[2],2)+(bV?\".\"+a2"
+"($sub(ce[3],0,3),3):\"\")}function cf(cg,ch,ci){cg+=g(ch/12)-(bP(ch,12)<=1);var c6=N((cg>=0?cg:cg-399)/400);var c8=cg-"
+"c6*400;var ca=N((153*(ch+(ch>1?-2:10))+2)/5)+ci-1;var c7=c8*365+N(c8/4)-N(c8/100)+ca;return(c6*146097+c7-719468)*864e5"
+"}function cj(bG,D,aN){var v,cc=c5(bG),aO=bP(bG,864e5);for(v=0;v<aN.length;++v,++D)cc[D]=N(aN[v]);return k(cf,null,cc)+"
+"aO}function ck(bG,D,aN){var v,I=bW(bG),aO=g(bG/864e5)*864e5;for(v=0;v<aN.length;++v,++D)I[D]=N(aN[v]);return k(bR,null"
+",I)+aO}function cl(cg,ch,cm,cn,co,cp,bV){var aC=arguments.length;return cf((cg=N(cg))+(0<=cg&&cg<=99?1900:0),N(ch),(aC"
+">2?N(cm):1))+bR(aC>3?N(cn):0,aC>4?N(co):0,aC>5?N(cp):0,aC>6?N(bV):0)}function cq(cc){var bG;return e(bG=bJ(cc))?null:b"
+"N(bG)+\"T\"+bO(bG,true)+\"Z\"}var cr,Date=a.distinctConstructor(function Date(){return bM(a.getCurrentTime())},functio"
+"n Date(cg,ch,cm,cn,co,cp,bV){var H,aC;if((aC=arguments.length)>=2&&aC<=7)H=c4(k(cl,null,arguments));else if(aC===1)H=c"
+"3(typeof(H=a.toPrimitive(cg))===\"string\"?cr(H):+H);else H=a.getCurrentTime();return a.createWrapper(\"Date\",H,a.pro"
+"totypes.Date)});R(Date,{dontEnum:true,readOnly:true,dontDelete:true},{prototype:a.prototypes.Date});R(Date,{dontEnum:t"
+"rue},{parse:d(cr=function parse(C){var bG,c9,v,aV,cs,ct,cu,v=0;function cv(az){var H;for(H=0;--az>=0;)if(\"0\"<=C[v]&&"
+"C[v]<=\"9\")H=H*10+(+C[v++]);else return h;return H}bG=cf(((aV=C[v])===\"+\"||aV===\"-\")&&(++v,c9=cv(6),aV===\"-\"?-c"
+"9:c9)||cv(4),C[v]===\"-\"&&(++v,cv(2)-1)||0,C[v]===\"-\"&&(++v,cv(2))||1);bG+=bR(((aV=C[v])===\"T\"||aV===\"t\"||aV==="
+"' ')&&(++v,cv(2))||0,C[v]===\":\"&&(++v,cv(2))||0,C[v]===\":\"&&(++v,cv(2))||0,C[v]===\".\"&&(++v,cv(3))||0);while((aV"
+"=C[v])!==void 0&&aV!==\"Z\"&&aV!==\"z\"&&aV!==\"+\"&&aV!==\"-\")++v;if(aV===\"Z\"||aV===\"z\")cs=0;else if(aV===\"+\"|"
+"|aV===\"-\"){++v,ct=cv(2)*36e5,C[v]===\":\"&&++v,ct+=e(cu=cv(2))?0:cu*6e4,e(ct)||(cs=aV===\"-\"?-ct:ct)}return(cs===vo"
+"id 0?bX(bG):bG-cs)}),UTC:d(function UTC(cg,ch,cm,cn,co,cp,bV){return c3(cl(cg,ch,cm,cn,co,cp,bV))})});R(Date.prototype"
+",{dontEnum:true},{constructor:Date,toISOString:d(function toISOString(){var C;if((C=cq(this))===null)throw n(\"Invalid"
+" time value\");return C}),toUTCString:d(function toUTCString(){var bG;if(e(bG=bJ(this)))return\"Invalid Date\";return("
+"bN(bG)+' '+bO(bG))}),toString:d(function toString(){return bM(bJ(this))}),toDateString:d(function toDateString(){var a"
+"3;if(e(a3=bK(this)))return\"Invalid Date\";return bN(a3)}),toTimeString:d(function toTimeString(){var a3;if(e(a3=bK(th"
+"is)))return\"Invalid Date\";return bO(a3)}),toLocaleString:Object.prototype.toLocaleString,toLocaleDateString:d(functi"
+"on toLocaleDateString(){return this.toDateString()}),toLocaleTimeString:d(function toLocaleTimeString(){return this.to"
+"TimeString()}),valueOf:d(function valueOf(){return bJ(this)}),getTime:d(function getTime(){return bJ(this)}),getFullYe"
+"ar:d(function getFullYear(){return c5(bK(this))[0]}),getUTCFullYear:d(function getUTCFullYear(){return c5(bJ(this))[0]"
+"}),getMonth:d(function getMonth(){return c5(bK(this))[1]}),getUTCMonth:d(function getUTCMonth(){return c5(bJ(this))[1]"
+"}),getDate:d(function getDate(){return c5(bK(this))[2]}),getUTCDate:d(function getUTCDate(){return c5(bJ(this))[2]}),g"
+"etDay:d(function getDay(){return bY(bK(this))}),getUTCDay:d(function getUTCDay(){return bY(bJ(this))}),getHours:d(func"
+"tion getHours(){return bZ(bK(this))}),getUTCHours:d(function getUTCHours(){return bZ(bJ(this))}),getMinutes:d(function"
+" getMinutes(){return c0(bK(this))}),getUTCMinutes:d(function getUTCMinutes(){return c0(bJ(this))}),getSeconds:d(functi"
+"on getSeconds(){return c1(bK(this))}),getUTCSeconds:d(function getUTCSeconds(){return c1(bJ(this))}),getMilliseconds:d"
+"(function getMilliseconds(){return c2(bK(this))}),getUTCMilliseconds:d(function getUTCMilliseconds(){return c2(bJ(this"
+"))}),getTimezoneOffset:d(function getTimezoneOffset(){var H=bJ(this);return(H-bH(H))/6e4}),setTime:d(function setTime("
+"time){return bL(c3(+time))}),setMilliseconds:d(function setMilliseconds(bV){return bL(this,c4(ck(bK(this),3,arguments)"
+"))}),setUTCMilliseconds:d(function setUTCMilliseconds(bV){return bL(this,c3(ck(bJ(this),3,arguments)))}),setSeconds:d("
+"function setSeconds(C,bV){return bL(this,c4(ck(bK(this),2,arguments)))}),setUTCSeconds:d(function setUTCSeconds(C,bV){"
+"return bL(this,c3(ck(bJ(this),2,arguments)))}),setMinutes:d(function setMinutes(aU,C,bV){return bL(this,c4(ck(bK(this)"
+",1,arguments)))}),setUTCMinutes:d(function setUTCMinutes(aU,C,bV){return bL(this,c3(ck(bJ(this),1,arguments)))}),setHo"
+"urs:d(function setHours(cw,aU,C,bV){return bL(this,c4(ck(bK(this),0,arguments)))}),setUTCHours:d(function setUTCHours("
+"cw,aU,C,bV){return bL(this,c3(ck(bJ(this),0,arguments)))}),setDate:d(function setDate(cm){return bL(this,c4(cj(bK(this"
+"),2,arguments)))}),setUTCDate:d(function setUTCDate(cm){return bL(this,c3(cj(bJ(this),2,arguments)))}),setMonth:d(func"
+"tion setMonth(ch,cm){return bL(this,c4(cj(bK(this),1,arguments)))}),setUTCMonth:d(function setUTCMonth(ch,cm){return b"
+"L(this,c3(cj(bJ(this),1,arguments)))}),setFullYear:d(function setFullYear(cg,ch,cm){var H;return bL(this,c4(cj(e(H=bJ("
+"this))?0:bH(H),0,arguments)))}),setUTCFullYear:d(function setUTCFullYear(cg,ch,cm){var H;return bL(this,c3(cj(e(H=bJ(t"
+"his))?0:H,0,arguments)))}),toJSON:d(function toJSON(){return cq(this)})});var H=1;var cx=H,cy=(H<<=1),cz=(H<<=1),cA=(H"
+"<<=1),cB=(H<<=1),cC=(H<<=1),cD=(H<<=1),cE=(H<<=1),cF=(H<<=1),cG=(H<<=1),cH=(H<<=1);var CC={};(function(){function cI(c"
+"J,cK){for(var v in cK)CC[cK[v]]|=cJ}cI(cF,\"^$.*+?()[]{}|\");cI(cB|cD|cA,\"0123456789\");cI(cD|cC|cA,\"abcdefABCDEF\")"
+";cI(cC|cA,\"ghijklmnopqrstuvwxyzGHIJKLMNOPQRSTUVWXYZ\");cI(cy|cz,\"\\n\\r\\u2028\\u2029\");cI(cz,\" \\t\\v\\f\\xA0\");"
+"CC['_']|=cA;CC[\"undefined\"]|=cx;CC['']|=cx;cI(cE,\"fnrtv\");for(var v=32;v<=126;++v){var av=a.fromCharCode(v);if(av!"
+"=='\"'&&av!=='\\\\')CC[a.fromCharCode(v)]|=cG}var cL=[0,48,58,65,91,95,96,97,123,128];for(var v=cL.length-2;v>=0;v-=2)"
+"for(var b8=cL[v],cM=cL[v+1];b8<cM;++b8)CC[a.fromCharCode(b8)]|=cH})();function regExpCanonicalize(C){var I='',av,cc;if"
+"(!at)au();for(var v=0,az=C.length;v<az;++v)I+=((cc=at[av=C[v]])&&cc.length===1&&(av<'\\x80'||cc>='\\x80')?cc:av);retur"
+"n I}function cN(C,cO,cP){var Y=0,cQ='',cR=0,cS=0,cT='',cU=0;function cV(cW,cJ){return((CC[cW]&cJ)!==0)}function cX(C,c"
+"J){for(var v=C.length-1;v>=0;--v)if((CC[C[v]]&cJ)===0)return false;return true}var cY={'D':[cB,true],'d':[cB,false],'S"
+"':[cz,true],'s':[cz,false],'W':[cA,true],'w':[cA,false],'.':[cy,true]};function cZ(d0){var D=d0;if(cV(C[Y],cB)){D=0;do"
+"{D=D*10+(l(C,Y)-48);++Y}while(cV(C[Y],cB))}return D}function d1(){var d2=0,d3=i,d4=true;switch(C[Y]){case'*':++Y;break"
+";case'+':++Y;d2=1;break;case'?':++Y;d3=1;break;case'{':{var z=Y;++Y;if((d2=d3=cZ(-1))<0){Y=z;return null}if(C[Y]===','"
+"){++Y;d3=cZ(i)}if(C[Y]!=='}'){Y=z;return null}if(d2>d3){throw m(\"Min greater than max in regular expression quantifie"
+"r\")}++Y;break}default:return null}if(C[Y]==='?'){++Y;d4=false}return{d2:d2,d3:d3,d4:d4}}function d5(av){if(cV(av,cG))"
+"return av;return(av<='~'?\"\\\\x\":\"\\\\u\")+a2(ae(l(av,0),16),(av<='~'?2:4))}function d6(av){return d5(cO?regExpCano"
+"nicalize(av):av)}function d7(){var d8,d9,da;if((d8=C[Y])==='\\\\'){switch(d9=C[Y+1]){case'0':{if(!cV(C[Y+2],cB)){Y+=2;"
+"return'\\0'}break}case'c':{if(cV(C[Y+2],cC)){Y+=3;return a.fromCharCode(l(C,Y-1)&31)}break}case'x':case'u':{var D=(d9="
+"=='x'?2:4);if(cX(da=$sub(C,Y+2,Y+2+D),cD)){Y+=2+D;return a.fromCharCode(parseInt(da,16))}break}default:{if(cV(d9,cE)){"
+"Y+=2;return eval('\"\\\\'+d9+'\"')}else if(cV(d9,cH)){Y+=2;return d9}break}}}else if(d8){++Y;return d8}}function db(){"
+"var dc=[],H,D=0;while(!cV(C[Y],cF)&&(H=d7()))dc[D++]=d6(H);return(dc.length?dc:null)}function dd(){var H,de,av;if((av="
+"C[Y])!==']'&&(H=d7()))return H;if(av==='\\\\'){if((av=C[Y+1])==='b'){Y+=2;return'\\b'}if(de=cY[av]){Y+=2;return de}}}f"
+"unction df(bb){return(bb===0?'p':((bb<0?'p':'p+')+bb))}function dg(dc,bb){if(dc.length===0)return\"true\";else if(dc.l"
+"ength===1)return\"s[\"+df(bb)+']===\"'+dc[0]+'\"';else if(dc.length===2)return\"s[\"+df(bb)+']===\"'+dc[0]+'\" && s['+"
+"df(bb+1)+']===\"'+dc[1]+'\"';else{for(var v=0,C='',a3=dc.length;v<a3;++v)C+=dc[v];return\"$match(s,\"+df(bb)+',\"'+C+'"
+"\")'}}function dh(aN,z){switch(aN){case\"false\":return\"false\";case\"true\":return z;default:return(z===\"true\"?aN:"
+"aN+\" && \"+z)}}function di(aN,z){switch(aN){case\"false\":return z;case\"true\":return\"true\";default:return(z===\"f"
+"alse\"?aN:aN+\" || \"+z)}}function dj(name,dk){cQ+=\"\\tfunction \"+name+\"(p) { \"+dk+\" }\\n\"}function dl(dm,bb,dn,"
+"dp,dq,dr){var ds='q'+(++cR),dt=(dr?\"var h=\"+dr+\",\":\"var \")+(dq.d2?\"b=p+\"+dq.d2+(dr?\"*h\":\"\"):\"b=p\")+(dq.d"
+"3<i?\",e=p+\"+dq.d3+(dr?\"*h\":\"\"):\"\")+\"; \";if(dr)dt+=\"if (h<=0 || h!==h) return \"+dp+\"; \";if(dq.d4){dj(ds,d"
+"t+\"while (\"+dh((dq.d3<i?\"p<e\":\"true\"),dn)+\") \"+(dr?\"p+=h\":\"++p\")+\"; while (\"+dh(\"p>=b\",\"!(\"+dp+\")\""
+")+\") \"+(dr?\"p-=h\":\"--p\")+\"; return p>=b\")}else{dj(ds,dt+\"while (\"+di((dq.d2?\"p<b\":\"false\"),\"!(\"+dp+\")"
+"\")+\") { if (\"+di((dq.d3<i?\"p>=e\":\"false\"),\"!(\"+dn+\")\")+\") return false; \"+(dr?\"p+=h\":\"++p\")+\" }; ret"
+"urn true\")}return dh(dm,ds+\"(\"+df(bb)+\")\")}function du(dm,dv,dw,dx){if(dv===null&&dw===dx){return\"return \"+dm}e"
+"lse{var dy='',dz='',dA='';if(dv!==null){dy+='r'+dv+\"=c\"+dv;dz='c'+dv+\"=p\";dA='c'+dv+\"=r\"+dv}if(dx!==void 0){for("
+"var v=dw;v<dx;++v){var b8=v*2;if(dv!==null||v>dw){dy+=',';dA+=',';if(v===dw){dz+=','}}dy+='r'+b8+\"=c\"+b8;dz+='c'+b8+"
+"'=';dA+='c'+b8+\"=r\"+b8;if(v===dx-1){dz+=\"void 0\"}}}dm=dz+\", \"+di(dm,'('+dA+\",false)\");return\"var \"+dy+\"; re"
+"turn \"+dm}}function dB(aV,de){return(de[1]?'!':\"!!\")+\"(CC[\"+aV+\"]&\"+(de[0]|(de[1]?cx:0))+')'}function dC(bb,dD)"
+"{var dc,dq,dm=\"true\";dE:for(;;){if(dc=db()){if(dq=d1()){var dF=dc[dc.length-1];--dc.length;return dl(dh(dm,dg(dc,bb)"
+"),bb+dc.length,dg(dF,0),dC(0,dD),dq)}dm=dh(dm,dg(dc,bb));bb+=dc.length}else{var av,dG,dp,dH,dI;switch(av=C[Y]){case'^'"
+":{++Y;dG=df(bb)+\"===0\";if(cP)dG='('+di(dG,\"!!(CC[s[\"+df(bb-1)+\"]]&\"+cy+')')+')';dm=dh(dm,dG);break}case'$':{++Y;"
+"dG=df(bb)+\"===l\";if(cP)dG='('+di(dG,\"!!(CC[s[\"+df(bb)+\"]]&\"+cy+')')+')';dm=dh(dm,dG);break}case'[':{var dJ=false"
+",dK,dL,dM=\"false\";if(C[++Y]==='^'){dJ=true;++Y}while(dK=dd()){var z=Y;if(C[Y]==='-'&&(++Y,dL=dd())){if(typeof dK==="
+"\"string\"&&typeof dL===\"string\"&&dK<=dL){if(cO&&(dK>'~'||dL>'~'||(regExpCanonicalize(dK)!==dK)!==(regExpCanonicaliz"
+"e(dL)!==dL))){dK=d5(dK);dL=d5(dL);dM=di(dM,dh('upperToLower[c]>=\"'+dK+'\"','upperToLower[c]<=\"'+dL+'\"'))}else{dK=d6"
+"(dK);dL=d6(dL)}dM=di(dM,dh('c>=\"'+dK+'\"','c<=\"'+dL+'\"'))}else{throw m(\"Invalid character class syntax in regular "
+"expression\")}}else if(typeof dK===\"string\"){Y=z;dM=di(dM,'c===\"'+d6(dK)+'\"')}else{dM=di(dM,dB('c',dK))}}if(C[Y]!="
+"=']'){throw m(\"Invalid character class syntax in regular expression\")}++Y;var ds='k'+(++cR);dj(ds,\"var c=s[p]; retu"
+"rn \"+(dJ?\"p!==l && !(\"+dM+')':dM));if(dq=d1()){return dl(dm,bb,ds+'('+df(0)+')',dC(0,dD),dq)}dm=dh(dm,ds+'('+df(bb)"
+"+')');++bb;break}case'\\\\':{var D;++Y;if((D=cZ(-1))>=0){if(D>cU)cU=D;D=(D-1)*2;dq=d1();var dr='c'+(D+1)+\"-c\"+D,dN="
+"\"$match(s,\"+df(bb)+\",$sub(s, c\"+D+\",c\"+(D+1)+\"))\";dp=dC(0,dD);var dO='t'+(++cR);dj(dO,\"return \"+dp);return d"
+"q?dl(dm,bb,dN,dO+'('+df(0)+')',dq,dr):dh(dm,'(c'+D+\"<c\"+(D+1)+\" ? \"+dh(dN,dO+'('+df(bb)+'+'+dr+')')+\" : \"+dO+'('"
+"+df(bb)+\"))\")}else if((av=C[Y])==='b'||av==='B'){++Y;dm=dh(dm,(av==='b'?\"!!((CC[s[\":\"!((CC[s[\")+df(bb-1)+\"]]^CC"
+"[s[\"+df(bb)+\"]])&\"+cA+')');break}}case'.':{var de;if(!(de=cY[av]))throw m(\"Invalid escape in regular expression\")"
+";++Y;if(dq=d1()){return dl(dm,bb,dB(\"s[\"+df(0)+']',de),dC(0,dD),dq)}dm=dh(dm,dB(\"s[\"+df(bb)+']',de));++bb;break}ca"
+"se'(':{var dP=++cR,dQ='g'+dP,dR=dQ+'('+df(bb)+')',dS='j'+dP,dT=dS+'('+df(bb)+')',dU=true,dV=false,dW=false;++Y;if(C[Y]"
+"==='?'){switch(C[Y+1]){case'!':dW=true;case'=':dV=true;case':':dU=false;Y+=2}}var dX=null,dY=null;if(dU){(dY=(dX=(cS++"
+")*2)+1);cT+=\",c\"+dX+\",c\"+dY}var dZ=cS,e0=e1(0,(dV?void 0:dS)),e2=cS;if((av=C[Y])!==')'){throw m(av?\"Unterminated "
+"group in regular expression\":\"Invalid regular expression\")}++Y;dq=(dV?null:d1());dp=dC(0,dD);dI=e0;var e3='',e4=(dq"
+"&&dq.d3>1);if(e4&&(dq.d3<i||dq.d2>1)){cT+=\",n\"+dP+\"=0\";dI=((dq.d3<i)?dh(\"++n\"+dP+\"<=\"+dq.d3,dI):\"++n\"+dP+\","
+" \"+dI);if(dq.d2>1){dI=dh(dI,'n'+dP+\">=\"+dq.d2);e3='n'+dP+'<'+dq.d2}dI=di(dI,\"(--n\"+dP+\",false)\")}if(dV){dH=dS+'"
+"('+df(0)+')';if(dW){dI=\"!(\"+dI+')';if(dZ<e2){var e5='';for(var v=dZ;v<e2;++v)e5+='c'+v*2+'=';dH='('+e5+\"void 0, \"+"
+"dH+')'}}dI=dh(dI,dH)}if(e4){cT+=\",p\"+dP;var e6='p'+dP+\"!=p\";dI=dh(e3?'('+di(e6,e3)+')':e6,\"(p\"+dP+\"=p, \"+dI+')"
+"')}dj(dQ,du(dI,dX,dZ,e2));if(e4){var e7=dQ+'('+df(0)+')';dI=(dq.d4?di(e7,dp):di(dp,e7));dj(dS,du(dI,dY));dH=(dq.d2===0"
+"?dT:dR);dm=dh(dm,'(p'+dP+\"=void 0,\"+dH+')')}else{dj(dS,du(dp,dY));dm=((dq&&dq.d2===0)?dh(dm,(dq.d3===0?dT:'('+(dq.d4"
+"?di(dR,dT):di(dT,dR))+')')):dh(dm,dR))}return dm}default:break dE}}}switch(dD){case void 0:return dm;case'':return dh("
+"dm,\"(q=\"+df(bb)+\",true)\");default:return dh(dm,dD+'('+df(bb)+')')}}function e1(bb,dD){var dm=dC(bb,dD);if(C[Y]==='"
+"|'){do{++Y;dm=di(dm,dC(bb,dD))}while(C[Y]==='|');dm='('+dm+')'}return dm}var e0=e1(0,'');if(Y<C.length)throw m(\"Inval"
+"id regular expression\");if(cU>cS)throw m(\"Invalid back reference in regular expression\");var dm=\"(function(s, p) {"
+"\\n\";if(cO)dm+=\"\\ts=regExpCanonicalize(s)\\n\";dm+=\"\\tvar l=s.length,q\";dm+=cT+\";\\n\"+cQ+\"\\tif (\"+e0+\") re"
+"turn [p,q\";for(var v=0;v<cS*2;++v)dm+=\",c\"+v;dm+=\"];\\n})\";return dm}var e8={'g':\"global\",'i':\"ignoreCase\",'m"
+"':\"multiline\"},e9={},ea;function eb(b5,a8){a8=Q(a8);var v;if((v=(b5.global?N(b5.lastIndex):0))>=0){var aX=j(b5,\"val"
+"ue\"),az=a8.length,aU;for(;v<=az;++v)if(aU=aX(a8,v)){if(b5.global)b5.lastIndex=aU[1];return aU}}b5.lastIndex=0}functio"
+"n aM(b5,a8){var aU,aN=null;if(aU=eb(b5,a8)){(aN=[]).input=a8;aN.index=aU[0];for(var b8=0;b8<aU.length;b8+=2)aN[aN.leng"
+"th]=((aU[b8]===void 0)?void 0:$sub(a8,aU[b8],aU[b8+1]))}return aN}function ec(b5){return(b5.global?'g':'')+(b5.ignoreC"
+"ase?'i':'')+(b5.multiline?'m':'')}var RegExp=a.distinctConstructor(function RegExp(ed,ee){return(j(ed,\"class\")===\"R"
+"egExp\"&&ee===void 0?ed:new a.createRegExp(ed,ee))},a.createRegExp=function RegExp(ed,ee){if(j(ed,\"class\")===\"RegEx"
+"p\"){if(ee!==void 0)throw o(\"Cannot supply flags when constructing one RegExp from another\");ee=ec(ed);ed=ed.source}"
+"ed=(ed===void 0?'':Q(ed));ee=(ee===void 0?'':Q(ee));var ef={global:false,ignoreCase:false,multiline:false,source:ed};f"
+"or(var v=ee.length-1;v>=0;--v){var Y;if(!(Y=e8[ee[v]])||ef[Y])throw m(\"Invalid regular expression flags\");ef[Y]=true"
+"}var eg,eh;if(!(eh=e9[eg=ed+','+ef.ignoreCase+','+ef.multiline]))e9[eg]=eh=ai(cN(ed,ef.ignoreCase,ef.multiline));var b"
+"5=a.createWrapper(\"RegExp\",eh,ea);R(b5,{dontEnum:true,readOnly:true,dontDelete:true},ef);R(b5,{dontEnum:true,dontDel"
+"ete:true},{lastIndex:0});return b5});R(RegExp,{dontEnum:true,readOnly:true,dontDelete:true},{prototype:ea=RegExp.proto"
+"type});R(RegExp.prototype,{dontEnum:true},{exec:d(function exec(a8){Z(this,\"RegExp\",\"exec\");return aM(this,a8)}),t"
+"est:d(function test(a8){Z(this,\"RegExp\",\"test\");return eb(this,a8)!==void 0}),toString:d(function toString(){Z(thi"
+"s,\"RegExp\",\"toString\");return'/'+this.source+'/'+ec(this)})});R(c,{dontEnum:true},{Array:Array,Boolean:Boolean,Dat"
 "e:Date,Function:Function,Math:a.createWrapper(\"Math\",void 0),Number:Number,Object:Object,RegExp:RegExp,String:String"
-",isFinite:c(function isFinite(G){return e(+G)}),isNaN:c(function isNaN(G){return d(+G)}),JSON:a.createWrapper(\"JSON\""
-",void 0),eval:a.evalFunction=c(function eval(bP){return a.eval(bP)}),parseFloat:c(function parseFloat(a7){return a.par"
-"seFloat(P(a7))}),parseInt:c(function parseInt(a7,af){a7=P(a7);var s=r,u=-1,ag=1;while(s[a7[++u]]===null);switch(a7[u])"
-"{case'-':ag=-1;case'+':++u}if(((af=N(af))===0||af===16)&&(a7[u]==='0'&&a7[u+1]==='x')){u+=2;af=16}if(af===0)af=10;else"
-" if(af<2||af>36)return g;var G=0,y,aG=a7.length,C;for(y=u;u<aG&&(C=s[a7[u]])!=null&&C<af;++u)G=G*af+C;return(y===u?g:G"
-"*ag)})});Q(b,{dontEnum:true,dontDelete:true},{NaN:g,Infinity:h,undefined:a.undefined});Q(Math,{readOnly:true,dontEnum:"
+",isFinite:d(function isFinite(H){return f(+H)}),isNaN:d(function isNaN(H){return e(+H)}),JSON:a.createWrapper(\"JSON\""
+",void 0),eval:a.evalFunction=d(function eval(bQ){return a.eval(bQ)}),parseFloat:d(function parseFloat(a8){return a.par"
+"seFloat(Q(a8))}),parseInt:d(function parseInt(a8,ag){a8=Q(a8);var t=s,v=-1,ah=1;while(t[a8[++v]]===null);switch(a8[v])"
+"{case'-':ah=-1;case'+':++v}if(((ag=O(ag))===0||ag===16)&&(a8[v]==='0'&&a8[v+1]==='x')){v+=2;ag=16}if(ag===0)ag=10;else"
+" if(ag<2||ag>36)return h;var H=0,z,aH=a8.length,D;for(z=v;v<aH&&(D=t[a8[v]])!=null&&D<ag;++v)H=H*ag+D;return(z===v?h:H"
+"*ah)})});R(c,{dontEnum:true,dontDelete:true},{NaN:h,Infinity:i,undefined:a.undefined});R(Math,{readOnly:true,dontEnum:"
 "true,dontDelete:true},{E:2.718281828459045235360,LN10:2.302585092994045684018,LN2:0.6931471805599453094172,LOG10E:0.43"
 "429448190325182765113,LOG2E:1.442695040888963407360,PI:3.1415926535897932,SQRT1_2:0.7071067811865475244008,SQRT2:1.414"
-"213562373095048802});Q(Math,{dontEnum:true},{abs:c(abs=function abs(G){return((G=+G)<0?-G:G)}),acos:c(function acos(G)"
-"{return a.acos(+G)}),asin:c(function asin(G){return a.asin(+G)}),atan:c(function atan(G){return a.atan(+G)}),atan2:c(f"
-"unction atan2(c8,bP){return a.atan2(+c8,+bP)}),ceil:c(function ceil(G){return-f(-G)}),cos:c(function cos(G){return a.c"
-"os(+G)}),exp:c(function exp(G){return a.exp(+G)}),floor:c(function floor(G){return f(+G)}),log:c(function log(G){retur"
-"n a.log(+G)}),max:c(function max(bP,c8){var aT=-h,G,ak;for(var u=(ak=arguments).length-1;u>=0;--u)if((G=+ak[u])>aT||d("
-"G))aT=G;return aT}),min:c(function min(bP,c8){var aT=h,G,ak;for(var u=(ak=arguments).length-1;u>=0;--u)if((G=+ak[u])<a"
-"T||d(G))aT=G;return aT}),pow:c(function pow(bP,c8){return a.pow(+bP,+c8)}),random:c(function random(){return a.random("
-")}),round:c(function round(G){return(G===0.0?G:(G>=-0.5&&G<0.0?-0.0:f(G+0.5)))}),sin:c(function sin(G){return a.sin(+G"
-")}),sqrt:c(function sqrt(G){return a.sqrt(+G)}),tan:c(function tan(G){return a.tan(+G)})});function eh(name,prototype)"
-"{return function(message){var aG;a.defineProperty(aG=a.createWrapper(\"Error\",name,prototype),\"message\",(message!=="
-"void 0?P(message):''),false,true,false);return aG}};(function(){var ei=[\"Error\",\"EvalError\",\"RangeError\",\"Refer"
-"enceError\",\"SyntaxError\",\"TypeError\",\"URIError\"];for(var u=ei.length;--u>=0;){var C,au,X;a.defineProperty(b,C=e"
-"i[u],au=eh(C,X=a.prototypes[C]),false,true,false);au.name=C;Q(au,{dontEnum:true,readOnly:true,dontDelete:true},{protot"
-"ype:X});Q(X,{dontEnum:true},{constructor:au});X.name=C}Q(Error.prototype,{dontEnum:true},{message:'',toString:c(functi"
-"on toString(){return(this.name===void 0?\"Error\":this.name)+(this.message?(\": \"+this.message):'')})});l=SyntaxError"
-";m=RangeError;n=TypeError})();var ej={'\\\\':\"\\\\\\\\\",'\"':\"\\\\\\\"\",'\\b':\"\\\\b\",'\\f':\"\\\\f\",'\\n':\"\\"
-"\\n\",'\\r':\"\\\\r\",'\\t':\"\\\\t\"};var ek=61;Q(JSON,{dontEnum:true},{stringify:c(function stringify(ae,el,em){var "
-"en=[],eo=(typeof el===\"function\"?el:null),ep='',eq;if(i(el,\"class\")===\"Array\"){eq={};for(var u=el.length;--u>=0;"
-")eq[el[u]]=true}if(typeof em===\"number\"||(typeof em===\"object\"&&i(em,\"class\")===\"Number\")){em=+em;for(var u=(e"
-"m>10?10:em);--u>=0;)ep+=' '}else if(typeof em===\"string\"||(typeof em===\"object\"&&i(em,\"class\")===\"String\")){ep"
-"=$sub(P(em),0,10)}function er(B){var H='\"',ay=B.length;for(var u=0;u<ay;++u){var aU=B[u],es;H+=((es=ej[aU])?es:((aU>="
-"' '&&aU<='~')?aU:\"\\\\u\"+a1(ad(k(aU,0),16),4)))}return H+'\"'}function a7(ef,et,eu){var ae;if((ae=et[ef])&&typeof ae"
-"===\"object\"&&typeof ae.toJSON===\"function\")ae=ae.toJSON(ef);if(eo)ae=j(eo,et,[ef,ae]);var ev=(ep?'\\n'+eu:'');if(t"
-"ypeof ae===\"object\"){switch(i(ae,\"class\")){case\"Number\":ae=+ae;break;case\"String\":ae=P(ae);break;case\"Boolean"
-"\":ae=i(ae,\"value\");break}}switch(typeof ae){case\"object\":{if(!ae)return\"null\";var ay,B=new x,G;for(var u=(ay=en"
-".length);--u>=0;){if(en[u]===ae)throw n(\"Cannot convert circular structure to JSON\")}if(ay>ek)throw n(\"Structure to"
-"o deeply nested for JSON conversion\");en[ay]=ae;if(i(ae,\"class\")===\"Array\"){ay=ae.length;for(var u=0;u<ay;++u){B."
-"A((u==0?'[':',')+ev+ep+(a7(u,ae,eu+ep)||\"null\"))}B.A(ay==0?\"[]\":ev+']')}else{var ew=false;for(var cL in(eq?eq:ae))"
-"{if(a.hasOwnProperty(ae,cL)){if(G=a7(cL,ae,eu+ep)){B.A((ew?',':'{')+ev+ep+er(cL)+(ep?\": \":':')+G);ew=true}}}B.A(ew?e"
-"v+'}':\"{}\")}--en.length;return B.D()}case\"string\":return er(ae);case\"number\":return(e(ae)?P(ae):\"null\");case\""
-"boolean\":return P(ae)}}return a7('',{'':ae},'')}),parse:c(function parse(ex,ey){var ez=0;function em(H,X){var aU;whil"
-"e((aU=H[X])===' '||aU==='\\t'||aU==='\\r'||aU==='\\n')++X;return X}function eA(H,X){var aU;if(H[X]==='-')++X;if((aU=H["
-"X])==='0')aU=H[++X];else if(aU>='1'&&aU<='9')do{aU=H[++X]}while(aU>='0'&&aU<='9');else return;if(aU==='.'){if((aU=H[++"
-"X])<'0'||aU>'9')return;while((aU=H[++X])>='0'&&aU<='9')}if(aU==='e'||aU==='E'){if((aU=H[++X])==='-'||aU==='+')aU=H[++X"
-"];if(aU<'0'||aU>'9')return;while((aU=H[++X])>='0'&&aU<='9')}return X}function a7(H,X){var aU;if(H[X]!=='\"')return;++X"
-";while((aU=H[X])!=='\"'&&aU>=' '){if(aU==='\\\\'){switch(H[++X]){default:return;case'\"':case'/':case'\\\\':case'b':ca"
-"se'f':case'n':case'r':case't':break;case'u':for(var u=4;--u>=0;)if(!(((aU=H[++X])>='0'&&aU<='9')||(aU>='a'&&aU<='f')||"
-"(aU>='A'&&aU<='F')))return;break}}++X}if(aU==='\"')return++X}function eB(H,X){if($match(H,X,\"true\")||$match(H,X,\"nu"
-"ll\"))return X+4;else if($match(H,X,\"false\"))return X+5}function R(H,X){if(ez>ek)throw n(\"Structure too deeply nest"
-"ed for JSON conversion\");++ez;try{var aU,eC=false,eD=H[X],eE=(eD==='['?']':'}');X=em(H,++X);while((aU=H[X])!==eE&&aU)"
-"{if(eC){if(aU!==',')return;X=em(H,++X)}if(eD==='{'){if(!(X=a7(H,X))||H[X=em(H,X)]!==':')return;X=em(H,++X)}if(!(eF=eG["
-"H[X]])||!(X=eF(H,X)))return;X=em(H,X);eC=true}if(aU===eE)return++X}finally{--ez}}var eG={'{':R,'[':R,'\"':a7,'t':eB,'f"
-"':eB,'n':eB,'-':eA,'0':eA,'1':eA,'2':eA,'3':eA,'4':eA,'5':eA,'6':eA,'7':eA,'8':eA,'9':eA};ex=P(ex);var X,eF;if((eF=eG["
-"ex[X=em(ex,0)]])&&(X=eF(ex,X))&&em(ex,X)===ex.length){var ae=eval('('+ex+')');if(typeof ey===\"function\"){function eH"
-"(et,ef){var cL,G,J;if(typeof(J=et[ef])===\"object\"&&J){for(cL in J){if(a.hasOwnProperty(J,cL)){if((G=eH(J,cL))!==void"
-" 0)J[cL]=G;else delete J[cL]}}}return j(ey,et,[ef,J])}ae=eH({\"\":ae},\"\")}return ae}throw l(\"Error parsing JSON\")}"
-")});Q(Array,{dontEnum:true},{isArray:c(function isArray(J){return i(J,\"class\")===\"Array\"})});Q(Object,{dontEnum:tr"
-"ue},{defineProperty:c(function defineProperty(J,X,cb){a.defineProperty(J,P(X),cb.value,!cb.writable,!cb.enumerable,!cb"
-".configurable)}),getPrototypeOf:c(function getPrototypeOf(J){return i(J,\"prototype\")})});if(g.toString()!==\"NaN\")t"
-"hrow Error(\"Internal self test failed. Check C++ compiler options concerning IEEE 754 compliance.\")})"
+"213562373095048802});R(Math,{dontEnum:true},{abs:d(abs=function abs(H){return((H=+H)<0?-H:H)}),acos:d(function acos(H)"
+"{return a.acos(+H)}),asin:d(function asin(H){return a.asin(+H)}),atan:d(function atan(H){return a.atan(+H)}),atan2:d(f"
+"unction atan2(c9,bQ){return a.atan2(+c9,+bQ)}),ceil:d(function ceil(H){return-g(-H)}),cos:d(function cos(H){return a.c"
+"os(+H)}),exp:d(function exp(H){return a.exp(+H)}),floor:d(function floor(H){return g(+H)}),log:d(function log(H){retur"
+"n a.log(+H)}),max:d(function max(bQ,c9){var aU=-i,H,al;for(var v=(al=arguments).length-1;v>=0;--v)if((H=+al[v])>aU||e("
+"H))aU=H;return aU}),min:d(function min(bQ,c9){var aU=i,H,al;for(var v=(al=arguments).length-1;v>=0;--v)if((H=+al[v])<a"
+"U||e(H))aU=H;return aU}),pow:d(function pow(bQ,c9){return a.pow(+bQ,+c9)}),random:d(function random(){return a.random("
+")}),round:d(function round(H){return(H===0.0?H:(H>=-0.5&&H<0.0?-0.0:g(H+0.5)))}),sin:d(function sin(H){return a.sin(+H"
+")}),sqrt:d(function sqrt(H){return a.sqrt(+H)}),tan:d(function tan(H){return a.tan(+H)})});function ei(name,prototype)"
+"{return function(message){var aH;a.defineProperty(aH=a.createWrapper(\"Error\",name,prototype),\"message\",(message!=="
+"void 0?Q(message):''),false,true,false);return aH}};(function(){var ej=[\"Error\",\"EvalError\",\"RangeError\",\"Refer"
+"enceError\",\"SyntaxError\",\"TypeError\",\"URIError\"];for(var v=ej.length;--v>=0;){var D,av,Y;a.defineProperty(c,D=e"
+"j[v],av=ei(D,Y=a.prototypes[D]),false,true,false);av.name=D;R(av,{dontEnum:true,readOnly:true,dontDelete:true},{protot"
+"ype:Y});R(Y,{dontEnum:true},{constructor:av});Y.name=D}R(Error.prototype,{dontEnum:true},{message:'',toString:d(functi"
+"on toString(){return(this.name===void 0?\"Error\":this.name)+(this.message?(\": \"+this.message):'')})});m=SyntaxError"
+";n=RangeError;o=TypeError})();var ek={'\\\\':\"\\\\\\\\\",'\"':\"\\\\\\\"\",'\\b':\"\\\\b\",'\\f':\"\\\\f\",'\\n':\"\\"
+"\\n\",'\\r':\"\\\\r\",'\\t':\"\\\\t\"};var el=61;R(JSON,{dontEnum:true},{stringify:d(function stringify(af,em,en){var "
+"eo=[],ep=(typeof em===\"function\"?em:null),eq='',er;if(j(em,\"class\")===\"Array\"){er={};for(var v=em.length;--v>=0;"
+")er[em[v]]=true}if(typeof en===\"number\"||(typeof en===\"object\"&&j(en,\"class\")===\"Number\")){en=+en;for(var v=(e"
+"n>10?10:en);--v>=0;)eq+=' '}else if(typeof en===\"string\"||(typeof en===\"object\"&&j(en,\"class\")===\"String\")){eq"
+"=$sub(Q(en),0,10)}function es(C){var I='\"',az=C.length;for(var v=0;v<az;++v){var aV=C[v],et;I+=((et=ek[aV])?et:((aV>="
+"' '&&aV<='~')?aV:\"\\\\u\"+a2(ae(l(aV,0),16),4)))}return I+'\"'}function a8(eg,eu,ev){var af;if((af=eu[eg])&&typeof af"
+"===\"object\"&&typeof af.toJSON===\"function\")af=af.toJSON(eg);if(ep)af=k(ep,eu,[eg,af]);var ew=(eq?'\\n'+ev:'');if(t"
+"ypeof af===\"object\"){switch(j(af,\"class\")){case\"Number\":af=+af;break;case\"String\":af=Q(af);break;case\"Boolean"
+"\":af=j(af,\"value\");break}}switch(typeof af){case\"object\":{if(!af)return\"null\";var az,C=new y,H;for(var v=(az=eo"
+".length);--v>=0;){if(eo[v]===af)throw o(\"Cannot convert circular structure to JSON\")}if(az>el)throw o(\"Structure to"
+"o deeply nested for JSON conversion\");eo[az]=af;if(j(af,\"class\")===\"Array\"){az=af.length;for(var v=0;v<az;++v){C."
+"B((v==0?'[':',')+ew+eq+(a8(v,af,ev+eq)||\"null\"))}C.B(az==0?\"[]\":ew+']')}else{var ex=false;for(var cM in(er?er:af))"
+"{if(a.hasOwnProperty(af,cM)){if(H=a8(cM,af,ev+eq)){C.B((ex?',':'{')+ew+eq+es(cM)+(eq?\": \":':')+H);ex=true}}}C.B(ex?e"
+"w+'}':\"{}\")}--eo.length;return C.F()}case\"string\":return es(af);case\"number\":return(f(af)?Q(af):\"null\");case\""
+"boolean\":return Q(af)}}return a8('',{'':af},'')}),parse:d(function parse(ey,ez){var eA=0;function en(I,Y){var aV;whil"
+"e((aV=I[Y])===' '||aV==='\\t'||aV==='\\r'||aV==='\\n')++Y;return Y}function eB(I,Y){var aV;if(I[Y]==='-')++Y;if((aV=I["
+"Y])==='0')aV=I[++Y];else if(aV>='1'&&aV<='9')do{aV=I[++Y]}while(aV>='0'&&aV<='9');else return;if(aV==='.'){if((aV=I[++"
+"Y])<'0'||aV>'9')return;while((aV=I[++Y])>='0'&&aV<='9')}if(aV==='e'||aV==='E'){if((aV=I[++Y])==='-'||aV==='+')aV=I[++Y"
+"];if(aV<'0'||aV>'9')return;while((aV=I[++Y])>='0'&&aV<='9')}return Y}function a8(I,Y){var aV;if(I[Y]!=='\"')return;++Y"
+";while((aV=I[Y])!=='\"'&&aV>=' '){if(aV==='\\\\'){switch(I[++Y]){default:return;case'\"':case'/':case'\\\\':case'b':ca"
+"se'f':case'n':case'r':case't':break;case'u':for(var v=4;--v>=0;)if(!(((aV=I[++Y])>='0'&&aV<='9')||(aV>='a'&&aV<='f')||"
+"(aV>='A'&&aV<='F')))return;break}}++Y}if(aV==='\"')return++Y}function eC(I,Y){if($match(I,Y,\"true\")||$match(I,Y,\"nu"
+"ll\"))return Y+4;else if($match(I,Y,\"false\"))return Y+5}function S(I,Y){if(eA>el)throw o(\"Structure too deeply nest"
+"ed for JSON conversion\");++eA;try{var aV,eD=false,eE=I[Y],eF=(eE==='['?']':'}');Y=en(I,++Y);while((aV=I[Y])!==eF&&aV)"
+"{if(eD){if(aV!==',')return;Y=en(I,++Y)}if(eE==='{'){if(!(Y=a8(I,Y))||I[Y=en(I,Y)]!==':')return;Y=en(I,++Y)}if(!(eG=eH["
+"I[Y]])||!(Y=eG(I,Y)))return;Y=en(I,Y);eD=true}if(aV===eF)return++Y}finally{--eA}}var eH={'{':S,'[':S,'\"':a8,'t':eC,'f"
+"':eC,'n':eC,'-':eB,'0':eB,'1':eB,'2':eB,'3':eB,'4':eB,'5':eB,'6':eB,'7':eB,'8':eB,'9':eB};ey=Q(ey);var Y,eG;if((eG=eH["
+"ey[Y=en(ey,0)]])&&(Y=eG(ey,Y))&&en(ey,Y)===ey.length){var af=eval('('+ey+')');if(typeof ez===\"function\"){function eI"
+"(eu,eg){var cM,H,K;if(typeof(K=eu[eg])===\"object\"&&K){for(cM in K){if(a.hasOwnProperty(K,cM)){if((H=eI(K,cM))!==void"
+" 0)K[cM]=H;else delete K[cM]}}}return k(ez,eu,[eg,K])}af=eI({\"\":af},\"\")}return af}throw m(\"Error parsing JSON\")}"
+")});R(Array,{dontEnum:true},{isArray:d(function isArray(K){return j(K,\"class\")===\"Array\"})});R(Object,{dontEnum:tr"
+"ue},{defineProperty:d(function defineProperty(K,Y,cc){a.defineProperty(K,Q(Y),cc.value,!cc.writable,!cc.enumerable,!cc"
+".configurable)}),getPrototypeOf:d(function getPrototypeOf(K){return j(K,\"prototype\")})});if(b){eval=a.eval;eval(b);e"
+"val=a.evalFunction}if(h.toString()!==\"NaN\")throw Error(\"Internal self test failed. Check C++ compiler options conce"
+"rning IEEE 754 compliance.\")})"
 ;
+#if (!defined(NUXJS_ES5) || NUXJS_ES5)
+const char* STDLIB_ES5_JS =
+"R(String.prototype,{dontEnum:true},{trimLeft:function trimLeft(){var C=Q(this),v=0,b8=C.length,av;for(;v<b8;++v){av=C."
+"charCodeAt(v);if(av!==0x20&&(av<0x09||av>0x0D)&&av!==0xA0&&av!==0x2028&&av!==0x2029&&av!==0xFEFF)break}return C.substr"
+"ing(v,b8)},trimRight:function trimRight(){var C=Q(this),b8=C.length,av;for(;b8>0;--b8){av=C.charCodeAt(b8-1);if(av!==0"
+"x20&&(av<0x09||av>0x0D)&&av!==0xA0&&av!==0x2028&&av!==0x2029&&av!==0xFEFF)break}return C.substring(0,b8)},trim:functio"
+"n trim(){var C=Q(this),v=0,b8=C.length,av;for(;v<b8;++v){av=C.charCodeAt(v);if(av!==0x20&&(av<0x09||av>0x0D)&&av!==0xA"
+"0&&av!==0x2028&&av!==0x2029&&av!==0xFEFF)break}for(;b8>v;--b8){av=C.charCodeAt(b8-1);if(av!==0x20&&(av<0x09||av>0x0D)&"
+"&av!==0xA0&&av!==0x2028&&av!==0x2029&&av!==0xFEFF)break}return C.substring(v,b8)}});R(Array.prototype,{dontEnum:true},"
+"{forEach:function forEach(eJ){var K=Object(this),az=P(K.length),I=arguments[1];if(typeof eJ!==\"function\")throw TypeE"
+"rror();for(var cM=0;cM<az;++cM)if(cM in K)eJ.call(I,K[cM],cM,K)},map:function map(eJ){var K=Object(this),az=P(K.length"
+"),I=arguments[1],aN=new Array(az);if(typeof eJ!==\"function\")throw TypeError();for(var cM=0;cM<az;++cM)if(cM in K)aN["
+"cM]=eJ.call(I,K[cM],cM,K);return aN},filter:function filter(eJ){var K=Object(this),az=P(K.length),I=arguments[1],aN=[]"
+",bs=0;if(typeof eJ!==\"function\")throw TypeError();for(var cM=0;cM<az;++cM)if(cM in K){var H=K[cM];if(eJ.call(I,H,cM,"
+"K))aN[bs++]=H}aN.length=bs;return aN},indexOf:function indexOf(eK){var az=P(this.length),v=arguments[1];if(az===0)retu"
+"rn-1;v=N(v);if(v<0){v+=az;if(v<0)v=0}for(;v<az;++v)if(v in this&&this[v]===eK)return v;return-1},lastIndexOf:function "
+"lastIndexOf(eK){var az=P(this.length),v=arguments[1];if(az===0)return-1;if(v===void 0)v=az-1;else{v=N(v);if(v<0)v+=az;"
+"if(v>=az)v=az-1}for(;v>=0;--v)if(v in this&&this[v]===eK)return v;return-1},reduce:function reduce(eJ){var K=Object(th"
+"is),az=P(K.length),cM=0,eL;if(typeof eJ!==\"function\")throw TypeError();if(arguments.length>1)eL=arguments[1];else{wh"
+"ile(cM<az&&!(cM in K))++cM;if(cM>=az)throw TypeError();eL=K[cM++]}for(;cM<az;++cM)if(cM in K)eL=eJ.call(void 0,eL,K[cM"
+"],cM,K);return eL},reduceRight:function reduceRight(eJ){var K=Object(this),az=P(K.length),cM=az-1,eL;if(typeof eJ!==\""
+"function\")throw TypeError();if(arguments.length>1)eL=arguments[1];else{while(cM>=0&&!(cM in K))--cM;if(cM<0)throw Typ"
+"eError();eL=K[cM--]}for(;cM>=0;--cM)if(cM in K)eL=eJ.call(void 0,eL,K[cM],cM,K);return eL},every:function every(eJ){va"
+"r K=Object(this),az=P(K.length),I=arguments[1];if(typeof eJ!==\"function\")throw TypeError();for(var cM=0;cM<az;++cM)i"
+"f(cM in K&&!eJ.call(I,K[cM],cM,K))return false;return true},some:function some(eJ){var K=Object(this),az=P(K.length),I"
+"=arguments[1];if(typeof eJ!==\"function\")throw TypeError();for(var cM=0;cM<az;++cM)if(cM in K&&eJ.call(I,K[cM],cM,K))"
+"return true;return false}});R(Date,{dontEnum:true},{now:function now(){return new Date().getTime()}});R(Object,{dontEn"
+"um:true},{defineProperty:function defineProperty(K,Y,cc){var cM=Q(Y);var V=!cc.writable,W=!cc.enumerable,X=!cc.configu"
+"rable;if(\"get\"in cc||\"set\"in cc){if(\"value\"in cc||\"writable\"in cc)throw TypeError();var eM=cc[\"get\"];var C=c"
+"c[\"set\"];if(eM!==undefined&&typeof eM!==\"function\")throw TypeError();if(C!==undefined&&typeof C!==\"function\")thr"
+"ow TypeError();a.defineProperty(K,cM,undefined,V,W,X,eM,C)}else{a.defineProperty(K,cM,cc.value,V,W,X)}},defineProperti"
+"es:function defineProperties(K,U){if(K===undefined||K===null)throw TypeError();var eN=Object(K);for(var cM in U)if(Obj"
+"ect.prototype.hasOwnProperty.call(U,cM))Object.defineProperty(eN,cM,U[cM]);return eN},create:function create(eO,eP){if"
+"(eO===null)throw TypeError();var I=typeof eO;if(I!==\"object\"&&I!==\"function\")throw TypeError();function eQ(){}eQ.p"
+"rototype=eO;var K=new eQ();if(eP!==void 0)Object.defineProperties(K,Object(eP));return K},keys:function keys(K){if(K=="
+"=undefined||K===null)throw TypeError();var eN=Object(K),eR=[],cM;for(cM in eN)if(Object.prototype.hasOwnProperty.call("
+"eN,cM))eR[eR.length]=cM;return eR}});R(Function.prototype,{dontEnum:true},{bind:function bind(an){var eS=this;if(typeo"
+"f eS!=='function')throw TypeError();var eT=Array.prototype.slice.call(arguments,1);function eU(aN){var eV=eT.concat(Ar"
+"ray.prototype.slice.call(arguments));if(this instanceof eU){if(!eS||!eS.prototype)throw TypeError();function eW(){}eW."
+"prototype=eS.prototype;var bj=new eW();var eX=eS.apply(bj,eV);return(eX&&(typeof eX==='object'||typeof eX==='function'"
+"))?eX:bj}return eS.apply(an,eV)}return eU}});"
+;
+#endif
 }
diff --git a/tests/es5/arrayForEach.io b/tests/es5/arrayForEach.io
new file mode 100644
index 0000000..194d307
--- /dev/null
+++ b/tests/es5/arrayForEach.io
@@ -0,0 +1,19 @@
+> total = 0;
+> [1, 2, 3].forEach(function(v){ total += v; });
+> print(total);
+< 6
+-
+> seen = [];
+> arr = [ , 5 ];
+> arr.forEach(function(v,i){ seen.push(i); });
+> print(seen.length);
+< 1
+-
+> print(seen[0]);
+< 1
+-
+> ctx = { sum: 0 };
+> [1,2].forEach(function(v){ this.sum += v; }, ctx);
+> print(ctx.sum);
+< 3
+-
diff --git a/tests/es5/arrayIndexOf.io b/tests/es5/arrayIndexOf.io
new file mode 100644
index 0000000..261fda9
--- /dev/null
+++ b/tests/es5/arrayIndexOf.io
@@ -0,0 +1,23 @@
+> var a = [1, 2, 3, 2];
+-
+> print(a.indexOf(2));
+< 1
+-
+> print(a.indexOf(2, 2));
+< 3
+-
+> print(a.indexOf(4));
+< -1
+-
+> print(a.lastIndexOf(2));
+< 3
+-
+> print(a.lastIndexOf(2, 2));
+< 1
+-
+> print(a.lastIndexOf(2, -3));
+< 1
+-
+> print(a.lastIndexOf(2, -5));
+< -1
+-
diff --git a/tests/es5/arrayMapFilter.io b/tests/es5/arrayMapFilter.io
new file mode 100644
index 0000000..47f3143
--- /dev/null
+++ b/tests/es5/arrayMapFilter.io
@@ -0,0 +1,28 @@
+> res = [1,2,3].map(function(v){ return v*2; });
+> print(res.join(','));
+< 2,4,6
+-
+> ctx = { add: 1 };
+> res = [1,2].map(function(v){ return v + this.add; }, ctx);
+> print(res[1]);
+< 3
+-
+> src = [ , 5 ];
+> res = src.map(function(v){ return v; });
+> print(0 in res);
+< false
+-
+> filtered = [1,2,3,4].filter(function(v){ return v % 2 === 0; });
+> print(filtered.join(','));
+< 2,4
+-
+> ctx = { max:2 };
+> filtered = [1,2,3].filter(function(v){ return v > this.max; }, ctx);
+> print(filtered[0]);
+< 3
+-
+> src = [ ,1,2 ];
+> filtered = src.filter(function(v){ return true; });
+> print(filtered.length);
+< 2
+-
diff --git a/tests/es5/arrayReduce.io b/tests/es5/arrayReduce.io
new file mode 100644
index 0000000..8af505d
--- /dev/null
+++ b/tests/es5/arrayReduce.io
@@ -0,0 +1,23 @@
+> print([1,2,3].reduce(function(a,b){ return a + b; }));
+< 6
+-
+> print([1,2,3].reduce(function(a,b){ return a + b; }, 1));
+< 7
+-
+> print([1,2,3].reduceRight(function(a,b){ return a - b; }));
+< 0
+-
+> print([1,2,3].reduceRight(function(a,b){ return a - b; }, 10));
+< 4
+-
+> calls = 0; arr = [ , 1 ];
+> arr.reduce(function(acc, v){ calls++; return acc; }, 0);
+> print(calls);
+< 1
+-
+> try { [].reduce(function(){}); } catch(e){ print(e instanceof TypeError); }
+< true
+-
+> try { [].reduceRight(function(){}); } catch(e){ print(e instanceof TypeError); }
+< true
+-
diff --git a/tests/es5/arraySomeEvery.io b/tests/es5/arraySomeEvery.io
new file mode 100644
index 0000000..17f58c1
--- /dev/null
+++ b/tests/es5/arraySomeEvery.io
@@ -0,0 +1,21 @@
+> print([1,2,3].some(function(v){ return v > 2; }));
+< true
+-
+> print([1,2,3].some(function(v){ return v > 5; }));
+< false
+-
+> print([1,2,3].every(function(v){ return v < 4; }));
+< true
+-
+> print([1,2,3].every(function(v){ return v < 3; }));
+< false
+-
+> ctx = { t:2 };
+> print([1,2,3].some(function(v){ return v > this.t; }, ctx));
+< true
+-
+> calls = 0; arr = [ , 1 ];
+> arr.every(function(v,i){ calls++; return true; });
+> print(calls);
+< 1
+-
diff --git a/tests/stdlib/checkAllPrototypes.io b/tests/es5/checkAllPrototypes.io
similarity index 99%
rename from tests/stdlib/checkAllPrototypes.io
rename to tests/es5/checkAllPrototypes.io
index 40a6942..dc23c26 100644
--- a/tests/stdlib/checkAllPrototypes.io
+++ b/tests/es5/checkAllPrototypes.io
@@ -944,7 +944,7 @@
 < defineProperty : dontEnum, (deleted:true)
 < name : dontEnum, (deleted:true)
 < length : dontEnum,readOnly,dontDelete, (deleted:false)
-< unconstructable: TypeError: defineProperty is not a constructor
+< unconstructable: TypeError: Cannot convert undefined or null to object
 < OK: true
 < --------
 -
diff --git a/tests/es5/dateNow.io b/tests/es5/dateNow.io
new file mode 100644
index 0000000..9251ce1
--- /dev/null
+++ b/tests/es5/dateNow.io
@@ -0,0 +1,8 @@
+> print(typeof Date.now);
+< function
+-
+> delta = Math.abs(Date.now() - new Date().getTime());
+-
+> print(delta < 10);
+< true
+-
diff --git a/tests/es5/functionBind.io b/tests/es5/functionBind.io
new file mode 100644
index 0000000..8d608a2
--- /dev/null
+++ b/tests/es5/functionBind.io
@@ -0,0 +1,27 @@
+> ctx = { x: 2 };
+> function f(a,b){ return this.x + a + b; }
+> g = f.bind(ctx, 1);
+> print(g(2));
+< 5
+-
+> function h(a,b,c){}
+> hb = h.bind(null, 1, 2);
+> print(hb.length);
+< 1
+-
+> function C(a){ this.y = a; }
+> C.prototype.m = function(){ return this.y * 2; };
+> B = C.bind(null, 10);
+> o = new B();
+> print(o.y);
+< 10
+>
+> print(typeof o.m === 'function');
+< true
+> print(o instanceof C);
+< true
+-
+> nb = Math.max.bind(null, 1);
+> try { new nb(); } catch(e){ print(e instanceof TypeError); }
+< true
+-
diff --git a/tests/es5/getterSetterProperties.io b/tests/es5/getterSetterProperties.io
new file mode 100644
index 0000000..2aed455
--- /dev/null
+++ b/tests/es5/getterSetterProperties.io
@@ -0,0 +1,26 @@
+> obj = { _v: 1, get value() { return this._v; }, set value(v) { this._v = v; }, get double() { return this._v * 2; }, set double(v) { this._v = v / 2; } };
+-
+> print(obj.value);
+< 1
+-
+> print(obj.double);
+< 2
+-
+> obj.double = 50;
+-
+> print(obj.value);
+< 25
+-
+> obj.value = 15;
+-
+> print(obj.double);
+< 30
+-
+> print(obj._v);
+< 15
+-
+> only = { _v: 0, get value() { return this._v; } };
+> only.value = 5;
+> print(only.value);
+< 0
+-
diff --git a/tests/es5/objectCreateDefineProperties.io b/tests/es5/objectCreateDefineProperties.io
new file mode 100644
index 0000000..573242b
--- /dev/null
+++ b/tests/es5/objectCreateDefineProperties.io
@@ -0,0 +1,17 @@
+> p = { t: 3 };
+> o = Object.create(p, { x: { value: 1, enumerable: true }, y: { get: function(){ return this.x + this.t; }, enumerable: true } });
+> print(o.x);
+< 1
+> print(o.y);
+< 4
+> print(Object.getPrototypeOf(o) === p);
+< true
+-
+> o2 = {};
+> Object.defineProperties(o2, { a: { value: 1, enumerable: true }, b: { value: 2 } });
+> print(Object.keys(o2).join(','));
+< a
+> o2.a = 7;
+> print(o2.a);
+< 1
+-
diff --git a/tests/es5/objectKeys.io b/tests/es5/objectKeys.io
new file mode 100644
index 0000000..bdc0a7f
--- /dev/null
+++ b/tests/es5/objectKeys.io
@@ -0,0 +1,22 @@
+> print(Object.keys({a:1,b:2}).sort().join(','));
+< a,b
+-
+> function F(){}
+> F.prototype.a = 1;
+> var o = new F();
+> o.b = 2;
+> print(Object.keys(o).join(','));
+< b
+-
+> var obj = {};
+> Object.defineProperty(obj, 'x', { value:1, enumerable:false });
+> obj.y = 2;
+> print(Object.keys(obj).join(','));
+< y
+-
+> print(Object.keys('hi').length);
+< 2
+-
+> try { Object.keys(null); } catch(e){ print(e instanceof TypeError); }
+< true
+-
diff --git a/tests/es5/strictArgumentsObject.io b/tests/es5/strictArgumentsObject.io
new file mode 100644
index 0000000..da3fb35
--- /dev/null
+++ b/tests/es5/strictArgumentsObject.io
@@ -0,0 +1,8 @@
+> function f(a){ "use strict"; arguments[0] = 2; return a === 1 && arguments[0] === 2; }
+> print(f(1))
+< true
+-
+> function g(a){ "use strict"; a = 3; return arguments[0] === 1; }
+> print(g(1))
+< true
+-
diff --git a/tests/es5/strictDeleteIdentifier.io b/tests/es5/strictDeleteIdentifier.io
new file mode 100644
index 0000000..8d859e9
--- /dev/null
+++ b/tests/es5/strictDeleteIdentifier.io
@@ -0,0 +1,7 @@
+> eval("\"use strict\"; var x = 1; delete x;")
+! !!!! SyntaxError: Deleting identifier in strict code
+-
+> function f(){ "use strict"; var y; delete y; }
+! !!!! Line: 1
+! !!!! SyntaxError: Deleting identifier in strict code
+-
diff --git a/tests/es5/strictDuplicateParam.io b/tests/es5/strictDuplicateParam.io
new file mode 100644
index 0000000..60ae825
--- /dev/null
+++ b/tests/es5/strictDuplicateParam.io
@@ -0,0 +1,11 @@
+> function f(a, a){ "use strict"; }
+! !!!! Line: 1
+! !!!! SyntaxError: Duplicate parameter name not allowed in strict code
+-
+> function g(a, a){ return a; }
+> print(g(1))
+< undefined
+-
+> eval("\"use strict\"; function h(a, a){ return a; }")
+! !!!! SyntaxError: Duplicate parameter name not allowed in strict code
+-
diff --git a/tests/es5/strictEvalArgsBinding.io b/tests/es5/strictEvalArgsBinding.io
new file mode 100644
index 0000000..72f7597
--- /dev/null
+++ b/tests/es5/strictEvalArgsBinding.io
@@ -0,0 +1,6 @@
+> eval("\"use strict\"; var eval = 0;")
+! !!!! SyntaxError: Illegal use of eval or arguments in strict code
+-
+> eval("\"use strict\"; function arguments(){}");
+! !!!! SyntaxError: Illegal use of eval or arguments in strict code
+-
diff --git a/tests/es5/strictEvalScope.io b/tests/es5/strictEvalScope.io
new file mode 100644
index 0000000..71ea5d5
--- /dev/null
+++ b/tests/es5/strictEvalScope.io
@@ -0,0 +1,4 @@
+> function f(){ "use strict"; eval("1"); }
+! !!!! Line: 1
+! !!!! SyntaxError: Illegal use of eval or arguments in strict code
+-
diff --git a/tests/es5/strictImplicitGlobal.io b/tests/es5/strictImplicitGlobal.io
new file mode 100644
index 0000000..3961474
--- /dev/null
+++ b/tests/es5/strictImplicitGlobal.io
@@ -0,0 +1,7 @@
+> eval("\"use strict\"; implicit = 1;")
+! !!!! ReferenceError: implicit is not defined
+-
+> f=function(){ "use strict"; implicit2 = 1; }
+> f()
+! !!!! ReferenceError: implicit2 is not defined
+-
diff --git a/tests/es5/strictThisBinding.io b/tests/es5/strictThisBinding.io
new file mode 100644
index 0000000..1171128
--- /dev/null
+++ b/tests/es5/strictThisBinding.io
@@ -0,0 +1,8 @@
+> f=function(){ "use strict"; return this===undefined; }
+> print(f())
+< true
+-
+> g=function(){ return this===undefined; }
+> print(g())
+< false
+-
diff --git a/tests/es5/strictWithStatement.io b/tests/es5/strictWithStatement.io
new file mode 100644
index 0000000..362f7bc
--- /dev/null
+++ b/tests/es5/strictWithStatement.io
@@ -0,0 +1,7 @@
+> eval("\"use strict\"; with({}){}")
+! !!!! SyntaxError: "with" is not allowed in strict code
+-
+> function f(){ "use strict"; with({}){} }
+! !!!! Line: 1
+! !!!! SyntaxError: "with" is not allowed in strict code
+-
diff --git a/tests/es5/stringTrim.io b/tests/es5/stringTrim.io
new file mode 100644
index 0000000..9ea2d97
--- /dev/null
+++ b/tests/es5/stringTrim.io
@@ -0,0 +1,6 @@
+> print(" \tfoo \n".trim())
+< foo
+-
+> print("\u00A0bar\u00A0".trim())
+< bar
+-
diff --git a/tests/es5/stringTrimLeftRight.io b/tests/es5/stringTrimLeftRight.io
new file mode 100644
index 0000000..16d13ba
--- /dev/null
+++ b/tests/es5/stringTrimLeftRight.io
@@ -0,0 +1,14 @@
+> var s = " \tfoo \n";
+-
+> print(s.trimLeft().charCodeAt(0));
+< 102
+-
+> print(s.trimLeft().charCodeAt(s.trimLeft().length - 1));
+< 10
+-
+> print(s.trimRight().charCodeAt(0));
+< 32
+-
+> print(s.trimRight().charCodeAt(s.trimRight().length - 1));
+< 111
+-
diff --git a/tools/NuXJSTest.cpp b/tools/NuXJSTest.cpp
index 13936d0..d1430ee 100644
--- a/tools/NuXJSTest.cpp
+++ b/tools/NuXJSTest.cpp
@@ -708,6 +708,7 @@ static void testStandardLibrary() {
 	EXPECT_EQUAL(upper.to<std::wstring>(), L"ABC");
 }
 
+	#if (NUXJS_ES5)
 static void testJSON() {
 	std::cout << std::endl << "***** JSON *****" << std::endl << std::endl;
 	std::cout << "  - stringify objects" << std::endl;
@@ -726,6 +727,7 @@ static void testJSON() {
 	EXPECT_EQUAL(parsed["bar"][1], 2);
         EXPECT_EQUAL(parsed["baz"].to<std::wstring>(), L"hi");
 }
+	#endif
 
 static void testCompilation() {
 	std::cout << std::endl << "***** Compilation *****" << std::endl << std::endl;
@@ -1793,7 +1795,9 @@ int main(int argc, const char* argv[]) {
 		testTables();
 		testVars();
 		testArrayVars();
+	#if (NUXJS_ES5)
 		testJSON();
+	#endif
 		testCompilation();
 		testLimits();
 		testHighLevelAPI();
diff --git a/tools/buildAndTest.cmd b/tools/buildAndTest.cmd
index 8865056..66eb334 100644
--- a/tools/buildAndTest.cmd
+++ b/tools/buildAndTest.cmd
@@ -7,19 +7,62 @@ SET target=%~1
 SET model=%~2
 IF "%target%"=="" SET target=debug
 IF "%model%"=="" SET model=x64
-SET CPP_OPTIONS=/FS
+IF "%CPP_OPTIONS%"=="" SET CPP_OPTIONS=/FS
 
-CD ..\externals\PikaCmd
+REM Build PikaCmd and update stdlibJS.cpp
+PUSHD ..\externals\PikaCmd
 CALL .\BuildPikaCmd.cmd || GOTO error
-CD ..\..\tools
+POPD
 ..\externals\PikaCmd\PikaCmd.exe .\stdlibToCpp.pika ..\src\stdlib.js ..\src\stdlibJS.cpp || GOTO error
-IF "%target%"=="release" SET CPP_OPTIONS=/GR- %CPP_OPTIONS%
+
+REM Optional dual-variant test mode (ES3 and ES5) — default OFF if not set
+IF "%NUXJS_TEST_ES5_VARIANTS%"=="" SET NUXJS_TEST_ES5_VARIANTS=0
+IF "%NUXJS_TEST_ES5_VARIANTS%"=="1" (
+	IF /I "%target%"=="release" IF "%NUXJS_SKIP_RELEASE%"=="1" (
+		ECHO Skipping release per NUXJS_SKIP_RELEASE=1
+		POPD
+		EXIT /b 0
+	)
+
+	SET CPP_OPTIONS_BASE=%CPP_OPTIONS%
+	MKDIR ..\output >NUL 2>&1
+	FOR %%E IN (0 1) DO (
+		ECHO Building and testing with NUXJS_ES5=%%E (%target% %model%)
+		SET CPP_OPTIONS=%CPP_OPTIONS_BASE% /DNUXJS_ES5=%%E
+		IF /I "%target%"=="release" SET CPP_OPTIONS=/GR- %CPP_OPTIONS%
+		CALL .\BuildCpp.cmd %target% %model% ..\output\NuXJSTest_%target%_%model%.exe .\NuXJSTest.cpp ..\src\NuXJS.cpp ..\src\stdlibJS.cpp || GOTO error
+		..\output\NuXJSTest_%target%_%model% -s >NUL 2>&1 || GOTO error
+		..\output\NuXJSTest_%target%_%model% || GOTO error
+		CALL .\BuildCpp.cmd %target% %model% ..\output\NuXJS_%target%_%model%.exe .\NuXJSREPL.cpp ..\src\NuXJS.cpp ..\src\stdlibJS.cpp || GOTO error
+		IF "%%E"=="1" (
+			SET TEST_DIRS=..\tests\conforming ..\tests\erroneous ..\tests\es3only ..\tests\es5 ..\tests\extremes ..\tests\from262 ..\tests\migrated ..\tests\regression ..\tests\stdlib ..\tests\unconforming ..\tests\unsorted
+		) ELSE (
+			SET TEST_DIRS=..\tests\conforming ..\tests\erroneous ..\tests\es3only ..\tests\extremes ..\tests\migrated ..\tests\regression ..\tests\stdlib ..\tests\unconforming ..\tests\unsorted
+		)
+		..\externals\PikaCmd\PikaCmd.exe .\test.pika -e -x ..\output\NuXJS_%target%_%model% %TEST_DIRS% || GOTO error
+		CALL runExamples.cmd %target% || GOTO error
+		ECHO Done NUXJS_ES5=%%E (%target% %model%)
+	)
+	ECHO Success!
+	POPD
+	EXIT /b 0
+)
+
+REM Default single-pass build and test
+IF /I "%target%"=="release" SET CPP_OPTIONS=/GR- %CPP_OPTIONS%
 MKDIR ..\output >NUL 2>&1
 CALL .\BuildCpp.cmd %target% %model% ..\output\NuXJSTest_%target%_%model%.exe .\NuXJSTest.cpp ..\src\NuXJS.cpp ..\src\stdlibJS.cpp || GOTO error
 ..\output\NuXJSTest_%target%_%model% -s >NUL 2>&1 || GOTO error
 ..\output\NuXJSTest_%target%_%model% || GOTO error
 CALL .\BuildCpp.cmd %target% %model% ..\output\NuXJS_%target%_%model%.exe .\NuXJSREPL.cpp ..\src\NuXJS.cpp ..\src\stdlibJS.cpp || GOTO error
-..\externals\PikaCmd\PikaCmd.exe .\test.pika -e -x ..\output\NuXJS_%target%_%model% ..\tests\ || GOTO error
+REM Select test directories; exclude ES5 tests only when explicitly disabled with /DNUXJS_ES5=0
+ECHO %CPP_OPTIONS% | FINDSTR /C:"/DNUXJS_ES5=0" >NUL
+IF ERRORLEVEL 0 (
+	SET TEST_DIRS=..\tests\conforming\ ..\tests\erroneous\ ..\tests\es3only\ ..\tests\extremes\..\tests\migrated\ ..\tests\regression\ ..\tests\stdlib\ ..\tests\unconforming\ ..\tests\unsorted
+) ELSE (
+	SET TEST_DIRS=..\tests\conforming\ ..\tests\erroneous\ ..\tests\es3only\ ..\tests\es5\ ..\tests\extremes\ ..\tests\from262\ ..\tests\migrated\ ..\tests\regression\ ..\tests\stdlib\ ..\tests\unconforming\ ..\tests\unsorted
+)
+..\externals\PikaCmd\PikaCmd.exe .\test.pika -e -x\ ..\output\NuXJS_%target%_%model% %TEST_DIRS% || GOTO error
 CALL runExamples.cmd %target% || GOTO error
 ECHO Success!
 POPD
diff --git a/tools/buildAndTest.sh b/tools/buildAndTest.sh
index 1a40282..f9c43fc 100755
--- a/tools/buildAndTest.sh
+++ b/tools/buildAndTest.sh
@@ -5,15 +5,56 @@ cd "$(dirname "$0")"
 target=${1-debug}
 model=${2-x64}
 
+# Build PikaCmd tools and update stdlibJS.cpp if needed (once per invocation)
 cd ../externals/PikaCmd
 if [ ! -e ./PikaCmd ]; then
 	bash ./BuildCpp.sh ./PikaCmd -DPLATFORM_STRING=UNIX PikaCmdAmalgam.cpp
 fi
 bash ./BuildPikaCmd.sh
 cd ../../tools
-if [ "../src/stdlib.js" -nt "../src/stdlibJS.cpp" ]; then
+# Rebuild stdlibJS.cpp when any relevant source changed (base stdlib, ES5 extras, or the minifier pipeline).
+if [ "../src/stdlib.js" -nt "../src/stdlibJS.cpp" ] || \
+   [ "../src/stdlibES5.js" -nt "../src/stdlibJS.cpp" ] || \
+   [ "./stdlibToCpp.pika" -nt "../src/stdlibJS.cpp" ] || \
+   [ "./stdlibMinifier.ppeg" -nt "../src/stdlibJS.cpp" ]; then
 	../externals/PikaCmd/PikaCmd ./stdlibToCpp.pika ../src/stdlib.js ../src/stdlibJS.cpp
 fi
+
+# When NUXJS_TEST_ES5_VARIANTS=1, run tests twice with NUXJS_ES5=0 and 1.
+if [ "${NUXJS_TEST_ES5_VARIANTS-0}" = "1" ]; then
+	# Optionally skip release target to speed up dev iterations.
+	if [ "$target" = "release" ] && [ "${NUXJS_SKIP_RELEASE-0}" = "1" ]; then
+		echo "Skipping release per NUXJS_SKIP_RELEASE=1"
+		exit 0
+	fi
+
+	CPP_OPTIONS_BASE="${CPP_OPTIONS-}"
+	mkdir ../output >/dev/null 2>&1 || true
+	for es5 in 0 1; do
+		echo "Building and testing with NUXJS_ES5=${es5} ($target $model)"
+		export CPP_OPTIONS="${CPP_OPTIONS_BASE} -DNUXJS_ES5=${es5}"
+		if [ "$target" == "release" ]; then
+			export CPP_OPTIONS="-fno-rtti ${CPP_OPTIONS}"
+		fi
+		bash ./BuildCpp.sh $target $model ../output/NuXJSTest_${target}_${model} ../tools/NuXJSTest.cpp ../src/NuXJS.cpp ../src/stdlibJS.cpp
+		../output/NuXJSTest_${target}_${model} -s >/dev/null 2>&1
+		../output/NuXJSTest_${target}_${model}
+		bash ./BuildCpp.sh $target $model ../output/NuXJS_${target}_${model} ../tools/NuXJSREPL.cpp ../src/NuXJS.cpp ../src/stdlibJS.cpp
+		# Select test directories; include ES5 tests only when ES5 is enabled.
+			if [ "$es5" = "1" ]; then
+					TEST_DIRS=(../tests/conforming ../tests/erroneous ../tests/es3only ../tests/es5 ../tests/extremes ../tests/from262 ../tests/migrated ../tests/regression ../tests/stdlib ../tests/unconforming ../tests/unsorted)
+			else
+					TEST_DIRS=(../tests/conforming ../tests/erroneous ../tests/es3only ../tests/extremes ../tests/migrated ../tests/regression ../tests/stdlib ../tests/unconforming ../tests/unsorted)
+			fi
+		../externals/PikaCmd/PikaCmd ./test.pika -e -x ../output/NuXJS_${target}_${model} "${TEST_DIRS[@]}"
+		bash ./runExamples.sh "$target"
+		echo "Done NUXJS_ES5=${es5} ($target $model)"
+	done
+	echo Success!
+	exit 0
+fi
+
+# Default single-pass build and test
 if [ "$target" == "release" ]; then
 	export CPP_OPTIONS="-fno-rtti ${CPP_OPTIONS-}"
 fi
@@ -22,7 +63,14 @@ bash ./BuildCpp.sh $target $model ../output/NuXJSTest_${target}_${model} ../tool
 ../output/NuXJSTest_${target}_${model} -s >/dev/null 2>&1
 ../output/NuXJSTest_${target}_${model}
 bash ./BuildCpp.sh $target $model ../output/NuXJS_${target}_${model} ../tools/NuXJSREPL.cpp ../src/NuXJS.cpp ../src/stdlibJS.cpp
-../externals/PikaCmd/PikaCmd ./test.pika -e -x ../output/NuXJS_${target}_${model} ../tests/
+
+# Select test directories; exclude ES5 tests only when explicitly disabled with -DNUXJS_ES5=0.
+if echo " ${CPP_OPTIONS-} " | grep -q -- "-DNUXJS_ES5=0"; then
+	TEST_DIRS=(../tests/conforming/ ../tests/erroneous/ ../tests/es3only/ ../tests/extremes/ ../tests/migrated/ ../tests/regression/ ../tests/stdlib/ ../tests/unconforming/ ../tests/unsorted)
+else
+	TEST_DIRS=(../tests/conforming/ ../tests/erroneous/ ../tests/es3only/ ../tests/es5/ ../tests/extremes/ ../tests/from262/ ../tests/migrated/ ../tests/regression/ ../tests/stdlib/ ../tests/unconforming/ ../tests/unsorted)
+fi
+../externals/PikaCmd/PikaCmd ./test.pika -e -x ../output/NuXJS_${target}_${model} "${TEST_DIRS[@]}"
 bash ./runExamples.sh "$target"
 
 echo Success!
diff --git a/tools/diffs/whitespace_ignored_diff_from_main.patch b/tools/diffs/whitespace_ignored_diff_from_main.patch
new file mode 100644
index 0000000..2c2c25a
--- /dev/null
+++ b/tools/diffs/whitespace_ignored_diff_from_main.patch
@@ -0,0 +1,2795 @@
+diff --git a/docs/ES5.1 Roadmap.md b/docs/ES5.1 Roadmap.md
+new file mode 100644
+index 000000000..4791d2522
+--- /dev/null
++++ b/docs/ES5.1 Roadmap.md	
+@@ -0,0 +1,109 @@
++# ES5.1 Implementation Roadmap
++
++## Overview
++NuXJS today is a portable C++03 engine that fully implements ECMAScript 3 with a few ES5 conveniences such as JSON support and indexed string access. Custom property getters and setters are not yet available and `Object.defineProperty` only handles data properties. Built‑in library objects are written directly in JavaScript and omit modern helpers like `Object.assign` or `Array.prototype.map`. The repository already contains a broad test suite, including `tests/from262` for conformance.
++
++All ES5.1 work should be driven by regression tests. Whenever a roadmap item lands, reference its verifying `.io` file in this document.
++ES5‑specific regression tests live in `tests/es5`.
++
++## Roadmap to ES5.1
++
++### Object model & descriptors
++	- Extend the internal property representation to track attributes (`[[Writable]]`, `[[Enumerable]]`, `[[Configurable]]`) and accessor pairs.
++       - `src/NuXJS.h` defines `Object::Table::Bucket`; expand the union to hold either a `Value` or a `{ get, set }` pair and add an `ACCESSOR_FLAG` bit.
++       - Update `Object::getProperty` and `Object::setProperty` in `src/NuXJS.cpp` so that accessor buckets surface the getter or setter function while respecting attribute bits during writes and deletes.
++               - `GET_PROPERTY_OP` in `Processor` already delegates to `Object::getProperty`; when an `ACCESSOR_FLAG` bucket is found, the getter function replaces the original value and the processor invokes it via its standard `invokeFunction` path with the object as `this`, leaving the call result on the stack.
++               - `SET_PROPERTY_OP` similarly uses `Object::setProperty`; when an accessor exists, the processor calls the setter through `invokeFunction` with the provided value and keeps the caller's value as the final result.
++- Implement full `Object.defineProperty`, `Object.defineProperties`, `Object.getOwnPropertyDescriptor`, and `Object.create` in both the C++ core and `src/stdlib.js`.
++- Replace the legacy `support.defineProperty(o, name, value, readOnly, dontEnum, dontDelete)` with a `PropertyDescriptor` structure that can carry `value`, `get`, `set`, and attribute flags.
++- The runtime helper in `src/NuXJS.cpp` should validate descriptor combinations and install either a data or accessor property in the object's hash table.
++- Expose enumeration helpers like `Object.keys` and `Object.getOwnPropertyNames`.
++	- `Object.keys` implemented in `src/stdlib.js` (`tests/es5/objectKeys.io`).
++	- `Object.getOwnPropertyNames` pending; requires a runtime iterator that can expose non-enumerable properties.
++	- Add support for accessor syntax (`get`/`set` in object literals) and function prototype attributes.
++- Extend the parser to recognize `get name(){}` and `set name(v){}` tokens and emit descriptor objects for property creation.
++- Bootstrapping of built‑ins in `src/stdlib.js` can then define getters on prototypes, e.g. for `Function.prototype.name`.
++
++### Strict mode
++- Detect strict directives and propagate mode.
++    - Add a `bool strict` member to `Code` in `src/NuXJS.h`. *(Implemented; `tests/es5/strictThisBinding.io`)*
++   - In `Compiler::compile` and `compileFunction` (`src/NuXJS.cpp`), scan the directive prologue by walking the leading string literals before any other token. A literal whose contents are exactly `use strict` (10 characters, case‑sensitive) toggles `code->strict`. *(Implemented; `tests/es5/strictThisBinding.io`)*
++- Enforce identifier restrictions and parameter checks.
++   - Update `Compiler::identifier` so `eval` and `arguments` trigger a syntax error when the current scope is strict. *(Implemented; `tests/es5/strictEvalArgsBinding.io`)*
++   - During parameter list parsing, reject duplicate names in strict functions. *(Implemented; `tests/es5/strictDuplicateParam.io`)*
++- Preserve `undefined` for unbound `this` values.
++    - Modify `Processor::enter` to skip substituting the global object when `code->strict` is set. *(Implemented; `tests/es5/strictThisBinding.io`)*
++- Reject `with` statements in strict code.
++    - Have `Compiler::withStatement` test the active scope’s `strict` flag and emit a syntax error if encountered. *(Implemented; `tests/es5/strictWithStatement.io`)*
++- Propagate strict mode through `eval` and isolate its environment. *(Implemented; `tests/es5/strictEvalScope.io`)*
++    - Pass the caller’s strict flag to `CALL_EVAL_OP` and down to `Runtime::compileEvalCode` and `Processor::enterEvalCode`. *(Implemented; `tests/es5/strictEvalScope.io`)*
++    - When strict, compile eval code with a fresh variable environment. *(Implemented; `tests/es5/strictEvalScope.io`)*
++- Tighten `delete` semantics.
++    - If `delete` targets a simple identifier in strict mode, emit a syntax error instead of `DELETE_NAMED_OP`. *(Implemented; `tests/es5/strictDeleteIdentifier.io`)*
++- Disallow implicit global variable creation.
++   - When strict code assigns to an undeclared identifier, raise a `ReferenceError` rather than defining a global property. *(Implemented; `tests/es5/strictImplicitGlobal.io`)*
++- Implement strict arguments-object behavior. *(Implemented; `tests/es5/strictArgumentsObject.io`)*
++    - Introduce a non-mapped `ArgumentsObject` variant and construct it in `FunctionScope` when `code->strict`. *(Implemented; `tests/es5/strictArgumentsObject.io`)*
++    - Ensure `arguments` does not alias parameters. *(Implemented; `tests/es5/strictArgumentsObject.io`)*
++
++### Arguments object & function semantics
++- Implement ES5.1 arguments-object behavior (decoupled mapping, `Object.getOwnPropertyDescriptor` support).
++	- Introduce an `ArgumentsObject` class that can either map indices to parameters or, in strict mode, hold a copy without parameter aliases.
++	- `Object.getOwnPropertyDescriptor` on arguments must expose `length`, `callee`, and indexed properties with correct attributes.
++- Provide `Function.prototype.bind` and ensure correct `.name`, `.length`, and `toString` outputs.
++	- Implement `bind` in `src/stdlib.js`; the resulting bound functions require a C++ backing type to store the target, bound `this`, and partial arguments while exposing an adjusted `length` and `name`.
++        - Revise function serialization so that `Function.prototype.toString` reconstructs source code for bound and native functions.
++
++### Spec compliance fixes
++- Align ES5 semantics that differ from the current engine implementation.
++	- Permit `for...in` on `null` or `undefined` to yield an empty iteration instead of throwing.  *(see `docs/notes/ECMAScript Compatibility Notes.md`)*
++	- Make user-defined functions' `prototype` properties non-enumerable and adjust `name`/`length` attributes to match ES5.1.
++	- Update `Object.prototype.toString` so `arguments` objects report `[object Arguments]` and enumerate indexed slots during `for...in`.
++	- Add regression tests for each behaviour in `tests/es5`.
++
++### Array & string methods
++- Add ES5.1 array iteration utilities: `forEach`, `map`, `filter`, `some`, `every`, `reduce`, `reduceRight`, `indexOf`, `lastIndexOf`.
++- These are pure library additions to `src/stdlib.js`; each helper must follow the spec's callback invocation pattern and handle sparse arrays via `Object` property checks rather than simple loops.
++- `Array.prototype.indexOf` and `Array.prototype.lastIndexOf` implemented (`tests/es5/arrayIndexOf.io`).
++- `Array.prototype.forEach` implemented (`tests/es5/arrayForEach.io`).
++- `Array.prototype.map` and `Array.prototype.filter` implemented (`tests/es5/arrayMapFilter.io`).
++- `Array.prototype.some` and `Array.prototype.every` implemented (`tests/es5/arraySomeEvery.io`).
++- `Array.prototype.reduce` and `Array.prototype.reduceRight` implemented (`tests/es5/arrayReduce.io`).
++- Implement string utilities like `trim`, `trimLeft`, `trimRight`, and JSON-related `toJSON` helpers.
++- Extend the string section in `src/stdlib.js` with whitespace tables identical to the spec and expose `String.prototype.trim*` methods.
++ - `String.prototype.trim` implemented (`tests/es5/stringTrim.io`).
++ - `String.prototype.trimLeft` and `trimRight` implemented (`tests/es5/stringTrimLeftRight.io`).
++- Add `Date.prototype.toJSON` and `Number.prototype.toJSON` wrappers that call the internal `toISOString`/conversion paths.
++
++### Object immutability controls
++- Support `Object.preventExtensions`, `Object.seal`, `Object.freeze`, and related predicates (`isExtensible`, `isSealed`, `isFrozen`).
++	- Add an `extensible` flag to the base `Object` class and teach `setProperty`/`setOwnProperty` to honor it, returning false when extensions are blocked.
++	- Implement helpers in `src/stdlib.js` that iterate over `Object.getOwnPropertyNames` descriptors and toggle `[[Configurable]]`/`[[Writable]]` bits as required by `seal` and `freeze`.
++
++### Date and Number extras
++- Finish remaining ES5.1 Date features such as `toISOString`, `toJSON`, and `now`.
++ - `Date.now` implemented using `support.getCurrentTime` (`tests/es5/dateNow.io`).
++- Add a spec‑compliant `toISOString` implementation in JavaScript.
++- Add Number and Math helpers (`isNaN`, `isFinite` refinements, `parseInt`/`parseFloat` alignment).
++	- Refine `support.isNaN`/`isFinite` semantics and expose `Number.isNaN` and `Number.isFinite` shims.
++	- Ensure `parseInt` and `parseFloat` follow ES5.1 whitespace trimming rules and radix handling; update the `Math` object with any missing constants.
++
++### Parser/VM robustness
++- Update grammar to allow reserved words as property keys and recognize accessor definitions.
++	- Expand the lexical grammar in `src/Parser.cpp` to treat keywords as identifiers in object literals and hook into the new accessor creation path.
++- Revisit bytecode generation for new features and enforce ES5.1 evaluation order.
++	- The compiler in `src/NuXJS.cpp` must emit bytecode for accessors, strict arguments, and `bind` calls while guaranteeing left‑to‑right evaluation as mandated by ES5.1.
++
++### Testing & conformance
++- Expand the existing `tests/from262` set with ES5.1 cases from Test262.
++- Import the ES5.1 section of Test262 and hook them into the `tests/from262` runner so failures can be tracked.
++- Introduce regression tests for each new feature and run the full suite (`timeout 180 ./build.sh`) during development.
++ - Add coverage in `tests/es5` for accessor edge cases, strict‑mode violations, and bound function behavior before shipping any change.
++
++### Documentation & tooling
++- Revise compatibility notes and TypeScript guidance to reflect ES5.1 support.
++- Expand `docs/notes/ECMAScript Compatibility Notes.md` once features land and document any intentional deviations.
++- Update examples and `lib.NuXJS.d.ts` to expose new APIs and maintain TypeScript type safety.
++- Regenerate declaration files so that editors pick up getters/setters and newly added methods.
++- Refresh `docs/NuXJS Documentation.md` once features land.
++- The "Partial ES5 features" table currently lists the arguments object as ES3-mapped and `Object.defineProperty` as data-only; rewrite these notes after the new behavior ships.
+diff --git a/docs/getter-setter-attempt.md b/docs/getter-setter-attempt.md
+new file mode 100644
+index 000000000..bb57cce59
+--- /dev/null
++++ b/docs/getter-setter-attempt.md
+@@ -0,0 +1,13 @@
++# Getter/Setter Work
++
++Initial infrastructure for ES5.1 accessor properties is in place. A new `Accessor` object stores getter and setter pairs in property buckets flagged with `ACCESSOR_FLAG`.
++
++`Object.defineProperty` now accepts descriptor objects containing `get` or `set` and forwards the functions to the runtime without invoking the blocking `Runtime::call` path.
++
++However, accessor properties remain non-functional: the example in `examples/getter_setter_example.cpp` still prints `obj.value = undefined` and leaves `obj._v` unchanged. Further work is needed to wire descriptor plumbing to property lookup and write paths.
++
++Current limitations:
++- Descriptor validation is minimal and object literal `get`/`set` syntax is still unparsed.
++- Redefinition semantics and strict mode error handling remain incomplete.
++- Runtime `support.defineProperty` receives `undefined` for the `get` and `set` slots, indicating argument propagation from the
++  JavaScript wrapper is still broken.
+diff --git a/examples/getter_setter_example.cpp b/examples/getter_setter_example.cpp
+new file mode 100644
+index 000000000..e3a29b9f3
+--- /dev/null
++++ b/examples/getter_setter_example.cpp
+@@ -0,0 +1,57 @@
++/**
++	NuXJS is released under the BSD 2-Clause License.
++
++	Copyright (c) 2018-2025, Magnus Lidström
++
++	Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
++	following conditions are met:
++
++	1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following
++	disclaimer.
++
++	2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
++	disclaimer in the documentation and/or other materials provided with the distribution.
++
++	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
++	INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
++	DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
++	SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
++	SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
++	WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
++	OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
++**/
++
++#include <iostream>
++#include "../src/NuXJS.h"
++
++using namespace NuXJS;
++
++int main() {
++	Heap heap;
++	Runtime rt(heap);
++	rt.setupStandardLibrary();
++
++	Var globals = rt.getGlobalsVar();
++rt.run(
++"var obj = {\n" \
++"\t_v: 1,\n" \
++"\tget value() { return this._v; },\n" \
++"\tset value(v) { this._v = v; },\n" \
++"\tget double() { return this._v * 2; },\n" \
++"\tset double(v) { this._v = v / 2; }\n" \
++"};\n" \
++"var start = obj.value;\n" \
++"var startDouble = obj.double;\n" \
++"obj.double = 50;\n" \
++"var afterSetDouble = obj.value;\n" \
++"obj.value = 15;\n" \
++"var finalDouble = obj.double;"
++);
++	Var obj = globals["obj"];
++	std::wcout << L"start = " << globals["start"].to<int>() << std::endl;
++	std::wcout << L"startDouble = " << globals["startDouble"].to<int>() << std::endl;
++	std::wcout << L"afterSetDouble = " << globals["afterSetDouble"].to<int>() << std::endl;
++	std::wcout << L"finalDouble = " << globals["finalDouble"].to<int>() << std::endl;
++	std::wcout << L"obj._v = " << obj["_v"].to<int>() << std::endl;
++	return 0;
++}
+diff --git a/src/NuXJS.cpp b/src/NuXJS.cpp
+index 091635a04..5ba35b11d 100644
+--- a/src/NuXJS.cpp
++++ b/src/NuXJS.cpp
+@@ -180,6 +180,8 @@ const String A_RGUMENTS_STRING("Arguments"), A_RRAY_STRING("Array"), B_OOLEAN_ST
+                 , E_RROR_STRING("Error"), F_UNCTION_STRING("Function"), N_UMBER_STRING("Number"), O_BJECT_STRING("Object")
+                 , S_TRING_STRING("String");
+ 
++const String GET_STRING("get"), SET_STRING("set");
++
+ static const String ANONYMOUS_STRING("anonymous"), ARGUMENTS_STRING("arguments")
+ 		, BRACKET_OBJECT_STRING("[object "), CALLEE_STRING("callee")
+ 		, CANNOT_CONVERT_TO_OBJECT_STRING("Cannot convert undefined or null to object")
+@@ -1277,6 +1279,7 @@ const String* Object::getClassName() const { return &O_BJECT_STRING; }
+ Object* Object::getPrototype(Runtime& rt) const { return rt.getObjectPrototype(); }
+ Value Object::getInternalValue(Heap&) const { return UNDEFINED_VALUE; }
+ Flags Object::getOwnProperty(Runtime&, const Value&, Value*) const { return NONEXISTENT; }
++bool Object::setOwnProperty(Runtime& rt, const String* key, const Value& v, Flags flags) { return setOwnProperty(rt, Value(key), v, flags); }
+ bool Object::setOwnProperty(Runtime&, const Value&, const Value&, Flags) { return false; }
+ bool Object::deleteOwnProperty(Runtime&, const Value&) { return false; }
+ Enumerator* Object::getOwnPropertyEnumerator(Runtime&) const { return &EMPTY_ENUMERATOR; }
+@@ -1316,6 +1319,31 @@ Flags Object::getProperty(Runtime& rt, const Value& key, Value* v) const {
+ 	return NONEXISTENT;
+ }
+ 
++Flags Object::getProperty(Runtime& rt, Processor& processor, const Value& key, Value* v) const {
++const Object* o = this;
++do {
++Value current;
++Flags flags = o->getOwnProperty(rt, key, &current);
++if (flags != NONEXISTENT) {
++if ((flags & ACCESSOR_FLAG) != 0) {
++Accessor* acc = static_cast<Accessor*>(current.asObject());
++Function* getter = (acc != 0 ? acc->getter : 0);
++if (getter != 0) {
++processor.invokeFunction(getter, 0, static_cast<const Value*>(0), const_cast<Object*>(this));
++} else {
++*v = UNDEFINED_VALUE;
++}
++} else {
++*v = current;
++}
++return flags;
++}
++o = o->getPrototype(rt);
++} while (o != 0);
++return NONEXISTENT;
++}
++
++
+ bool Object::setProperty(Runtime& rt, const Value& key, const Value& v) {
+ 	if (updateOwnProperty(rt, key, v)) {
+ 		return true;
+@@ -1330,6 +1358,23 @@ bool Object::setProperty(Runtime& rt, const Value& key, const Value& v) {
+ 	return setOwnProperty(rt, key, v);
+ }
+ 
++bool Object::setProperty(Runtime& rt, Processor& processor, const Value& key, const Value& v) {
++Value current;
++Flags flags = getProperty(rt, key, &current);
++if (flags != NONEXISTENT && (flags & ACCESSOR_FLAG) != 0) {
++Accessor* acc = static_cast<Accessor*>(current.asObject());
++Function* setter = (acc != 0 ? acc->setter : 0);
++if (setter != 0) {
++Value arg(v);
++processor.invokeFunction(setter, 1, &arg, const_cast<Object*>(this));
++return true;
++}
++return false;
++}
++setProperty(rt, key, v);
++return false;
++}
++
+ Enumerator* Object::getPropertyEnumerator(Runtime& rt) const {
+ 	Heap& heap = rt.getHeap();
+ 	Enumerator* enumerator = getOwnPropertyEnumerator(rt);
+@@ -1479,9 +1524,26 @@ JSObject::JSObject(GCList& gcList, Object* prototype)
+ Object* JSObject::getPrototype(Runtime&) const { return prototype; }
+ 
+ bool JSObject::setOwnProperty(Runtime& rt, const Value& key, const Value& v, Flags flags) {
+-	return update(insert(key.toString(rt.getHeap())), v, flags);
++	return setOwnProperty(rt, key.toString(rt.getHeap()), v, flags);
++}
++
++bool JSObject::setOwnProperty(Runtime& rt, const String* key, const Value& v, Flags flags) {
++	Table::Bucket* bucket = insert(key);
++	if ((flags & ACCESSOR_FLAG) != 0 && bucket->valueExists() && (bucket->getFlags() & ACCESSOR_FLAG) != 0) {
++	Accessor* acc = static_cast<Accessor*>(bucket->getValue().getObject());
++	Accessor* nv = static_cast<Accessor*>(v.getObject());
++	if (nv->getter != 0) {
++	acc->getter = nv->getter;
++	}
++	if (nv->setter != 0) {
++	acc->setter = nv->setter;
++	}
++	return true;
++	}
++	return update(bucket, v, flags);
+ }
+ 
++
+ bool JSObject::updateOwnProperty(Runtime& rt, const Value& key, const Value& v) {
+ 	Table::Bucket* bucket = lookup(key.toString(rt.getHeap()));
+ 	return (bucket != 0 && update(bucket, v));
+@@ -1495,7 +1557,6 @@ Flags JSObject::getOwnProperty(Runtime& rt, const Value& key, Value* v) const {
+ 	}
+ 	return NONEXISTENT;
+ }
+-
+ bool JSObject::deleteOwnProperty(Runtime& rt, const Value& key) {
+ 	Table::Bucket* bucket = lookup(key.toString(rt.getHeap()));
+ 	return (bucket == 0 || erase(bucket));
+@@ -1553,7 +1614,7 @@ Code::Code(GCList& gcList, Constants* sharedConstants)
+ 	: super(gcList), codeWords(0, &gcList.getHeap())
+ 	, constants(sharedConstants ? sharedConstants : new(gcList.getHeap()) Constants(gcList.getHeap().managed()))
+ 	, nameIndexes(&gcList.getHeap()), varNames(&gcList.getHeap()), argumentNames(&gcList.getHeap()), name(0)
+-	, selfName(0), source(0), bloomSet(0), maxStackDepth(0)
++, selfName(0), source(0), bloomSet(0), maxStackDepth(0), strict(false)
+ {
+ 	assert(constants != 0);
+ }
+@@ -1697,6 +1758,10 @@ bool JSArray::setElement(Runtime& rt, UInt32 index, const Value& v) {
+ 	return super::setOwnProperty(rt, index, v, STANDARD_FLAGS);
+ }
+ 
++bool JSArray::setOwnProperty(Runtime& rt, const String* key, const Value& v, Flags flags) {
++	return setOwnProperty(rt, Value(key), v, flags);
++}
++
+ bool JSArray::setOwnProperty(Runtime& rt, const Value& key, const Value& v, Flags flags) {
+ 	UInt32 index;
+ 	if (key.toArrayIndex(index) && index != 0xFFFFFFFFU) {
+@@ -1754,6 +1819,10 @@ template<class SUPER> bool LazyJSObject<SUPER>::setOwnProperty(Runtime& rt, cons
+ 	return getCompleteObject(rt)->setOwnProperty(rt, key, v, flags);
+ }
+ 
++template<class SUPER> bool LazyJSObject<SUPER>::setOwnProperty(Runtime& rt, const String* key, const Value& v, Flags flags) {
++	return getCompleteObject(rt)->setOwnProperty(rt, key, v, flags);
++}
++
+ template<class SUPER> bool LazyJSObject<SUPER>::deleteOwnProperty(Runtime& rt, const Value& key) {
+ 	return getCompleteObject(rt)->deleteOwnProperty(rt, key);
+ }
+@@ -1828,6 +1897,12 @@ void Error::updateReflection(Runtime& rt) {
+ 	message = (getProperty(rt, &MESSAGE_STRING, &v) != NONEXISTENT ? v.toString(rt.getHeap()) : 0);
+ }
+ 
++bool Error::setOwnProperty(Runtime& rt, const String* key, const Value& v, Flags flags) {
++	const bool result = super::setOwnProperty(rt, key, v, flags);
++	updateReflection(rt);
++	return result;
++}
++
+ bool Error::setOwnProperty(Runtime& rt, const Value& key, const Value& v, Flags flags) {
+ 	const bool result = super::setOwnProperty(rt, key, v, flags);
+ 	updateReflection(rt);
+@@ -1850,7 +1925,7 @@ void Error::constructCompleteObject(Runtime& rt) const {
+ 
+ Arguments::Arguments(GCList& gcList, const FunctionScope* scope, UInt32 argumentsCount) : super(gcList)
+ 	, scope(scope), function(scope->function), argumentsCount(argumentsCount)
+-	   , deletedArguments(argumentsCount, &gcList.getHeap()), values(0, &gcList.getHeap()) {
++	, deletedArguments(argumentsCount, &gcList.getHeap()), values(0, &gcList.getHeap()), owner(const_cast<FunctionScope*>(scope)) {
+ 	std::fill(deletedArguments.begin(), deletedArguments.end(), false);
+ }
+ 
+@@ -1884,6 +1959,10 @@ Flags Arguments::getOwnProperty(Runtime& rt, const Value& key, Value* v) const {
+ 	return (p == 0 ? super::getOwnProperty(rt, key, v) : ((void)(*v = *p), (DONT_ENUM_FLAG | EXISTS_FLAG)));
+ }
+ 
++bool Arguments::setOwnProperty(Runtime& rt, const String* key, const Value& v, Flags flags) {
++	return setOwnProperty(rt, Value(key), v, flags);
++}
++
+ bool Arguments::setOwnProperty(Runtime& rt, const Value& key, const Value& v, Flags flags) {
+ 	Value* p = findProperty(key);
+ 	if (p != 0 && (flags & (READ_ONLY_FLAG | DONT_ENUM_FLAG | DONT_DELETE_FLAG)) != 0) {
+@@ -1910,8 +1989,8 @@ void Arguments::constructCompleteObject(Runtime& rt) const {
+ }
+ 
+ Arguments::~Arguments() {
+-	if (scope != 0) {
+-		scope->arguments = 0;
++	if (owner != 0) {
++		owner->arguments = 0;
+ 	}
+ }
+ 
+@@ -1961,13 +2040,24 @@ FunctionScope::FunctionScope(GCList& gcList, JSFunction* function, UInt32 argc,
+ 	if (code->getArgumentsCount() > argc) {
+ 		std::fill(e, locals.end(), UNDEFINED_VALUE);
+ 	}
++	if (code->strict) {
++		Heap& heap = gcList.getHeap();
++		arguments = new(heap) Arguments(heap.managed(), this, passedArgumentsCount);
++		arguments->detach();
++	}
++
+ }
+ 
+ JSObject* FunctionScope::getDynamicVars(Runtime& rt) const {
+ 	if (dynamicVars == 0) {
+ 		Heap& heap = rt.getHeap();
+ 		dynamicVars = new(heap) JSObject(heap.managed(), 0);
++		if (arguments == 0) {
+ 			arguments = new(heap) Arguments(heap.managed(), this, passedArgumentsCount);
++			if (function->code->strict) {
++				arguments->detach();
++			}
++		}
+ 		dynamicVars->setOwnProperty(rt, &ARGUMENTS_STRING, arguments, DONT_DELETE_FLAG);
+ 	}
+ 	return dynamicVars;
+@@ -2062,6 +2152,7 @@ void FunctionScope::declareVar(Runtime& rt, const String* name, const Value& ini
+ 
+ FunctionScope::~FunctionScope() {
+         if (arguments != 0) {
++                arguments->owner = 0;
+                 arguments->detach();
+                 arguments = 0;
+         }
+@@ -2095,7 +2186,8 @@ static struct EvalFunction : public Function {
+ 
+ 		Heap& heap = rt.getHeap();
+ 		const String* expression = argv[0].toString(heap);
+-		processor.enterEvalCode(rt.compileEvalCode(expression), direct);
++		bool strict = direct && processor.isCurrentStrict();
++		processor.enterEvalCode(rt.compileEvalCode(expression, strict), direct);
+ 		return UNDEFINED_VALUE;
+ 	}
+ 	bool direct;
+@@ -2119,6 +2211,8 @@ const Processor::OpcodeInfo Processor::opcodeInfo[Processor::OP_COUNT] = {
+ 	{ SET_PROPERTY_OP            , "SET_PROPERTY"            , -2     , 0 },
+ 	{ SET_PROPERTY_POP_OP        , "SET_PROPERTY_POP"        , -3     , 0 },
+ 	{ ADD_PROPERTY_OP            , "ADD_PROPERTY"            , -1     , 0 },
++	{ ADD_GETTER_OP            , "ADD_GETTER"             , -1     , 0 },
++	{ ADD_SETTER_OP            , "ADD_SETTER"             , -1     , 0 },
+ 	{ PUSH_ELEMENTS_OP           , "PUSH_ELEMENTS_OP"        , 0      , OpcodeInfo::POP_OPERAND },
+ 	{ OBJ_TO_PRIMITIVE_OP        , "OBJ_TO_PRIMITIVE"        , 0      , 0 },
+ 	{ OBJ_TO_NUMBER_OP           , "OBJ_TO_NUMBER"           , 0      , 0 },
+@@ -2202,10 +2296,49 @@ const Processor::OpcodeInfo& Processor::getOpcodeInfo(const Opcode opcode) {
+ */
+ struct Processor::EvalScope : public Scope {
+ 		typedef Scope super;
+-	EvalScope(GCList& gcList, Scope* parentScope) : super(gcList, parentScope) { }
+-	virtual void declareVar(Runtime& rt, const String* name, const Value& initValue, bool) {
++		EvalScope(GCList& gcList, Scope* parentScope, bool isolated) : super(gcList, parentScope), vars(0), isolated(isolated) { }
++		virtual Flags readVar(Runtime& rt, const String* name, Value* v) const {
++			if (isolated && vars != 0) {
++				const Flags flags = vars->getOwnProperty(rt, name, v);
++				if (flags != NONEXISTENT) {
++					return flags;
++				}
++			}
++			return parentScope->readVar(rt, name, v);
++		}
++		virtual void writeVar(Runtime& rt, const String* name, const Value& value) {
++			if (isolated && vars != 0) {
++				Value tmp;
++				if (vars->getOwnProperty(rt, name, &tmp) != NONEXISTENT) {
++					vars->setOwnProperty(rt, name, value);
++					return;
++				}
++			}
++			parentScope->writeVar(rt, name, value);
++		}
++		virtual bool deleteVar(Runtime& rt, const String* name) {
++			if (isolated && vars != 0 && vars->deleteOwnProperty(rt, name)) {
++				return true;
++			}
++			return parentScope->deleteVar(rt, name);
++		}
++		virtual void declareVar(Runtime& rt, const String* name, const Value& initValue, bool dontDelete) {
++			if (isolated) {
++				if (vars == 0) {
++					Heap& heap = rt.getHeap();
++					vars = new(heap) JSObject(heap.managed(), 0);
++				}
++				vars->setOwnProperty(rt, name, initValue.isUndefined() ? UNDEFINED_VALUE : initValue, dontDelete ? DONT_DELETE_FLAG : 0);
++			} else {
+ 				parentScope->declareVar(rt, name, initValue, false);
+ 			}
++		}
++		JSObject* vars;
++		bool isolated;
++		virtual void gcMarkReferences(Heap& heap) const {
++			gcMark(heap, vars);
++			super::gcMarkReferences(heap);
++		}
+ };
+ 	
+ /*
+@@ -2313,7 +2446,8 @@ void Processor::enter(const Code* code, Scope* scope, Object* thisObject) {
+ 	if (sp + code->getMaxStackDepth() > stack.end()) {
+ 		ScriptException::throwError(heap, RANGE_ERROR, &STACK_OVERFLOW_STRING); // Notice: we can't use virtual throw here, cause we need to abort any sp changes etc that could happen if we continued execution beyond this point.
+ 	} else {
+-		pushFrame(code, scope, (thisObject == 0 ? rt.getGlobalObject() : thisObject));
++Object* obj = (thisObject == 0 && !code->isStrict() ? rt.getGlobalObject() : thisObject);
++pushFrame(code, scope, obj);
+ 		ip = code->getCodeWords();
+ 	}
+ }
+@@ -2326,14 +2460,16 @@ void Processor::enterGlobalCode(const Code* code) {
+ 	enter(code, rt.getGlobalScope(), rt.getGlobalObject());
+ }
+ 
+-void Processor::enterEvalCode(const Code* code, bool local) {
+-	if (local && currentFrame != 0) {
+-		enter(code, new(heap) Processor::EvalScope(heap.managed(), currentFrame->scope), currentFrame->thisObject);
++void Processor::enterEvalCode(const Code* code, bool direct) {
++	bool isolate = direct && code->isStrict();
++	if (direct && currentFrame != 0) {
++		enter(code, new(heap) Processor::EvalScope(heap.managed(), currentFrame->scope, isolate), currentFrame->thisObject);
+ 	} else {
+-		enter(code, new(heap) Processor::EvalScope(heap.managed(), rt.getGlobalScope()), rt.getGlobalObject());
++		enter(code, new(heap) Processor::EvalScope(heap.managed(), rt.getGlobalScope(), isolate), rt.getGlobalObject());
+ 	}
+ }
+ 
++
+ void Processor::enterFunctionCode(JSFunction* func, UInt32 argc, const Value* argv, Object* thisObject) {
+ 	enter(func->code, new(heap) FunctionScope(heap.managed(), func, argc, argv), thisObject);
+ }
+@@ -2451,42 +2587,80 @@ void Processor::innerRun() {
+ 				}
+ 			}
+ 			break;
+-			case WRITE_NAMED_OP:		scope->writeVar(rt, constants[im].getString(), sp[0]); break;
+-			case WRITE_NAMED_POP_OP:	scope->writeVar(rt, constants[im].getString(), sp[0]); pop(1); break;
+-
++			case WRITE_NAMED_OP: {
++				const String* name = constants[im].getString();
++				if (code->isStrict()) {
++					Value dummy;
++					if (scope->readVar(rt, name, &dummy) == NONEXISTENT) {
++						error(REFERENCE_ERROR, new(heap) String(heap.managed(), *name, IS_NOT_DEFINED_STRING));
++						return;
++					}
++				}
++				scope->writeVar(rt, name, sp[0]);
++			}
++			break;
++			case WRITE_NAMED_POP_OP: {
++				const String* name = constants[im].getString();
++				if (code->isStrict()) {
++					Value dummy;
++					if (scope->readVar(rt, name, &dummy) == NONEXISTENT) {
++						error(REFERENCE_ERROR, new(heap) String(heap.managed(), *name, IS_NOT_DEFINED_STRING));
++						return;
++					}
++				}
++				scope->writeVar(rt, name, sp[0]);
++				pop(1);
++			}
++			break;
+ case GET_PROPERTY_OP: {
+ const Object* o = convertToObject(sp[-1], false);
+ if (o == 0) {
+ return;
+ }
+-				if (o->getProperty(rt, sp[0], sp - 1) == NONEXISTENT) {
++Flags f = o->getProperty(rt, *this, sp[0], sp - 1);
++if (f == NONEXISTENT) {
+ sp[-1] = UNDEFINED_VALUE;
++pop(1);
++break;
+ }
+ pop(1);
++if ((f & ACCESSOR_FLAG) != 0) {
++return;
++}
+ break;
+ }
+ 
++			
+ case SET_PROPERTY_OP: {
+ Object* o = convertToObject(sp[-2], false);
+ if (o == 0) {
+ return;
+ }
+-				o->setProperty(rt, sp[-1], sp[0]);
+-				sp[-2] = sp[0];
++Value v = sp[0];
++bool acc = o->setProperty(rt, *this, sp[-1], sp[0]);
++sp[-2] = v;
+ pop(2);
++if (acc) {
++return;
++}
+ break;
+ }
+ 
++			
+ case SET_PROPERTY_POP_OP: {
+ Object* o = convertToObject(sp[-2], false);
+ if (o == 0) {
+ return;
+ }
+-				o->setProperty(rt, sp[-1], sp[0]);
++bool acc = o->setProperty(rt, *this, sp[-1], sp[0]);
+ pop(3);
++if (acc) {
++return;
++}
+ break;
+ }
+ 
++
+ 			case OBJ_TO_PRIMITIVE_OP:
+ 			case OBJ_TO_NUMBER_OP:
+ 			case OBJ_TO_STRING_OP: {
+@@ -2596,7 +2770,7 @@ void Processor::innerRun() {
+ 			case NEW_ARRAY_OP: push(new(heap) JSArray(heap.managed())); break;
+ 			case NEW_REG_EXP_OP: invokeFunction(rt.createRegExpFunction, 1, 2); return;
+ 			case RETURN_OP:	ip = currentFrame->returnIP; popFrame(); return;
+-			case THIS_OP: push(thisObject); break;
++case THIS_OP: push(thisObject != 0 ? Value(thisObject) : UNDEFINED_VALUE); break;
+ 			case VOID_OP: push(UNDEFINED_VALUE); break;
+ 			
+ 			case GEN_FUNC_OP: {
+@@ -2615,6 +2789,20 @@ void Processor::innerRun() {
+ 				pop(1);
+ 				break;
+ 			}
++			case ADD_GETTER_OP: {
++				Object* o = sp[-1].getObject();
++				Accessor* acc = new(heap) Accessor(heap.managed(), sp[0].asFunction(), 0);
++				o->setOwnProperty(rt, constants[im], acc, ACCESSOR_FLAG);
++				pop(1);
++				break;
++			}
++			case ADD_SETTER_OP: {
++				Object* o = sp[-1].getObject();
++				Accessor* acc = new(heap) Accessor(heap.managed(), 0, sp[0].asFunction());
++				o->setOwnProperty(rt, constants[im], acc, ACCESSOR_FLAG);
++				pop(1);
++				break;
++			}
+ 
+ 			case PUSH_ELEMENTS_OP: {
+ 				Object* o = sp[-im].getObject();
+@@ -3123,7 +3311,11 @@ const String* Compiler::identifier(bool required, bool allowKeywords) {
+         if (!allowKeywords && findReservedKeyword(parsed.size(), parsed.begin()) >= 0) {
+                 error(SYNTAX_ERROR, "Illegal use of keyword");
+         }
+-	return newHashedString(heap, parsed.begin(), parsed.end());
++        const String* name = newHashedString(heap, parsed.begin(), parsed.end());
++        if (code->isStrict() && name->isEqualTo(EVAL_STRING)) {
++                error(SYNTAX_ERROR, "Illegal use of eval or arguments in strict code");
++        }
++        return name;
+ }
+ 
+ static UInt32 unescapedMaxLength(const Char* p, const Char* e) {
+@@ -3367,17 +3559,36 @@ Compiler::ExpressionResult Compiler::objectInitialiser() { // FIX : share stuff
+ 	
+ 	white();
+ 	while (!token("}", false)) {
++		bool handled = false;
+ 		const Char* b = p;
+ 		Value key = stringOrNumberConstant();
+ 		if (p == b) {
+-			key = identifier(false, true);
+-			if (key.equalsString(EMPTY_STRING)) {
++			const String* id = identifier(false, true);
++			if (id->isEqualTo(EMPTY_STRING)) {
+ 			error(SYNTAX_ERROR, "Expected property name");
+ 			}
++			white();
++				if ((id->isEqualTo(GET_STRING) || id->isEqualTo(SET_STRING)) && *p != ':') {
++				bool isGetter = id->isEqualTo(GET_STRING);
++				const Char* b2 = p;
++				Value accKey = stringOrNumberConstant();
++				if (p == b2) {
++				accKey = identifier(true, true);
++				}
++				white();
++				const String* funcName = accKey.toString(heap);
++				functionDefinition(funcName, funcName);
++				emitWithConstant(isGetter ? Processor::ADD_GETTER_OP : Processor::ADD_SETTER_OP, accKey);
++				handled = true;
++			} else {
++			key = id;
++			}
+ 			}
++		if (!handled) {
+ 				expectToken(":", true);
+ 				rvalueExpression(COMMA_PREC);
+ 				emitWithConstant(Processor::ADD_PROPERTY_OP, key);
++		}
+ 			if (token("}", true)) {
+ 				break;
+ 			}
+@@ -3459,8 +3670,19 @@ bool Compiler::preOperate(ExpressionResult& xr, Precedence precedence) {
+ 				case ExpressionResult::PUSHED_PRIMITIVE: emit(Processor::POP_OP, 1); /* fall through */
+ 				case ExpressionResult::NONE:
+ 				case ExpressionResult::CONSTANT: xr = ExpressionResult(ExpressionResult::CONSTANT, true); break;
+-				case ExpressionResult::LOCAL: xr = ExpressionResult(ExpressionResult::CONSTANT, false); break;
+-				case ExpressionResult::NAMED: emitWithConstant(Processor::DELETE_NAMED_OP, xr.v); xr = ExpressionResult(ExpressionResult::PUSHED_PRIMITIVE); break;
++				case ExpressionResult::LOCAL:
++					if (code->isStrict()) {
++						error(SYNTAX_ERROR, "Deleting identifier in strict code");
++					}
++					xr = ExpressionResult(ExpressionResult::CONSTANT, false);
++					break;
++				case ExpressionResult::NAMED:
++					if (code->isStrict()) {
++						error(SYNTAX_ERROR, "Deleting identifier in strict code");
++					}
++					emitWithConstant(Processor::DELETE_NAMED_OP, xr.v);
++					xr = ExpressionResult(ExpressionResult::PUSHED_PRIMITIVE);
++					break;
+ 				case ExpressionResult::PROPERTY: emit(Processor::DELETE_OP); xr = ExpressionResult(ExpressionResult::PUSHED_PRIMITIVE); break;
+ 				default: assert(0);
+ 			}
+@@ -3665,6 +3887,7 @@ bool Compiler::postOperate(ExpressionResult& xr, Precedence precedence) {
+ void Compiler::functionDefinition(const String* functionName, const String* selfName) {
+ 	assert(functionName != 0);
+ 	Code* func = new(heap) Code(heap.managed(), code->constants);
++	func->strict = code->strict;
+ 	Compiler funcCompiler(heap.roots(), func, Compiler::FOR_FUNCTION, nestCounter);
+ 	try {
+ 		p = funcCompiler.compileFunction(p, e, functionName, selfName);
+@@ -3819,6 +4042,9 @@ void Compiler::rvalueGroup() {
+ 
+ // FIX : ok, this is serious mess
+ Compiler::ExpressionResult Compiler::declareIdentifier(const String* name, bool func) {
++	if (code->isStrict() && (name->isEqualTo(EVAL_STRING) || name->isEqualTo(ARGUMENTS_STRING))) {
++		error(SYNTAX_ERROR, "Illegal use of eval or arguments in strict code");
++	}
+ 	ExpressionResult lxr(ExpressionResult::NAMED, name);
+ 	if (compilingFor != FOR_FUNCTION) {
+ 		CodeSection* previousSection = changeSection(&setupSection);
+@@ -3974,6 +4200,9 @@ void Compiler::functionStatement() {
+ }
+ 
+ void Compiler::withStatement(SemanticScope* currentScope) {
++	if (code->isStrict()) {
++		error(SYNTAX_ERROR, "\"with\" is not allowed in strict code");
++	}
+ 	rvalueGroup();
+ 	emit(Processor::WITH_SCOPE_OP);
+ 	{
+@@ -4461,6 +4690,28 @@ const Char* Compiler::compile(const Char* b, const Char* e) {
+ 	p = b;
+ 	this->e = e;
+ 	acceptInOperator = true;
++	const Char* directiveStart = p;
++	white();
++	bool foundStrict = false;
++	while (p < e && (*p == '"' || *p == '\'')) {
++		Char q = *p++;
++		const Char* litStart = p;
++		while (p < e && *p != q) { ++p; }
++		if (p >= e) { break; }
++		if (!foundStrict && p - litStart == 10 && strncmp(litStart, "use strict", 10) == 0) {
++			foundStrict = true;
++		}
++		++p;
++		white();
++		if (p < e && *p == ';') {
++			++p;
++			white();
++			continue;
++		}
++		break;
++	}
++	if (foundStrict) { code->setStrict(true); }
++	p = directiveStart;
+ 	
+ 	// FIX : not 100% necessary now because we should always start with undefined on top of stack
+ 	if (compilingFor == FOR_EVAL) {
+@@ -4496,6 +4747,7 @@ const Char* Compiler::compileFunction(const Char* b, const Char* e, const String
+ 	white();
+ 	Table& nameIndexes = code->nameIndexes;
+ 	Vector<const String*>& argumentNames = code->argumentNames;
++	bool hasDuplicateParameters = false;
+ 	while (!token(")", false)) {
+ 		if (eof()) {
+ 			error(SYNTAX_ERROR, argumentNames.size() == 0 ? "Expected ')'" : "Expected ',' or ')'");
+@@ -4507,6 +4759,15 @@ const Char* Compiler::compileFunction(const Char* b, const Char* e, const String
+ 			white();
+ 		}
+ 		const String* name = identifier(true, false);
++		if (code->isStrict() && (name->isEqualTo(EVAL_STRING) || name->isEqualTo(ARGUMENTS_STRING))) {
++			error(SYNTAX_ERROR, "Illegal use of eval or arguments in strict code");
++		}
++		for (size_t i = 0; i < argumentNames.size(); ++i) {
++			if (argumentNames[i]->isEqualTo(*name)) {
++				hasDuplicateParameters = true;
++				break;
++			}
++		}
+ 		nameIndexes.update(nameIndexes.insert(name), static_cast<Int32>(argumentNames.size()));
+ 		argumentNames.push(name);
+ 		code->bloomSet |= name->createBloomCode();
+@@ -4515,6 +4776,9 @@ const Char* Compiler::compileFunction(const Char* b, const Char* e, const String
+ 	expectToken("{", true);
+ 	compile(p, e); // FIX: ugly as it sets p and e again, although it doesn't hurt
+ 	expectToken("}", false);
++	if (code->strict && hasDuplicateParameters) {
++		error(SYNTAX_ERROR, "Duplicate parameter name not allowed in strict code");
++	}
+ 	code->name = functionName;
+ 	code->selfName = selfName;
+ 	code->source = String::concatenate(heap, String(heap.roots(), FUNCTION_SPACE, *functionName), String(heap.roots(), b, p));
+@@ -4734,11 +4998,17 @@ struct Support {
+ 		if (argc >= 2) {
+ 			Object *o = argv[0].asObject();
+ 			if (o != 0) {
+-				success = o->setOwnProperty(rt, argv[1], (argc >= 3 ? argv[2] : UNDEFINED_VALUE)
+-						, (argc >= 4 && argv[3].toBool() ? READ_ONLY_FLAG : 0)
+-						| (argc >= 5 && argv[4].toBool() ? DONT_ENUM_FLAG : 0)
+-						| (argc >= 6 && argv[5].toBool() ? DONT_DELETE_FLAG : 0)
+-						| EXISTS_FLAG);
++				Flags flags = (argc >= 4 && argv[3].toBool() ? READ_ONLY_FLAG : 0) |
++				              (argc >= 5 && argv[4].toBool() ? DONT_ENUM_FLAG : 0) |
++				              (argc >= 6 && argv[5].toBool() ? DONT_DELETE_FLAG : 0) | EXISTS_FLAG;
++				if (argc >= 7) {
++					Heap &heap = rt.getHeap();
++					Accessor *acc = new (heap)
++					    Accessor(heap.managed(), argv[6].asFunction(), (argc >= 8 ? argv[7].asFunction() : 0));
++					success = o->setOwnProperty(rt, argv[1], acc, flags | ACCESSOR_FLAG);
++				} else {
++					success = o->setOwnProperty(rt, argv[1], (argc >= 3 ? argv[2] : UNDEFINED_VALUE), flags);
++				}
+ 			}
+ 		}
+ 		return success;
+@@ -5058,21 +5328,23 @@ Var Runtime::eval(const String& expression) {
+ 	return runUntilReturn(processor);
+ }
+ 
+-Code* Runtime::compileEvalCode(const String* expression) {
+-	const Table::Bucket* bucket = evalCodeCache.lookup(expression);
++Code* Runtime::compileEvalCode(const String* expression, bool strict) {
++	const Table::Bucket* bucket = (strict ? 0 : evalCodeCache.lookup(expression));
+ 	if (bucket != 0) {
+ 		Object* o = bucket->getValue().getObject();
+ 		assert(dynamic_cast<Code*>(o) != 0);
+ 		return reinterpret_cast<Code*>(o);
+ 	} else {
+ 		Code* code = new(heap) Code(heap.managed());
++		if (strict) { code->setStrict(true); }
+ 		Compiler compiler(heap.roots(), code, Compiler::FOR_EVAL);
+ 		compiler.compile(*expression);
+-		evalCodeCache.update(evalCodeCache.insert(expression), code);
++		if (!strict) { evalCodeCache.update(evalCodeCache.insert(expression), code); }
+ 		return code;
+ 	}
+ }
+ 
++
+ Code* Runtime::compileGlobalCode(const String& source, const String* filename) {
+ 	Code* code = new(heap) Code(heap.managed());
+ 	Compiler compiler(heap.roots(), code, Compiler::FOR_GLOBAL);
+diff --git a/src/NuXJS.h b/src/NuXJS.h
+index 98904d66f..08901b336 100644
+--- a/src/NuXJS.h
++++ b/src/NuXJS.h
+@@ -447,11 +447,13 @@ const Flags READ_ONLY_FLAG = 2;
+ const Flags DONT_ENUM_FLAG = 4;
+ const Flags DONT_DELETE_FLAG = 8;
+ const Flags INDEX_TYPE_FLAG = 16;	///< internal index type, only used as an optimization for faster name -> local index lookup
++const Flags ACCESSOR_FLAG = 32;       ///< property stores accessor pair
+ const Flags STANDARD_FLAGS = EXISTS_FLAG;	///< use with setOwnProperty()
+ const Flags HIDDEN_CONST_FLAGS = READ_ONLY_FLAG | DONT_ENUM_FLAG | DONT_DELETE_FLAG | EXISTS_FLAG;
+ const Flags NONEXISTENT = 0;		///< use with getOwnProperty() to check for existence, e.g. getOwnProperty(o, k, v) != NONEXISTENT
+ const UInt32 TABLE_BUILT_IN_N = 3; ///< 1 << 3 == 8
+ 
++class Accessor;
+ /**
+ 	Table implements a hash table for storing object properties. It provides fast lookup and is used internally by JS
+ 	objects.
+@@ -538,13 +540,16 @@ class Object : public GCItem {
+ 		virtual Object* getPrototype(Runtime& rt) const;		///< Default returns the Object prototype.
+ 
+ 		virtual Flags getOwnProperty(Runtime& rt, const Value& key, Value* v) const;								///< Don't touch v if you return NONEXISTENT. Default returns NONEXISTENT.
++		virtual bool setOwnProperty(Runtime& rt, const String* key, const Value& v, Flags flags = STANDARD_FLAGS);	///< Insert a new or update an existing property. Return false if not possible (e.g. read-only property already exists). Default returns false.
+ 		virtual bool setOwnProperty(Runtime& rt, const Value& key, const Value& v, Flags flags = STANDARD_FLAGS);	///< Insert a new or update an existing property. Return false if not possible (e.g. read-only property already exists). Default returns false.
+ 		virtual bool updateOwnProperty(Runtime& rt, const Value& key, const Value& v);								///< Update existing property. Return false if it doesn't exist or can't be updated (e.g. read-only property exists). Can be overriden for optimization. (Default implementation checks existence with hasOwnProperty() first.)
+ 		virtual bool deleteOwnProperty(Runtime& rt, const Value& key);												///< Default returns false.
+ 		virtual Enumerator* getOwnPropertyEnumerator(Runtime& rt) const;											///< Default returns an empty enumerator.
+ 
+ 		Flags getProperty(Runtime& rt, const Value& key, Value* v) const; 	///< Searches prototype chain.
++		Flags getProperty(Runtime& rt, Processor& processor, const Value& key, Value* v) const;
+ 		bool setProperty(Runtime& rt, const Value& key, const Value& v); 	///< First tries updateOwnProperty(). If that fails, checks prototype chain for read-only property with the same name and returns false if found. Otherwise attempts to insert a new property with setOwnProperty() and returns its outcome.
++		bool setProperty(Runtime& rt, Processor& processor, const Value& key, const Value& v);
+ 		bool isOwnPropertyEnumerable(Runtime& rt, const Value& key) const;
+ 		bool hasOwnProperty(Runtime& rt, const Value& key) const; 			///< Checks via getOwnProperty().
+ 		bool hasProperty(Runtime& rt, const Value& key) const;				///< Checks via getProperty().
+@@ -707,6 +712,7 @@ class JSObject : public Object, public Table {
+ 		JSObject(GCList& gcList, Object* prototype);
+ 		virtual Object* getPrototype(Runtime& rt) const;
+ 		virtual Flags getOwnProperty(Runtime& rt, const Value& key, Value* v) const;
++		virtual bool setOwnProperty(Runtime& rt, const String* key, const Value& v, Flags flags = STANDARD_FLAGS);
+ 		virtual bool setOwnProperty(Runtime& rt, const Value& key, const Value& v, Flags flags = STANDARD_FLAGS);
+ 		virtual bool updateOwnProperty(Runtime& rt, const Value& key, const Value& v);
+ 		virtual bool deleteOwnProperty(Runtime& rt, const Value& key);
+@@ -742,6 +748,7 @@ template<class SUPER> class LazyJSObject : public SUPER {
+ 		typedef SUPER super;
+ 		LazyJSObject(GCList& gcList) : super(gcList), completeObject(0) { }
+ 		virtual Flags getOwnProperty(Runtime& rt, const Value& key, Value* v) const;
++		virtual bool setOwnProperty(Runtime& rt, const String* key, const Value& v, Flags flags = STANDARD_FLAGS);
+ 		virtual bool setOwnProperty(Runtime& rt, const Value& key, const Value& v, Flags flags = STANDARD_FLAGS);
+ 		virtual bool deleteOwnProperty(Runtime& rt, const Value& key);
+ 		virtual Enumerator* getOwnPropertyEnumerator(Runtime& rt) const;
+@@ -773,6 +780,7 @@ class JSArray : public LazyJSObject<Object> {
+ 		virtual Object* getPrototype(Runtime& rt) const;
+ 		// FIX : toString too?
+ 		virtual Flags getOwnProperty(Runtime& rt, const Value& key, Value* v) const;
++		virtual bool setOwnProperty(Runtime& rt, const String* key, const Value& v, Flags flags = STANDARD_FLAGS);
+ 		virtual bool setOwnProperty(Runtime& rt, const Value& key, const Value& v, Flags flags = STANDARD_FLAGS);
+ 		virtual bool updateOwnProperty(Runtime& rt, const Value& key, const Value& v);
+ 		virtual bool deleteOwnProperty(Runtime& rt, const Value& key);
+@@ -833,6 +841,8 @@ class Code : public Object {
+ 		const String* getName() const { return name; }
+ 		const String* getSource() const { return source; }
+ 		UInt32 getMaxStackDepth() const { return maxStackDepth; }
++		bool isStrict() const { return strict; }
++		void setStrict(bool v) { strict = v; }
+ 		UInt32 calcLocalsSize(UInt32 argc) const { return getVarsCount() + std::max(getArgumentsCount(), argc); }
+ 
+ 	protected:
+@@ -846,6 +856,7 @@ class Code : public Object {
+ 		const String* source;
+ 		UInt32 bloomSet;							///< Bloom bits of all local variables, arguments (+ self name and "arguments"). For faster scope resolution.
+ 		UInt32 maxStackDepth;
++		bool strict;
+ 
+ 		virtual void gcMarkReferences(Heap& heap) const {
+ 			gcMark(heap, constants);
+@@ -883,6 +894,20 @@ class Function : public Object {
+ 		Function(GCList& gcList) : super(gcList) { }
+ };
+ 
++class Accessor : public Object {
++	public:
++		Accessor(GCList& gcList, Function* g, Function* s)
++			: Object(gcList), getter(g), setter(s) { }
++		Function* getter;
++		Function* setter;
++	protected:
++		virtual void gcMarkReferences(Heap& heap) const {
++			gcMark(heap, getter);
++			gcMark(heap, setter);
++			super::gcMarkReferences(heap);
++		}
++};
++
+ typedef Value (*NativeFunction)(Runtime&, Processor&, UInt32, const Value*, Object*);
+ 
+ // FIX : overkill?
+@@ -983,6 +1008,7 @@ class Error : public LazyJSObject<Object> {
+ 		virtual const String* toString(Heap& heap) const;
+ 		virtual Value getInternalValue(Heap& heap) const; // error type name
+ 		virtual Object* getPrototype(Runtime& rt) const;
++		virtual bool setOwnProperty(Runtime& rt, const String* key, const Value& v, Flags flags = STANDARD_FLAGS);
+ 		virtual bool setOwnProperty(Runtime& rt, const Value& key, const Value& v, Flags flags = STANDARD_FLAGS);
+ 		virtual bool deleteOwnProperty(Runtime& rt, const Value& key);
+ 		ErrorType getErrorType() const;
+@@ -1007,12 +1033,14 @@ class FunctionScope;
+ class Arguments : public LazyJSObject<Object> {
+ 	public:
+ 		typedef LazyJSObject<Object> super;
++		friend class FunctionScope;
+ 
+         Arguments(GCList& gcList, const FunctionScope* scope, UInt32 argumentsCount);
+ 		virtual const String* getClassName() const;	// &A_RGUMENTS_STRING
+ 		virtual const String* toString(Heap& heap) const;
+ 		virtual Object* getPrototype(Runtime& rt) const;
+ 		virtual Flags getOwnProperty(Runtime& rt, const Value& key, Value* v) const;
++		virtual bool setOwnProperty(Runtime& rt, const String* key, const Value& v, Flags flags = STANDARD_FLAGS);
+ 		virtual bool setOwnProperty(Runtime& rt, const Value& key, const Value& v, Flags flags = STANDARD_FLAGS);
+ 		virtual bool deleteOwnProperty(Runtime& rt, const Value& key);
+ 		virtual Enumerator* getOwnPropertyEnumerator(Runtime& rt) const;
+@@ -1027,6 +1055,7 @@ class Arguments : public LazyJSObject<Object> {
+ 		UInt32 const argumentsCount;
+ 		Vector<Byte> deletedArguments;
+ 		Vector<Value> values;	// Contains copied values after the Argument has been detached from its closure.
++		FunctionScope* owner;	// Weak reference to owning FunctionScope for cleanup.
+ 
+ 		/**
+ 			Notice that we do not mark the scope reference, thus creating a "weak" reference that is handled by
+@@ -1133,7 +1162,7 @@ class Runtime : public GCItem {
+ 		JSArray* newJSArray(UInt32 initialLength = 0) const;	///< Convenience routine for `new(heap) JSArray(heap.managed(), initialLength)`
+ 		const String* newStringConstant(const char* s);
+ 
+-		Code* compileEvalCode(const String* expression);
++		Code* compileEvalCode(const String* expression, bool strict = false);
+ 		Code* compileGlobalCode(const String& source, const String* filename = 0);
+ 
+ 		Var getGlobalsVar();							///< Convenience routine for `Var(rt, rt.getGlobalObject())`
+@@ -1338,14 +1367,42 @@ class Property : public AccessorBase {
+ 	friend class AccessorBase;
+ 
+   public:
+-		template<typename T> const Property& operator=(const T& v) const { object->setProperty(rt, key, Var(rt, v)); return *this; }
+-		template<typename T> const Property& operator+=(const T& r) const { object->setProperty(rt, key, get().add(rt.getHeap(), makeValue(r))); return *this; }
++	template <typename T> const Property &operator=(const T &v) const {
++		Value current;
++		Flags flags = object->getProperty(rt, key, &current);
++		if (flags != NONEXISTENT && (flags & ACCESSOR_FLAG) != 0) {
++			Accessor *acc = static_cast<Accessor *>(current.asObject());
++			Function *setter = (acc != 0 ? acc->setter : 0);
++			if (setter != 0) {
++				Value arg = Var(rt, v);
++				rt.call(setter, 1, &arg, object);
++				return *this;
++			}
++		}
++		object->setProperty(rt, key, Var(rt, v));
++		return *this;
++	}
++	template <typename T> const Property &operator+=(const T &r) const {
++		object->setProperty(rt, key, get().add(rt.getHeap(), makeValue(r)));
++		return *this;
++	}
+ 
+   protected:
+ 	typedef AccessorBase super;
+ 	Property(Runtime &rt, Object *object, const Var &key) : super(rt), object(object), key(key) {}
+-		virtual Value get() const { Value v(UNDEFINED_VALUE); object->getProperty(rt, key, &v); return v; }
+-		virtual Var call(int argc, const Value* argv) const { return rt.call(*this, argc, argv, object); }
++	virtual Value get() const {
++		Value v(UNDEFINED_VALUE);
++		Flags flags = object->getProperty(rt, key, &v);
++		if (flags != NONEXISTENT && (flags & ACCESSOR_FLAG) != 0) {
++			Accessor *acc = static_cast<Accessor *>(v.asObject());
++			Function *getter = (acc != 0 ? acc->getter : 0);
++			return (getter != 0 ? rt.call(getter, 0, 0, object) : UNDEFINED_VALUE);
++		}
++		return v;
++	}
++	virtual Var call(int argc, const Value *argv) const {
++		return rt.call(*this, argc, argv, object);
++	}
+ 	Object *const object;
+ 	const Var key;
+ };
+@@ -1531,6 +1588,8 @@ class Processor : public GCItem {
+ 			, SET_PROPERTY_OP								// stack: object, name, value -> value
+ 			, SET_PROPERTY_POP_OP							// stack: object, name, value ->
+ 			, ADD_PROPERTY_OP								// operand: const_index (name), stack: object, value -> object
++							, ADD_GETTER_OP						// operand: const_index(name), stack: object, function -> object
++							, ADD_SETTER_OP						// operand: const_index(name), stack: object, function -> object
+ 			, PUSH_ELEMENTS_OP								// operand: count, stack: object, count * elements ... -> object
+ 			, OBJ_TO_PRIMITIVE_OP							// stack: value -> primitive_value (no preference)	// these three must be in this exact order
+ 			, OBJ_TO_NUMBER_OP								// stack: value -> primitive_value (number preferred)
+@@ -1585,7 +1644,12 @@ class Processor : public GCItem {
+ 		};
+ 	
+ 		struct OpcodeInfo {
+-			enum { TERMINAL = 1, POP_OPERAND = 2, POP_ON_BRANCH = 4, NO_POP_ON_BRANCH = 8 };
++			enum {
++				TERMINAL = 1,			/// instruction ends current basic block
++				POP_OPERAND = 2,	/// pop `operand` values after execution
++				POP_ON_BRANCH = 4,	/// branch path pops the top of stack
++				NO_POP_ON_BRANCH = 8	/// branch path keeps the top of stack
++			};
+ 			Opcode opcode;
+ 			const char* mnemonic;
+ 			Int32 stackUse;
+@@ -1600,12 +1664,13 @@ class Processor : public GCItem {
+ 		Processor(Runtime& rt);
+ 		void invokeFunction(Function* f, Int32 argc, const Value* argv, Object* thisObject = 0);
+ 		void enterGlobalCode(const Code* code);
+-		void enterEvalCode(const Code* code, bool local = false);
++		void enterEvalCode(const Code* code, bool direct = false);
+ 		void enterFunctionCode(JSFunction* func, UInt32 argc, const Value* argv, Object* thisObject = 0);
+ 		void throwVirtualException(const Value& exception);
+ 		void error(ErrorType errorType, const String* message = 0);
+ 		bool run(Int32 maxCycles);
+ 		Value getResult() const;	// make sure you've called run() until it returns false before calling this
++		bool isCurrentStrict() const { return currentFrame != 0 && currentFrame->code->isStrict(); }
+ 
+ 	protected:
+ 		struct Frame : public GCItem {
+diff --git a/src/stdlib.js b/src/stdlib.js
+index 2c8acffc9..0571ba0d2 100644
+--- a/src/stdlib.js
++++ b/src/stdlib.js
+@@ -2,24 +2,24 @@
+ 	@preserve: Array,Boolean,Date,E,Error,Function,Infinity,LN10,LN2,LOG10E,LOG2E,MAX_VALUE,MIN_VALUE,Math
+ 	@preserve: NEGATIVE_INFINITY,NaN,Number,Object,PI,POSITIVE_INFINITY,RangeError,RegExp,SQRT1_2,SQRT2,String
+ 	@preserve: SyntaxError,TypeError,UTC,abs,acos,apply,arguments,asin,atan,atan2,break,call,callWithArgs,case,ceil
+-	@preserve: charAt,charCodeAt,configurable,concat,cos,default,defineProperty,delete,do,dontDelete,dontEnum
+-	@preserve: else,enumerable,eval,exec,exp,false,finally,floor,for,fromCharCode,function,getCurrentTime
++	@preserve: charAt,charCodeAt,configurable,concat,cos,default,defineProperty,delete,do,dontDelete,dontEnum,get,set
++	@preserve: else,enumerable,eval,exec,exp,false,finally,floor,for,forEach,fromCharCode,function,getCurrentTime
+ 	@preserve: getDate,getDay,getFullYear,getHours,getInternalProperty,getMilliseconds,getMinutes,getMonth
+ 	@preserve: getPrototypeOf,getSeconds,getTime,getTimezoneOffset,getUTCDate,getUTCDay,getUTCFullYear,getUTCHours
+ 	@preserve: getUTCMilliseconds,getUTCMinutes,getUTCMonth,getUTCSeconds,hasOwnProperty,if,ignoreCase,in,index,indexOf
+-	@preserve: input,isArray,isFinite,isNaN,isPropertyEnumerable,join,lastIndex,lastIndexOf,length,localeCompare,log
+-	@preserve: match,max,maxNumber,message,min,minNumber,multiline,name,new,null,parseFloat,parseInt,pow
++        @preserve: input,isArray,isFinite,isNaN,isPropertyEnumerable,join,lastIndex,lastIndexOf,length,localeCompare,log,keys
++	@preserve: match,max,maxNumber,message,min,minNumber,multiline,name,new,now,null,parseFloat,parseInt,pow
+ 	@preserve: propertyIsEnumerable,prototype,push,readOnly,regExpCanonicalize,return,reverse,round,setDate
+ 	@preserve: setFullYear,setHours,setMilliseconds,setMinutes,setMonth,setSeconds,setTime,setUTCDate
+ 	@preserve: setUTCFullYear,setUTCHours,setUTCMilliseconds,setUTCMinutes,setUTCMonth,setUTCSeconds,shift,sin,slice
+ 	@preserve: sort,distinctConstructor,sqrt,submatch,substr,substring,switch,tan,this,throw,time,toExponential
+ 	@preserve: toFixed,toISOString,toLocaleDateString,toLocaleLowerCase,toLocaleString,toLocaleTimeString
+-	@preserve: toLocaleUpperCase,toLowerCase,toPrecision,toString,toTimeString,toUTCString,toUpperCase,true,try,typeof
++	@preserve: toLocaleUpperCase,toLowerCase,toPrecision,toString,toTimeString,toUTCString,toUpperCase,trim,trimLeft,trimRight,true,try,typeof
+ 	@preserve: undefined,upperToLower,value,valueOf,var,void,while,writable,pop,parse,toDateString,instanceof,test
+ 	@preserve: toPrimitiveNumber,toPrimitiveString,constructor,isPrototypeOf,prototypes,createWrapper,$match
+ @preserve: $sub,createRegExp,CC,global,source,JSON,stringify,toJSON,unshift,compileFunction,localTimeDifference
+ @preserve: splice,split,search,replace,random,evalFunction,updateDateValue,toPrimitive
+-
++@preserve: every,some,filter,map,reduce,reduceRight
+ support: {
+ 	prototypes: {	// built-in prototype objects
+ 	object, function, string, boolean, number, date, array
+@@ -60,19 +60,15 @@
+ 	Infinity
+ 	}
+ 	*/
+-
+ 	(function(support) {
+-
+ 	var globals = this;
+ 	var unconstructable = support.distinctConstructor; // these are the same now, but not guaranteed in the future
+-
+ 	var $isNaN = support.isNaN, $isFinite = support.isFinite, $floor = support.floor, $NaN = support.NaN
+ 	, $Infinity = support.Infinity, $match = support.submatch, $sub = support.substring // "$match" and "$sub" are used from within regexps, so names has to be preserved
+ 	, $getInternalProperty = support.getInternalProperty, $callWithArgs = support.callWithArgs
+ 	, $charCodeAt = support.charCodeAt, abs, syntaxError, rangeError, typeError
+ 	, ALPHA_DIGITS_LOWER = "0123456789abcdefghijklmnopqrstuvwxyz", ALPHA_DIGITS_UPPER = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
+ 	, WHITE_SPACES = " \f\n\r\t\v\xA0\u2028\u2029";
+-
+ 	var PARSE_INT_CHARS = (function() {
+ 	var pic = { }, ws = WHITE_SPACES;
+ 	for (var i = ws.length - 1; i >= 0; --i) {
+@@ -85,7 +81,6 @@ var PARSE_INT_CHARS = (function() {
+ 	}
+ 	return pic
+ 	})();
+-
+ 	function StringBuilder() {
+ 	var i = 20, b = this.buffers = [ ];
+ 	do { b[--i] = '' } while (i > 0)
+@@ -102,12 +97,10 @@ StringBuilder.prototype.build = function build() {
+ 	do { s += b[--i] } while (i > 0);
+ 	return s
+ 	};
+-
+ 	function isPrimitive(v) {
+ 	var v, t;
+ 	return (((t = typeof v) !== "object" || v === null) && t !== "function")
+ 	}
+-
+ 	function objectToPrimitive(o, f1, f2) {
+ 	var v;
+ 	if ((typeof (o[f1]) !== "function" || !isPrimitive(v = o[f1]()))
+@@ -116,34 +109,27 @@ function objectToPrimitive(o, f1, f2) {
+ 	}
+ 	return v
+ 	}
+-
+ 	support.toPrimitiveNumber = function(o) { return objectToPrimitive(o, "valueOf", "toString"); };
+ 	support.toPrimitiveString = function(o) { return objectToPrimitive(o, "toString", "valueOf"); };
+ 	support.toPrimitive = function(o) {
+ 	return support[$getInternalProperty(o, "class") === "Date" ? "toPrimitiveString" : "toPrimitiveNumber"](o);
+ 	};
+-
+ 	function int(v) { return $isNaN(v = +v) ? 0 : (!$isFinite(v) ? v : (v < 0 ? -$floor(-v) : $floor(v))); }
+ 	function int32(v) { return int(v) | 0; }
+ 	function uint32(v) { return int(v) >>> 0; }
+-
+ 	// TODO : what a waste of cycles, could be a simple OBJ_TO_STRING, problem with ''+s is that it uses OBJ_TO_NUMBER which only affects the priority of toString vs valueOf... so subtle!
+ 	function str(o) { return '' + (isPrimitive(o) ? o : support.toPrimitiveString(o)) }
+-
+ 	function defineProperties(object, attribs, props) {
+ 	var ro = attribs.readOnly, de = attribs.dontEnum, dd = attribs.dontDelete;
+ 	for (var p in props) support.defineProperty(object, p, props[p], ro, de, dd);
+ 	return object
+ 	}
+-
+ 	function checkClass(object, expectedClass, forFunction) {
+ 	if ($getInternalProperty(object, "class") !== expectedClass) {
+ 	throw typeError(expectedClass + ".prototype." + forFunction + " is not generic");
+ 	}
+ 	}
+-
+ 	function leftPad(s, l) { var n = (s = "00000000000000000000" + s).length; return $sub(s, n - l, n); }
+-
+ 	function numberToString(num, digits, eNotationBelow) {
+ 	var string = '';
+ 	if (num < 0) {
+@@ -187,7 +173,6 @@ function numberToString(num, digits, eNotationBelow) {
+ 	if (exponent !== null) string += (exponent >= 0 ? "e+" : 'e') + exponent;
+ 	return string
+ 	}
+-
+ 	function numberToRadix(val, radix) {
+ 	var sign = '', s = '';
+ 	if ((val = int(val)) < 0) {
+@@ -197,16 +182,13 @@ function numberToRadix(val, radix) {
+ 	do { s = ALPHA_DIGITS_LOWER[val % radix] + s } while ((val = $floor(val / radix)) > 0);
+ 	return sign + s;
+ 	}
+-
+ 	// eval without loads of local variables but with access to all internals
+ 	function evalThere(s) {
+ 	var customEval = eval;
+ 	eval = support.evalFunction; // must reassign for "direct mode" eval
+ 	try { return eval(s); } finally { eval = customEval; }
+ 	}
+-
+ 	/* --- Object --- */
+-
+ 	var Object = function Object(v) {
+ 	switch (typeof v) {
+ 	case "object":
+@@ -235,9 +217,7 @@ defineProperties(Object.prototype, { dontEnum: true }, {
+ 	return false;
+ 	})
+ 	});
+-
+ 	/* --- Function --- */
+-
+ 	var Function = function Function(body) {
+ 	var argv, src = '(', n = (argv = arguments).length - 1;
+ 	for (var i = 0; i < n; ++i) {
+@@ -267,9 +247,7 @@ defineProperties(Function.prototype, { dontEnum: true }, {
+ 	return $getInternalProperty(this, "value");
+ 	})
+ 	});
+-
+ 	/* --- Boolean --- */
+-
+ 	var Boolean = support.distinctConstructor(function Boolean(v) {
+ 	return !!v;
+ 	}, function Boolean(v) {
+@@ -287,14 +265,11 @@ defineProperties(Boolean.prototype, { dontEnum: true }, {
+ 	return '' + $getInternalProperty(this, "value");
+ 	})
+ 	});
+-
+ 	/* --- Number --- */
+-
+ 	function getInternalNumber(object, forFunction) {
+ 	checkClass(object, "Number", forFunction);
+ 	return $getInternalProperty(object, "value")
+ 	}
+-
+ 	var Number = support.distinctConstructor(function Number(v) {
+ 	return (arguments.length ? +v : 0);
+ 	}, function Number(v) {
+@@ -362,11 +337,8 @@ defineProperties(Number.prototype, { dontEnum: true }, {
+ 	}
+ 	})
+ 	});
+-
+ 	/* --- String --- */
+-
+ 	var lowerToUpper, upperToLower; // "upperToLower" is used from within regexps, so the name has to be preserved
+-
+ 	function createCaseTables() {
+ 	// In the future constant tables might be (nearly) free to setup, but as of 20160423 this is quite "expensive".
+ 	lowerToUpper = {
+@@ -405,23 +377,19 @@ function createCaseTables() {
+ 	};
+ 	for (c in BIDIRECTIONAL) lowerToUpper[upperToLower[c] = BIDIRECTIONAL[c]] = c
+ 	};
+-
+ 	function translateString(string, table) {
+ 	var i = -1, len = string.length, s = '', t, c;
+ 	while (++i < len) s += (t = table[c = string[i]]) ? t : c;
+ 	return s
+ 	}
+-
+ 	function toLower(o) {
+ 	if (!lowerToUpper) createCaseTables();
+ 	return translateString(str(o), upperToLower);
+ 	}
+-
+ 	function toUpper(o) {
+ 	if (!lowerToUpper) createCaseTables();
+ 	return translateString(str(o), lowerToUpper);
+ 	}
+-
+ 	var String = support.distinctConstructor(function String(v) {
+ 	return (arguments.length ? str(v) : '');
+ 	}, function String(v) {
+@@ -589,6 +557,34 @@ defineProperties(String.prototype, { dontEnum: true }, {
+ 	toLocaleUpperCase: unconstructable(function toLocaleUpperCase() { return toUpper(this) }),
+ 	toLowerCase: unconstructable(function toLowerCase() { return toLower(this) }),
+ 	toLocaleLowerCase: unconstructable(function toLocaleLowerCase() { return toLower(this) }),
++	trimLeft: unconstructable(function trimLeft() {
++	var s = str(this), i = 0, j = s.length, c;
++	for (; i < j; ++i) {
++	c = s.charCodeAt(i);
++	if (c !== 0x20 && (c < 0x09 || c > 0x0D) && c !== 0xA0 && c !== 0x2028 && c !== 0x2029 && c !== 0xFEFF) break;
++	}
++	return $sub(s, i, j);
++	}),
++	trimRight: unconstructable(function trimRight() {
++	var s = str(this), j = s.length, c;
++	for (; j > 0; --j) {
++	c = s.charCodeAt(j - 1);
++	if (c !== 0x20 && (c < 0x09 || c > 0x0D) && c !== 0xA0 && c !== 0x2028 && c !== 0x2029 && c !== 0xFEFF) break;
++	}
++	return $sub(s, 0, j);
++	}),
++	trim: unconstructable(function trim() {
++	var s = str(this), i = 0, j = s.length, c;
++	for (; i < j; ++i) {
++	c = s.charCodeAt(i);
++	if (c !== 0x20 && (c < 0x09 || c > 0x0D) && c !== 0xA0 && c !== 0x2028 && c !== 0x2029 && c !== 0xFEFF) break;
++	}
++	for (; j > i; --j) {
++	c = s.charCodeAt(j - 1);
++	if (c !== 0x20 && (c < 0x09 || c > 0x0D) && c !== 0xA0 && c !== 0x2028 && c !== 0x2029 && c !== 0xFEFF) break;
++	}
++	return $sub(s, i, j);
++	}),
+ 	valueOf: unconstructable(function valueOf() {
+ 	checkClass(this, "String", "valueOf");
+ 	return $getInternalProperty(this, "value");
+@@ -598,9 +594,7 @@ defineProperties(String.prototype, { dontEnum: true }, {
+ 	return $getInternalProperty(this, "value");
+ 	})
+ 	});
+-
+ 	/* --- Array --- */
+-
+ 	var Array = function Array(v) {
+ 	var a = [ ], argv, argc;
+ 	if ((argc = (argv = arguments).length) === 1 && typeof v === "number") {
+@@ -764,11 +758,75 @@ defineProperties(Array.prototype, { dontEnum: true }, {
+ }
+ for (var i = 0; i < n; ++i) this[i] = argv[i];
+ return (this.length = len + n);
++	}),
++	forEach: unconstructable(function forEach(callbackfn) { // .length should be 1
++	var o = Object(this), len = uint32(o.length), t = arguments[1];
++	if (typeof callbackfn !== "function") throw TypeError();
++	for (var k = 0; k < len; ++k) if (k in o) callbackfn.call(t, o[k], k, o);
++	}),
++	map: unconstructable(function map(callbackfn) { // .length should be 1
++	var o = Object(this), len = uint32(o.length), t = arguments[1], a = new Array(len);
++	if (typeof callbackfn !== "function") throw TypeError();
++	for (var k = 0; k < len; ++k) if (k in o) a[k] = callbackfn.call(t, o[k], k, o);
++	return a;
++	}),
++	filter: unconstructable(function filter(callbackfn) { // .length should be 1
++	var o = Object(this), len = uint32(o.length), t = arguments[1], a = [], to = 0;
++	if (typeof callbackfn !== "function") throw TypeError();
++	for (var k = 0; k < len; ++k) if (k in o) { var v = o[k]; if (callbackfn.call(t, v, k, o)) a[to++] = v; }
++	a.length = to;
++	return a;
++	}),
++	indexOf: unconstructable(function indexOf(searchElement) {
++	var len = uint32(this.length), i = arguments[1];
++	if (len === 0) return -1;
++	if ((i = int(i)) < 0) { i += len; if (i < 0) i = 0; }
++	for (; i < len; ++i) if (i in this && this[i] === searchElement) return i;
++	return -1;
++	}),
++lastIndexOf: unconstructable(function lastIndexOf(searchElement) {
++var len = uint32(this.length), i = arguments[1];
++if (len === 0) return -1;
++if (i === void 0) i = len - 1; else { i = int(i); if (i < 0) i += len; if (i >= len) i = len - 1; }
++for (; i >= 0; --i) if (i in this && this[i] === searchElement) return i;
++return -1;
++}),
++	reduce: unconstructable(function reduce(callbackfn) { // .length should be 1
++	var o = Object(this), len = uint32(o.length), k = 0, acc;
++	if (typeof callbackfn !== "function") throw TypeError();
++	if (arguments.length > 1) acc = arguments[1]; else {
++	while (k < len && !(k in o)) ++k;
++	if (k >= len) throw TypeError();
++	acc = o[k++];
++	}
++	for (; k < len; ++k) if (k in o) acc = callbackfn.call(void 0, acc, o[k], k, o);
++	return acc;
++	}),
++	reduceRight: unconstructable(function reduceRight(callbackfn) { // .length should be 1
++	var o = Object(this), len = uint32(o.length), k = len - 1, acc;
++	if (typeof callbackfn !== "function") throw TypeError();
++	if (arguments.length > 1) acc = arguments[1]; else {
++	while (k >= 0 && !(k in o)) --k;
++	if (k < 0) throw TypeError();
++	acc = o[k--];
++	}
++	for (; k >= 0; --k) if (k in o) acc = callbackfn.call(void 0, acc, o[k], k, o);
++	return acc;
++	}),
++	every: unconstructable(function every(callbackfn) { // .length should be 1
++	var o = Object(this), len = uint32(o.length), t = arguments[1];
++	if (typeof callbackfn !== "function") throw TypeError();
++	for (var k = 0; k < len; ++k) if (k in o && !callbackfn.call(t, o[k], k, o)) return false;
++	return true;
++	}),
++	some: unconstructable(function some(callbackfn) { // .length should be 1
++	var o = Object(this), len = uint32(o.length), t = arguments[1];
++	if (typeof callbackfn !== "function") throw TypeError();
++	for (var k = 0; k < len; ++k) if (k in o && callbackfn.call(t, o[k], k, o)) return true;
++	return false;
+ 	})
+ });
+-
+ 	/* --- Date --- */
+-
+ 	function localMaxDiff() { // local max is during DST
+ 	var startOfYearDiff = support.localTimeDifference(14516064e5); // 2016-01-01T00:00:00.000Z
+ 	var midOfYearDiff = support.localTimeDifference(14673312e5); // 2016-07-01T00:00:00.000Z
+@@ -781,18 +839,15 @@ function localMinDiff() { // local min is timezone (non DST)
+ 	}
+ 	function localTimeDiff(z) { var l = support.localTimeDifference(z); return ($isNaN(l) ? localMinDiff() : l) }
+ 	function toLocalTime(z) { return $isNaN(z) ? z : z + localTimeDiff(z) }
+-
+ 	function checkDateClass(object) {
+ 	if ($getInternalProperty(object, "class") !== "Date") throw typeError("this is not a Date object");
+ 	}
+-
+ 	function getDateValue(object) { checkDateClass(object); return $getInternalProperty(object, "value"); }
+ 	function getLocalDateValue(object) { return toLocalTime(getDateValue(object)); }
+ 	function setDateValue(object, v) { checkDateClass(object); support.updateDateValue(object, v); return v; }
+ 	function localDateTimeToString(v) {
+ 	return $isNaN(v = toLocalTime(v)) ? "Invalid Date" : (epochToDateString(v) + ' ' + epochToTimeString(v));
+ 	}
+-
+ 	function floorMod(x, n) { return (x % n + n) % n }
+ 	function epochFromTime(hour, minute, second, ms) { return hour * 36e5 + minute * 6e4 + second * 1e3 + ms }
+ 	function timeFromEpoch(z) { return [ floorMod($floor(z / 36e5), 24), floorMod($floor(z / 6e4), 60), floorMod($floor(z / 1e3), 60), floorMod(z, 1e3) ] }
+@@ -804,7 +859,6 @@ function secFromTime(z) { return floorMod($floor(z / 1e3), 60) }
+ 	function msFromTime(z) { return floorMod(z, 1e3) }
+ 	function timeClip(z) { return (!$isFinite(z) || abs(z) > 8.64e15 ? $NaN : int(z)) }
+ 	function timeClipLocal(z) { return fromLocalTime(timeClip(z)); }
+-
+ 	function dateFromEpoch(z) {
+ 	z = $floor(z / 864e5) + 719468;
+ 	var era = int( (z >= 0 ? z : z - 146096) / 146097 );
+@@ -817,19 +871,16 @@ function dateFromEpoch(z) {
+ 	var d = doy - int( (153 * mp + 2) / 5 ) + 1;
+ 	return [ (y + (m <= 1)), m, d ];
+ 	}
+-
+ 	function epochToDateString(z) {
+ 	var y, dt = dateFromEpoch(z);
+ 	return (0 <= (y = dt[0]) && y <= 9999 ? leftPad(y, 4) : (y < 0 ? "-" : "+") + leftPad(abs(y), 6))
+ 	+ "-" + leftPad(dt[1] + 1, 2) + "-" + leftPad(dt[2], 2);
+ 	}
+-
+ 	function epochToTimeString(z, ms) {
+ 	var tm = timeFromEpoch(z);
+ 	return leftPad(tm[0], 2) + ":" + leftPad(tm[1], 2) + ":" + leftPad(tm[2], 2)
+ 	+ (ms ? "." + leftPad($sub(tm[3], 0, 3), 3) : "")
+ 	}
+-
+ 	function epochFromDate(year, month, day) {
+ 	year += $floor(month / 12) - (floorMod(month, 12) <= 1);
+ 	var era = int( (year >= 0 ? year : year - 399) / 400 );
+@@ -838,31 +889,26 @@ function epochFromDate(year, month, day) {
+ 	var doe = yoe * 365 + int(yoe / 4) - int(yoe / 100) + doy;
+ 	return (era * 146097 + doe - 719468) * 864e5;
+ 	}
+-
+ 	function setDateParts(z, n, a) {
+ 	var i, d = dateFromEpoch(z), r = floorMod(z, 864e5);
+ 	for (i = 0; i < a.length; ++i, ++n) d[n] = int(a[i]);
+ 	return $callWithArgs(epochFromDate, null, d) + r;
+ 	}
+-
+ 	function setTimeParts(z, n, a) {
+ 	var i, t = timeFromEpoch(z), r = $floor(z / 864e5) * 864e5;
+ 	for (i = 0; i < a.length; ++i, ++n) t[n] = int(a[i]);
+ 	return $callWithArgs(epochFromTime, null, t) + r;
+ 	}
+-
+ 	function makeDateTime(year, month, date, hours, minutes, seconds, ms) {
+ 	var argc = arguments.length;
+ 	return epochFromDate( (year = int(year)) + (0 <= year && year <= 99 ? 1900 : 0),
+ 	int(month), (argc > 2 ? int(date) : 1)) + epochFromTime( argc > 3 ? int(hours) : 0,
+ 	argc > 4 ? int(minutes) : 0, argc > 5 ? int(seconds) : 0, argc > 6 ? int(ms) : 0);
+ 	}
+-
+ 	function isoDate(d) {
+ 	var z;
+ 	return $isNaN(z = getDateValue(d)) ? null : epochToDateString(z) + "T" + epochToTimeString(z, true) + "Z";
+ 	}
+-
+ 	var parseDate, Date = support.distinctConstructor(function Date() {
+ 	return localDateTimeToString(support.getCurrentTime());
+ 	}, function Date(year, month, date, hours, minutes, seconds, ms) {
+@@ -872,7 +918,6 @@ var parseDate, Date = support.distinctConstructor(function Date() {
+ 	else v = support.getCurrentTime();
+ 	return support.createWrapper("Date", v, support.prototypes.Date);
+ 	});
+-
+ 	defineProperties(Date, { dontEnum: true, readOnly: true, dontDelete: true }, { prototype: support.prototypes.Date });
+ 	defineProperties(Date, { dontEnum: true }, {
+ 	parse: unconstructable(parseDate = function parse(s) {
+@@ -891,9 +936,7 @@ defineProperties(Date, { dontEnum: true }, {
+ 	s[i] === ":" && (++i, readPart(2)) || 0,
+ 	s[i] === ":" && (++i, readPart(2)) || 0,
+ 	s[i] === "." && (++i, readPart(3)) || 0);
+-
+ 	while ((ch = s[i]) !== void 0 && ch !== "Z" && ch !== "z" && ch !== "+" && ch !== "-") ++i;
+-
+ 	if (ch === "Z" || ch === "z") tz = 0;
+ 	else if (ch === "+" || ch === "-") {
+ 	++i, tzh = readPart(2) * 36e5,
+@@ -904,9 +947,11 @@ defineProperties(Date, { dontEnum: true }, {
+ 	}),
+ 	UTC: unconstructable(function UTC(year, month, date, hours, minutes, seconds, ms) {
+ 		return timeClip(makeDateTime(year, month, date, hours, minutes, seconds, ms))
++	}),
++	now: unconstructable(function now() {
++		return support.getCurrentTime();
+ 	})
+ 	});
+-
+ 	defineProperties(Date.prototype, { dontEnum: true }, {
+ 	constructor: Date,
+ 	toISOString: unconstructable(function toISOString() {
+@@ -970,9 +1015,7 @@ defineProperties(Date.prototype, { dontEnum: true }, {
+ 	// TODO: this isn't as generic as in the ES5 spec, e.g. not converting this to object, not going via the objects reassignable `toISOString`.
+ 	toJSON: unconstructable(function toJSON() { return isoDate(this); })
+ 	});
+-
+ 	/* --- RegExp --- */
+-
+ 	var v = 1;
+ 	var EMPTY_CHAR = v, NEWLINE_CHAR = (v <<= 1), SPACE_CHAR = (v <<= 1), WORD_CHAR = (v <<= 1), DECIMAL_CHAR = (v <<= 1)
+ 	, LETTER_CHAR = (v <<= 1), HEX_CHAR = (v <<= 1), ESCAPE_CHAR = (v <<= 1), SPECIAL_CHAR = (v <<= 1)
+@@ -980,7 +1023,6 @@ var EMPTY_CHAR = v, NEWLINE_CHAR = (v <<= 1), SPACE_CHAR = (v <<= 1), WORD_CHAR
+ 	var CC = { }; // "CC" is used from within regexps, so the name has to be preserved
+ 	(function() {
+ 	function setupCharClass(mask, chars) { for (var i in chars) CC[chars[i]] |= mask }
+-
+ 	setupCharClass(SPECIAL_CHAR, "^$.*+?()[]{}|");
+ 	setupCharClass(DECIMAL_CHAR | HEX_CHAR | WORD_CHAR, "0123456789");
+ 	setupCharClass(HEX_CHAR | LETTER_CHAR | WORD_CHAR, "abcdefABCDEF");
+@@ -1000,7 +1042,6 @@ var CC = { }; // "CC" is used from within regexps, so the name has to be preserv
+ 	for (var j = IDENTITY_ESCAPE_RANGES[i], k = IDENTITY_ESCAPE_RANGES[i + 1]; j < k; ++j)
+ 	CC[support.fromCharCode(j)] |= IDENTITY_ESCAPE_CHAR;
+ 	})();
+-
+ 	// "regExpCanonicalize" is used from within regexps, so the name has to be preserved
+ 	function regExpCanonicalize(s) {
+ 	var t = '', c, d;
+@@ -1009,25 +1050,20 @@ function regExpCanonicalize(s) {
+ 	t += ((d = lowerToUpper[c = s[i]]) && d.length === 1 && (c < '\x80' || d >= '\x80') ? d : c);
+ 	return t
+ 	}
+-
+ 	// FIX : all charCodeAt etc need to be stowed away so that we won't destroy regexp if changing global objects. This is true for all the code in here actually.
+ 	function compileRegExp(s, caseInsensitive, multiLine) {
+ 	var p = 0, functions = '', functionCounter = 0, captureCounter = 0, closureVars = '', maxBackReference = 0;
+-
+ 	function isClass(char, mask) { return ((CC[char] & mask) !== 0); }
+-
+ 	function areClass(s, mask) { // FIX : only used once
+ 	for (var i = s.length - 1; i >= 0; --i) if ((CC[s[i]] & mask) === 0) return false;
+ 	return true;
+ 	}
+-
+ 	var CHAR_CLASS_RULES = {
+ 	'D': [ DECIMAL_CHAR, true ], 'd': [ DECIMAL_CHAR, false ],
+ 	'S': [ SPACE_CHAR, true ], 's': [ SPACE_CHAR, false ],
+ 	'W': [ WORD_CHAR, true ], 'w': [ WORD_CHAR, false ],
+ 	'.': [ NEWLINE_CHAR, true ]
+ 	};
+-
+ 	function parseNumber(defaultValue) {
+ 	var n = defaultValue;
+ 	if (isClass(s[p], DECIMAL_CHAR)) {
+@@ -1039,7 +1075,6 @@ function compileRegExp(s, caseInsensitive, multiLine) {
+ 	}
+ 	return n;
+ 	}
+-
+ 	function parseQuantifier() {
+ 	var mini = 0, maxi = $Infinity, greedy = true;
+ 	switch (s[p]) {
+@@ -1075,17 +1110,14 @@ function compileRegExp(s, caseInsensitive, multiLine) {
+ 	}
+ 	return { mini: mini, maxi: maxi, greedy: greedy };
+ 	}
+-
+ 	function escapeCharacter(c) {
+ 	if (isClass(c, OK_IN_STRING_LITERAL)) return c;
+ 	// TODO : shorter escapes for \n etc
+ 	return (c <= '~' ? "\\x" : "\\u") + leftPad(numberToRadix($charCodeAt(c, 0), 16), (c <= '~' ? 2 : 4));
+ 	}
+-
+ 	function canonicalizeAndEscape(c) {
+ 	return escapeCharacter(caseInsensitive ? regExpCanonicalize(c) : c);
+ 	}
+-
+ 	function parseLiteralCharacter() {
+ 	var c0, c1, sub;
+ 	if ((c0 = s[p]) === '\\') {
+@@ -1129,14 +1161,12 @@ function compileRegExp(s, caseInsensitive, multiLine) {
+ 	return c0;
+ 	}
+ 	}
+-
+ 	function parseLiteralSequence() {
+ 	var literalSequence = [ ], v, n = 0;
+ 	while (!isClass(s[p], SPECIAL_CHAR) && (v = parseLiteralCharacter()))
+ 	literalSequence[n++] = canonicalizeAndEscape(v);
+ 	return (literalSequence.length ? literalSequence : null);
+ 	}
+-
+ 	function parseClassAtom() {
+ 	var v, rule, c;
+ 	if ((c = s[p]) !== ']' && (v = parseLiteralCharacter())) return v;
+@@ -1151,9 +1181,7 @@ function compileRegExp(s, caseInsensitive, multiLine) {
+ 	}
+ 	}
+ 	}
+-	
+ 	function positionToCode(offset) { return (offset === 0 ? 'p' : ((offset < 0 ? 'p' : 'p+') + offset)); }
+-
+ 	function literalSequenceToCode(literalSequence, offset) {
+ 	if (literalSequence.length === 0) return "true";
+ 	else if (literalSequence.length === 1)
+@@ -1166,7 +1194,6 @@ function compileRegExp(s, caseInsensitive, multiLine) {
+ 	return "$match(s," + positionToCode(offset) + ',"' + s + '")';
+ 	}
+ 	}
+-
+ 	function and(a, b) {
+ 	switch (a) {
+ 	case "false": return "false";
+@@ -1174,7 +1201,6 @@ function compileRegExp(s, caseInsensitive, multiLine) {
+ 	default: return (b === "true" ? a : a + " && " + b);
+ 	}
+ 	}
+-
+ 	function or(a, b) {
+ 	switch (a) {
+ 	case "false": return b;
+@@ -1182,12 +1208,10 @@ function compileRegExp(s, caseInsensitive, multiLine) {
+ 	default: return (b === "false" ? a : a + " || " + b);
+ 	}
+ 	}
+-	
+ 	function addFunction(name, definition) {
+ 	// TODO : sometimes functions are identical (e.g. class-tests), reuse here or in '[' parsing directly?
+ 	functions += "\tfunction " + name + "(p) { " + definition + " }\n";
+ 	}
+-
+ 	function quantify(code, offset, repeatCode, tail, quantity, stepSize) {
+ 	// TODO : eliminate unnecessary b=p+0,e=p+Infinity and stuff
+ 	var functionName = 'q' + (++functionCounter)
+@@ -1206,7 +1230,6 @@ function compileRegExp(s, caseInsensitive, multiLine) {
+ 	}
+ 	return and(code, functionName + "(" + positionToCode(offset) + ")");
+ 	}
+-	
+ 	function captureWrap(code, capture, resetCaptureFrom, resetCaptureTo) {
+ 	if (capture === null && resetCaptureFrom === resetCaptureTo) {
+ 	return "return " + code;
+@@ -1239,11 +1262,9 @@ function compileRegExp(s, caseInsensitive, multiLine) {
+ 	return "var " + declares + "; return " + code;
+ 	}
+ 	}
+-
+ 	function charClassToCode(ch, rule) {
+ 	return (rule[1] ? '!' : "!!") + "(CC[" + ch + "]&" + (rule[0] | (rule[1] ? EMPTY_CHAR : 0)) + ')';
+ 	}
+-
+ 	function compileTerms(offset, junction) {
+ 	var literalSequence, quantity, code = "true";
+ 	termLoop: for (;;) {
+@@ -1436,7 +1457,6 @@ function compileRegExp(s, caseInsensitive, multiLine) {
+ 	default: return and(code, junction + '(' + positionToCode(offset) + ')');
+ 	}
+ 	}
+-
+ 	function compileDisjunction(offset, junction) { // junction = function name, undefined (for none for lookahead) or '' (for end of pattern)
+ 	var code = compileTerms(offset, junction);
+ 	if (s[p] === '|') {
+@@ -1448,7 +1468,6 @@ function compileRegExp(s, caseInsensitive, multiLine) {
+ 	}
+ 	return code;
+ 	}
+-
+ 	var disjunction = compileDisjunction(0, ''); 
+ 	if (p < s.length) throw syntaxError("Invalid regular expression");
+ 	if (maxBackReference > captureCounter) throw syntaxError("Invalid back reference in regular expression");
+@@ -1460,9 +1479,7 @@ function compileRegExp(s, caseInsensitive, multiLine) {
+ 	code += "];\n})";
+ 	return code
+ 	}
+-
+ 	var REG_EXP_FLAG_TO_PROPERTY = { 'g': "global", 'i': "ignoreCase", 'm': "multiline" }, regExpCache = { }, regExpPrototype;
+-
+ 	function execRegExp(re, string) {
+ 	string = str(string);
+ 	var i;
+@@ -1476,7 +1493,6 @@ function execRegExp(re, string) {
+ 	}
+ 	re.lastIndex = 0
+ 	}
+-
+ 	function regExpExecMethod(re, string) {
+ 	var m, a = null;
+ 	if (m = execRegExp(re, string)) {
+@@ -1487,9 +1503,7 @@ function regExpExecMethod(re, string) {
+ 	}
+ 	return a;
+ 	}
+-
+ 	function convertFlagsToText(re) { return (re.global ? 'g' : '') + (re.ignoreCase ? 'i' : '') + (re.multiline ? 'm' : ''); }
+-
+ 	var RegExp = support.distinctConstructor(function RegExp(pattern, flags) {
+ 	return ($getInternalProperty(pattern, "class") === "RegExp" && flags === void 0 ? pattern : new support.createRegExp(pattern, flags));
+ 	}, support.createRegExp = function RegExp(pattern, flags) {
+@@ -1498,7 +1512,6 @@ var RegExp = support.distinctConstructor(function RegExp(pattern, flags) {
+ 	flags = convertFlagsToText(pattern);
+ 	pattern = pattern.source;
+ 	}
+-	
+ 	// TODO : short-cut most of this through cache instead of only the func def.
+ 	// TODO : limit number of entries in cache
+ 	pattern = (pattern === void 0 ? '' : str(pattern));
+@@ -1518,7 +1531,6 @@ var RegExp = support.distinctConstructor(function RegExp(pattern, flags) {
+ 	defineProperties(re, { dontEnum: true, dontDelete: true }, { lastIndex: 0 });
+ 	return re;
+ 	});
+-
+ 	defineProperties(RegExp, { dontEnum: true, readOnly: true, dontDelete: true }, { prototype: regExpPrototype = RegExp.prototype });
+ 	defineProperties(RegExp.prototype, { dontEnum: true }, {
+ 	exec: unconstructable(function exec(string) { checkClass(this, "RegExp", "exec"); return regExpExecMethod(this, string); }),
+@@ -1528,9 +1540,7 @@ defineProperties(RegExp.prototype, { dontEnum: true }, {
+ 	return '/' + this.source + '/' + convertFlagsToText(this);
+ 	})
+ 	});
+-
+ 	/* --- Set up globals --- */
+-
+ 	defineProperties(globals, { dontEnum: true }, {
+ 	Array: Array,
+ 	Boolean: Boolean,
+@@ -1565,13 +1575,10 @@ defineProperties(globals, { dontEnum: true }, {
+ 	return (b === i ? $NaN : v * sign);
+ 	})
+ 	});
+-
+ 	defineProperties(globals, { dontEnum: true, dontDelete: true }, {
+ 	NaN: $NaN, Infinity: $Infinity, undefined: support.undefined
+ 	});
+-
+ 	/* --- Math --- */
+-
+ 	defineProperties(Math, { readOnly: true, dontEnum: true, dontDelete: true }, {
+ 	E: 2.718281828459045235360,
+ 	LN10: 2.302585092994045684018,
+@@ -1582,7 +1589,6 @@ defineProperties(Math, { readOnly: true, dontEnum: true, dontDelete: true }, {
+ 	SQRT1_2: 0.7071067811865475244008,
+ 	SQRT2: 1.414213562373095048802
+ 	});
+-
+ 	defineProperties(Math, { dontEnum: true }, {
+ 	abs: unconstructable(abs = function abs(v) { return ((v = +v) < 0 ? -v : v) }),
+ 	acos: unconstructable(function acos(v) { return support.acos(+v) }),
+@@ -1603,9 +1609,7 @@ defineProperties(Math, { dontEnum: true }, {
+ 	sqrt: unconstructable(function sqrt(v) { return support.sqrt(+v) }),
+ 	tan: unconstructable(function tan(v) { return support.tan(+v) })
+ 	});
+-
+ 	/* --- Errors --- */
+-
+ 	function createErrorConstructor(name, prototype) {
+ 	return function(message) {
+ 	var e;
+@@ -1614,10 +1618,8 @@ function createErrorConstructor(name, prototype) {
+ 	return e
+ 	}
+ 	};
+-
+ 	(function() {
+ 	var ERROR_NAMES = [ "Error", "EvalError", "RangeError", "ReferenceError", "SyntaxError", "TypeError", "URIError" ];
+-
+ 	for (var i = ERROR_NAMES.length; --i >= 0;) {
+ 	var n, c, p;
+ 	support.defineProperty(globals, n = ERROR_NAMES[i], c = createErrorConstructor(n, p = support.prototypes[n])
+@@ -1627,43 +1629,34 @@ function createErrorConstructor(name, prototype) {
+ 	defineProperties(p, { dontEnum: true }, { constructor: c });
+ 	p.name = n;
+ 	}
+-
+ 	defineProperties(Error.prototype, { dontEnum: true }, {
+ 	message: '',
+ 	toString: unconstructable(function toString() {
+ 	return (this.name === void 0 ? "Error" : this.name) + (this.message ? (": " + this.message) : '');
+ 	})
+ 	});
+-
+ 	syntaxError = SyntaxError;
+ 	rangeError = RangeError;
+ 	typeError = TypeError;
+ 	})();
+-
+ 	/* --- ES >3 polyfills --- */
+-
+ 	// These are not guaranteed to be 100% compatible
+-
+ 	var JSON_ESCAPE_SEQUENCES = { '\\': "\\\\", '"': "\\\"", '\b': "\\b", '\f': "\\f", '\n': "\\n", '\r': "\\r", '\t': "\\t" };
+ 	var MAX_JSON_DEPTH = 61;	// compiler internal recursion limit is 64 (as of 20180610), we must stick under this for eval() to work and 61 gives us enough margin
+-
+ 	// TODO : use StringBuilder?
+ 	defineProperties(JSON, { dontEnum: true }, {
+ 	stringify: unconstructable(function stringify(val, replacer, space) {
+ 	var stack = [ ], replacerFunction = (typeof replacer === "function" ? replacer : null), gap = '', includeProps;
+-
+ 	if ($getInternalProperty(replacer, "class") === "Array") {
+ 	includeProps = { };
+ 	for (var i = replacer.length; --i >= 0;) includeProps[replacer[i]] = true;
+ 	}
+-
+ 	if (typeof space === "number" || (typeof space === "object" && $getInternalProperty(space, "class") === "Number")) {
+ 	space = +space;
+ 	for (var i = (space > 10 ? 10 : space); --i >= 0;) gap += ' ';
+ 	} else if (typeof space === "string" || (typeof space === "object" && $getInternalProperty(space, "class") === "String")) {
+ 	gap = $sub(str(space), 0, 10);
+ 	}
+-
+ 	function quote(s) {
+ 	var t = '"', len = s.length;
+ 	for (var i = 0; i < len; ++i) {
+@@ -1674,12 +1667,10 @@ defineProperties(JSON, { dontEnum: true }, {
+ 	}
+ 	return t + '"';
+ 	}
+-
+ 	function string(key, holder, indent) {
+ 	var val;
+ 	if ((val = holder[key]) && typeof val === "object" && typeof val.toJSON === "function") val = val.toJSON(key);
+ 	if (replacerFunction) val = $callWithArgs(replacerFunction, holder, [ key, val ]);
+-
+ 	var lineEnd = (gap ? '\n' + indent : '');
+ 	if (typeof val === "object") {
+ 	switch ($getInternalProperty(val, "class")) {
+@@ -1719,7 +1710,6 @@ defineProperties(JSON, { dontEnum: true }, {
+ 	--stack.length;
+ 	return s.build();
+ 	}
+-
+ 	case "string": return quote(val);
+ 	case "number": return ($isFinite(val) ? str(val) : "null");
+ 	case "boolean": return str(val);
+@@ -1727,7 +1717,6 @@ defineProperties(JSON, { dontEnum: true }, {
+ 	}
+ 	return string('', { '': val }, '');
+ 	}),
+-
+ 	parse: unconstructable(function parse(text, reviver) {
+ 	var nest = 0;
+ 	function space(t, p) {
+@@ -1831,18 +1820,40 @@ defineProperties(JSON, { dontEnum: true }, {
+ 	throw syntaxError("Error parsing JSON");
+ 	})
+ 	});
+-
+ 	defineProperties(Array, { dontEnum: true }, {
+ 	isArray: unconstructable(function isArray(o) { return $getInternalProperty(o, "class") === "Array"; })
+ 	});
+-
+ 	defineProperties(Object, {dontEnum : true}, {
+ 	defineProperty : unconstructable(function defineProperty(o, p, d) {
+-		support.defineProperty(o, str(p), d.value, !d.writable, !d.enumerable, !d.configurable);
++	var k = str(p);
++	var ro = !d.writable, de = !d.enumerable, dd = !d.configurable;
++	if ("get" in d || "set" in d) {
++	if ("value" in d || "writable" in d)
++	throw TypeError();
++	var g = d.get;
++	var s = d.set;
++	if (g !== undefined && typeof g !== "function")
++	throw TypeError();
++	if (s !== undefined && typeof s !== "function")
++	throw TypeError();
++	support.defineProperty(o, k, undefined, ro, de, dd, g, s);
++	} else {
++	support.defineProperty(o, k, d.value, ro, de, dd);
++	}
++	}),
++	getPrototypeOf : unconstructable(function getPrototypeOf(o) {
++	return $getInternalProperty(o, "prototype");
+ 	}),
+-	getPrototypeOf: unconstructable(function getPrototypeOf(o) { return $getInternalProperty(o, "prototype"); })
++	keys : unconstructable(function keys(o) {
++	if (o === undefined || o === null) throw TypeError();
++	var obj = Object(o);
++	var res = [];
++	var k;
++	for (k in obj) {
++		if (Object.prototype.hasOwnProperty.call(obj, k)) res[res.length] = k;
++	}
++	return res;
++	})
+ 	});
+-
+ 	if ($NaN.toString() !== "NaN") throw Error("Internal self test failed. Check C++ compiler options concerning IEEE 754 compliance.");
+-
+ 	})
+diff --git a/src/stdlibES5.js b/src/stdlibES5.js
+new file mode 100644
+index 000000000..b4df0abcc
+--- /dev/null
++++ b/src/stdlibES5.js
+@@ -0,0 +1,24 @@
++/*
++ES5 additions to the standard library.
++This file is appended to stdlib.js by tools/stdlibToCpp.pika.
++
++@preserve: indexOf,lastIndexOf,Q
++*/
++
++Q(Array.prototype, {
++indexOf: unconstructable(function indexOf(searchElement) {
++var len = uint32(this.length), i = arguments[1];
++if (len === 0) return -1;
++if ((i = int(i)) < 0) { i += len; if (i < 0) i = 0; }
++for (; i < len; ++i) if (i in this && this[i] === searchElement) return i;
++return -1;
++}),
++lastIndexOf: unconstructable(function lastIndexOf(searchElement) {
++var len = uint32(this.length), i = arguments[1];
++if (len === 0) return -1;
++if (i === void 0) i = len - 1; else { i = int(i); if (i < 0) i += len; if (i >= len) i = len - 1; }
++for (; i >= 0; --i) if (i in this && this[i] === searchElement) return i;
++return -1;
++})
++});
++
+diff --git a/src/stdlibJS.cpp b/src/stdlibJS.cpp
+index 8754846d4..faef14492 100644
+--- a/src/stdlibJS.cpp
++++ b/src/stdlibJS.cpp
+@@ -252,240 +252,269 @@ const char* STDLIB_JS =
+ "aX;return $sub(B,aX,(length===void 0?h:aX+M(length)))}),substring:c(function substring(aX,aY){aX=M(aX);if(aY===void 0)"
+ "aY=h;else if((aY=M(aY))<aX){var b5=aX;aX=aY;aY=b5}return $sub(P(this),aX,aY)}),toUpperCase:c(function toUpperCase(){re"
+ "turn aA(this)}),toLocaleUpperCase:c(function toLocaleUpperCase(){return aA(this)}),toLowerCase:c(function toLowerCase("
+-"){return az(this)}),toLocaleLowerCase:c(function toLocaleLowerCase(){return az(this)}),valueOf:c(function valueOf(){Y("
+-"this,\"String\",\"valueOf\");return i(this,\"value\")}),toString:c(function toString(){Y(this,\"String\",\"toString\")"
+-";return i(this,\"value\")})});var Array=function Array(G){var aM=[],ak,aB;if((aB=(ak=arguments).length)===1&&typeof G="
+-"==\"number\"){if((G>>>0)!==G)throw m(\"Invalid array length\");aM.length=G}else{for(var u=0;u<aB;++u)aM[u]=ak[u]}retur"
+-"n aM};Q(Array,{dontEnum:true,readOnly:true,dontDelete:true},{prototype:a.prototypes.Array});Q(Array.prototype,{dontEnu"
+-"m:true},{constructor:Array,concat:c(function concat(b6){var aM=[],ak,aB=(ak=arguments).length,C=0,G=this;for(var u=-1;"
+-"u<aB;G=ak[++u]){if(i(G,\"class\")!==\"Array\"){aM[C++]=G}else{for(var b7=0,aG=G.length;b7<aG;++b7)if(b7 in G)aM[C+b7]="
+-"G[b7];aM.length=(C+=b7)}}return aM}),join:c(function join(aZ){var B=new x,b8,ay=O(this.length);aZ=(aZ===void 0?',':P(a"
+-"Z));for(var u=0;u<ay;++u){if(u>0)B.A(aZ);if((b8=this[u])!=null)B.A(P(b8))}return B.D()}),pop:c(function pop(){var G=vo"
+-"id 0,ay;if((ay=O(this.length))>0)G=this[--ay];this.length=ay;return G}),push:c(function push(b9){var ak,ba=O(this.leng"
+-"th),aY=(ak=arguments).length+ba;for(var u=ba;u<aY;++u)this[u]=ak[u-ba];return(this.length=aY)}),reverse:c(function rev"
+-"erse(){var ay,bb=f((ay=O(this.length))/2);--ay;for(var bc=0;bc<bb;++bc){var bd=ay-bc;var be=(bd in this),bf=this[bd];i"
+-"f(bc in this)this[bd]=this[bc];else delete this[bd];if(be)this[bc]=bf;else delete this[bc]}return this}),shift:c(funct"
+-"ion shift(){var ay,bg;if(ay=O(this.length)){bg=this[0];for(var u=1;u<ay;++u){if(u in this)this[u-1]=this[u];else delet"
+-"e this[u-1]}--ay};this.length=ay;return bg}),slice:c(function slice(aX,aY){var aM=[],ay=O(this.length);if((aX=M(aX))<0"
+-"){aX+=ay;if(aX<0)aX=0}if(aY===void 0||(aY=M(aY))>ay)aY=ay;else if(aY<0)aY+=ay;for(var u=aX,b7=0;u<aY;++u,++b7)if(u in "
+-"this)aM[b7]=this[u];aM.length=b7;return aM}),sort:c(function sort(bh){var bi=this;function b5(bj,bk,bl){var bm=(bk in "
+-"bj),bn=bj[bk];if(bl in bj)bj[bk]=bj[bl];else delete bj[bk];if(bm)bj[bl]=bn;else delete bj[bl]};function bo(bj,bk,bl){i"
+-"f(!(bk in bj)&&!(bl in bj))return 0;else if(!(bk in bj))return 1;else if(!(bl in bj))return-1;else{var aM=bj[bk];var y"
+-"=bj[bl];if(aM===void 0&&y===void 0)return 0;else if(aM===void 0)return 1;else if(y===void 0)return-1;else return bh(aM"
+-",y)}};function bp(bq,br){var bs=b5,bt=bo,bj=bi,bb,bu;for(--br;bq+1<br;bq=bu){var bv=br;bu=bq;bb=f((bu+bv)/2);while(bu<"
+-"bv){while(bu<=bv&&bt(bj,bu,bb)<=0&&bt(bj,bv,bb)>=0){++bu;--bv}while(bu<=bv&&bt(bj,bv,bb)>0)--bv;while(bu<=bv&&bt(bj,bu"
+-",bb)<0)++bu;if(bb===bu||bb===bv)bb^=bv^bu;if(bu<bv)bs(bj,bu,bv)}bp(bq,bu)}if(bq<br&&bt(bj,bq,br)>0)bs(bj,bq,br)};if(bh"
+-"===void 0){bh=function(aM,y){return((aM=P(aM))<(y=P(y))?-1:(aM>y?1:0))}};bp(0,this.length>>>0);return this}),splice:c("
+-"function splice(aX,bw){var aM=[],ay=O(this.length),ak,aB=(ak=arguments).length,aY,bx,by;if((aX=M(aX))<0){aX+=ay;if(aX<"
+-"0)aX=0}else if(aX>ay)aX=ay;if(aB==1||(aY=aX+M(bw))>ay)aY=ay;else if(aY<aX)aY=aX;for(var u=aX,b7=0;u<aY;++u,++b7)if(u i"
+-"n this)aM[b7]=this[u];aM.length=b7;if((bx=aB-2)<0)bx=0;if((by=aX+bx-aY)!==0){var bz=1,b7=aY;if(by>0){bz=-1;b7=ay-1}for"
+-"(u=ay-aY;--u>=0;b7+=bz){if(b7 in this)this[b7+by]=this[b7];else delete this[b7+by]}for(u=ay;--u>=ay+by;)delete this[u]"
+-"}for(u=2,b7=aX;u<aB;++u,++b7)this[b7]=ak[u];this.length=ay+by;return aM}),toLocaleString:Object.prototype.toLocaleStri"
+-"ng,toString:c(function toString(){Y(this,\"Array\",\"toString\");return this.join()}),unshift:c(function unshift(b6){v"
+-"ar ay,ak,C=(ak=arguments).length;if(ay=O(this.length)){for(var u=ay;--u>=0;){if(u in this)this[u+C]=this[u];else delet"
+-"e this[u+C]}}for(var u=0;u<C;++u)this[u]=ak[u];return(this.length=ay+C)})});function bA(){var bB=a.localTimeDifference"
+-"(14516064e5);var bC=a.localTimeDifference(14673312e5);return(bB>bC?bB:bC)}function bD(){var bB=a.localTimeDifference(1"
+-"4516064e5);var bC=a.localTimeDifference(14673312e5);return(bB<bC?bB:bC)}function bE(bF){var a2=a.localTimeDifference(b"
+-"F);return(d(a2)?bD():a2)}function bG(bF){return d(bF)?bF:bF+bE(bF)}function bH(R){if(i(R,\"class\")!==\"Date\")throw n"
+-"(\"this is not a Date object\")}function bI(R){bH(R);return i(R,\"value\")}function bJ(R){return bG(bI(R))}function bK"
+-"(R,G){bH(R);a.updateDateValue(R,G);return G}function bL(G){return d(G=bG(G))?\"Invalid Date\":(bM(G)+' '+bN(G))}functi"
+-"on bO(bP,C){return(bP%C+C)%C}function bQ(bR,bS,bT,bU){return bR*36e5+bS*6e4+bT*1e3+bU}function bV(bF){return[bO(f(bF/3"
+-"6e5),24),bO(f(bF/6e4),60),bO(f(bF/1e3),60),bO(bF,1e3)]}function bW(bF){return d(bF)?bF:(bF-bE(bF-bA()))}function bX(bF"
+-"){return bO(f(bF/864e5)+4,7)}function bY(bF){return bO(f(bF/36e5),24)}function bZ(bF){return bO(f(bF/6e4),60)}function"
+-" c0(bF){return bO(f(bF/1e3),60)}function c1(bF){return bO(bF,1e3)}function c2(bF){return(!e(bF)||abs(bF)>8.64e15?g:M(b"
+-"F))}function c3(bF){return bW(c2(bF))}function c4(bF){bF=f(bF/864e5)+719468;var c5=M((bF>=0?bF:bF-146096)/146097);var "
+-"c6=bF-c5*146097;var c7=M((c6-M(c6/1460)+M(c6/36524)-M(c6/146096))/365);var c8=c7+c5*400;var c9=c6-(365*c7+M(c7/4)-M(c7"
+-"/100));var ca=M((5*c9+2)/153);var aT=ca+(ca<10?2:-10);var cb=c9-M((153*ca+2)/5)+1;return[(c8+(aT<=1)),aT,cb]}function "
+-"bM(bF){var c8,cc=c4(bF);return(0<=(c8=cc[0])&&c8<=9999?a1(c8,4):(c8<0?\"-\":\"+\")+a1(abs(c8),6))+\"-\"+a1(cc[1]+1,2)+"
+-"\"-\"+a1(cc[2],2)}function bN(bF,bU){var cd=bV(bF);return a1(cd[0],2)+\":\"+a1(cd[1],2)+\":\"+a1(cd[2],2)+(bU?\".\"+a1"
+-"($sub(cd[3],0,3),3):\"\")}function ce(cf,cg,ch){cf+=f(cg/12)-(bO(cg,12)<=1);var c5=M((cf>=0?cf:cf-399)/400);var c7=cf-"
+-"c5*400;var c9=M((153*(cg+(cg>1?-2:10))+2)/5)+ch-1;var c6=c7*365+M(c7/4)-M(c7/100)+c9;return(c5*146097+c6-719468)*864e5"
+-"}function ci(bF,C,aM){var u,cb=c4(bF),aN=bO(bF,864e5);for(u=0;u<aM.length;++u,++C)cb[C]=M(aM[u]);return j(ce,null,cb)+"
+-"aN}function cj(bF,C,aM){var u,H=bV(bF),aN=f(bF/864e5)*864e5;for(u=0;u<aM.length;++u,++C)H[C]=M(aM[u]);return j(bQ,null"
+-",H)+aN}function ck(cf,cg,cl,cm,cn,co,bU){var aB=arguments.length;return ce((cf=M(cf))+(0<=cf&&cf<=99?1900:0),M(cg),(aB"
+-">2?M(cl):1))+bQ(aB>3?M(cm):0,aB>4?M(cn):0,aB>5?M(co):0,aB>6?M(bU):0)}function cp(cb){var bF;return d(bF=bI(cb))?null:b"
+-"M(bF)+\"T\"+bN(bF,true)+\"Z\"}var cq,Date=a.distinctConstructor(function Date(){return bL(a.getCurrentTime())},functio"
+-"n Date(cf,cg,cl,cm,cn,co,bU){var G,aB;if((aB=arguments.length)>=2&&aB<=7)G=c3(j(ck,null,arguments));else if(aB===1)G=c"
+-"2(typeof(G=a.toPrimitive(cf))===\"string\"?cq(G):+G);else G=a.getCurrentTime();return a.createWrapper(\"Date\",G,a.pro"
+-"totypes.Date)});Q(Date,{dontEnum:true,readOnly:true,dontDelete:true},{prototype:a.prototypes.Date});Q(Date,{dontEnum:t"
+-"rue},{parse:c(cq=function parse(B){var bF,c8,u,aU,cr,cs,ct,u=0;function cu(ay){var G;for(G=0;--ay>=0;)if(\"0\"<=B[u]&&"
+-"B[u]<=\"9\")G=G*10+(+B[u++]);else return g;return G}bF=ce(((aU=B[u])===\"+\"||aU===\"-\")&&(++u,c8=cu(6),aU===\"-\"?-c"
+-"8:c8)||cu(4),B[u]===\"-\"&&(++u,cu(2)-1)||0,B[u]===\"-\"&&(++u,cu(2))||1);bF+=bQ(((aU=B[u])===\"T\"||aU===\"t\"||aU==="
+-"' ')&&(++u,cu(2))||0,B[u]===\":\"&&(++u,cu(2))||0,B[u]===\":\"&&(++u,cu(2))||0,B[u]===\".\"&&(++u,cu(3))||0);while((aU"
+-"=B[u])!==void 0&&aU!==\"Z\"&&aU!==\"z\"&&aU!==\"+\"&&aU!==\"-\")++u;if(aU===\"Z\"||aU===\"z\")cr=0;else if(aU===\"+\"|"
+-"|aU===\"-\"){++u,cs=cu(2)*36e5,B[u]===\":\"&&++u,cs+=d(ct=cu(2))?0:ct*6e4,d(cs)||(cr=aU===\"-\"?-cs:cs)}return(cr===vo"
+-"id 0?bW(bF):bF-cr)}),UTC:c(function UTC(cf,cg,cl,cm,cn,co,bU){return c2(ck(cf,cg,cl,cm,cn,co,bU))})});Q(Date.prototype"
+-",{dontEnum:true},{constructor:Date,toISOString:c(function toISOString(){var B;if((B=cp(this))===null)throw m(\"Invalid"
+-" time value\");return B}),toUTCString:c(function toUTCString(){var bF;if(d(bF=bI(this)))return\"Invalid Date\";return("
+-"bM(bF)+' '+bN(bF))}),toString:c(function toString(){return bL(bI(this))}),toDateString:c(function toDateString(){var a"
+-"2;if(d(a2=bJ(this)))return\"Invalid Date\";return bM(a2)}),toTimeString:c(function toTimeString(){var a2;if(d(a2=bJ(th"
+-"is)))return\"Invalid Date\";return bN(a2)}),toLocaleString:Object.prototype.toLocaleString,toLocaleDateString:c(functi"
+-"on toLocaleDateString(){return this.toDateString()}),toLocaleTimeString:c(function toLocaleTimeString(){return this.to"
+-"TimeString()}),valueOf:c(function valueOf(){return bI(this)}),getTime:c(function getTime(){return bI(this)}),getFullYe"
+-"ar:c(function getFullYear(){return c4(bJ(this))[0]}),getUTCFullYear:c(function getUTCFullYear(){return c4(bI(this))[0]"
+-"}),getMonth:c(function getMonth(){return c4(bJ(this))[1]}),getUTCMonth:c(function getUTCMonth(){return c4(bI(this))[1]"
+-"}),getDate:c(function getDate(){return c4(bJ(this))[2]}),getUTCDate:c(function getUTCDate(){return c4(bI(this))[2]}),g"
+-"etDay:c(function getDay(){return bX(bJ(this))}),getUTCDay:c(function getUTCDay(){return bX(bI(this))}),getHours:c(func"
+-"tion getHours(){return bY(bJ(this))}),getUTCHours:c(function getUTCHours(){return bY(bI(this))}),getMinutes:c(function"
+-" getMinutes(){return bZ(bJ(this))}),getUTCMinutes:c(function getUTCMinutes(){return bZ(bI(this))}),getSeconds:c(functi"
+-"on getSeconds(){return c0(bJ(this))}),getUTCSeconds:c(function getUTCSeconds(){return c0(bI(this))}),getMilliseconds:c"
+-"(function getMilliseconds(){return c1(bJ(this))}),getUTCMilliseconds:c(function getUTCMilliseconds(){return c1(bI(this"
+-"))}),getTimezoneOffset:c(function getTimezoneOffset(){var G=bI(this);return(G-bG(G))/6e4}),setTime:c(function setTime("
+-"time){return bK(c2(+time))}),setMilliseconds:c(function setMilliseconds(bU){return bK(this,c3(cj(bJ(this),3,arguments)"
+-"))}),setUTCMilliseconds:c(function setUTCMilliseconds(bU){return bK(this,c2(cj(bI(this),3,arguments)))}),setSeconds:c("
+-"function setSeconds(B,bU){return bK(this,c3(cj(bJ(this),2,arguments)))}),setUTCSeconds:c(function setUTCSeconds(B,bU){"
+-"return bK(this,c2(cj(bI(this),2,arguments)))}),setMinutes:c(function setMinutes(aT,B,bU){return bK(this,c3(cj(bJ(this)"
+-",1,arguments)))}),setUTCMinutes:c(function setUTCMinutes(aT,B,bU){return bK(this,c2(cj(bI(this),1,arguments)))}),setHo"
+-"urs:c(function setHours(cv,aT,B,bU){return bK(this,c3(cj(bJ(this),0,arguments)))}),setUTCHours:c(function setUTCHours("
+-"cv,aT,B,bU){return bK(this,c2(cj(bI(this),0,arguments)))}),setDate:c(function setDate(cl){return bK(this,c3(ci(bJ(this"
+-"),2,arguments)))}),setUTCDate:c(function setUTCDate(cl){return bK(this,c2(ci(bI(this),2,arguments)))}),setMonth:c(func"
+-"tion setMonth(cg,cl){return bK(this,c3(ci(bJ(this),1,arguments)))}),setUTCMonth:c(function setUTCMonth(cg,cl){return b"
+-"K(this,c2(ci(bI(this),1,arguments)))}),setFullYear:c(function setFullYear(cf,cg,cl){var G;return bK(this,c3(ci(d(G=bI("
+-"this))?0:bG(G),0,arguments)))}),setUTCFullYear:c(function setUTCFullYear(cf,cg,cl){var G;return bK(this,c2(ci(d(G=bI(t"
+-"his))?0:G,0,arguments)))}),toJSON:c(function toJSON(){return cp(this)})});var G=1;var cw=G,cx=(G<<=1),cy=(G<<=1),cz=(G"
+-"<<=1),cA=(G<<=1),cB=(G<<=1),cC=(G<<=1),cD=(G<<=1),cE=(G<<=1),cF=(G<<=1),cG=(G<<=1);var CC={};(function(){function cH(c"
+-"I,cJ){for(var u in cJ)CC[cJ[u]]|=cI}cH(cE,\"^$.*+?()[]{}|\");cH(cA|cC|cz,\"0123456789\");cH(cC|cB|cz,\"abcdefABCDEF\")"
+-";cH(cB|cz,\"ghijklmnopqrstuvwxyzGHIJKLMNOPQRSTUVWXYZ\");cH(cx|cy,\"\\n\\r\\u2028\\u2029\");cH(cy,\" \\t\\v\\f\\xA0\");"
+-"CC['_']|=cz;CC[\"undefined\"]|=cw;CC['']|=cw;cH(cD,\"fnrtv\");for(var u=32;u<=126;++u){var au=a.fromCharCode(u);if(au!"
+-"=='\"'&&au!=='\\\\')CC[a.fromCharCode(u)]|=cF}var cK=[0,48,58,65,91,95,96,97,123,128];for(var u=cK.length-2;u>=0;u-=2)"
+-"for(var b7=cK[u],cL=cK[u+1];b7<cL;++b7)CC[a.fromCharCode(b7)]|=cG})();function regExpCanonicalize(B){var H='',au,cb;if"
+-"(!as)at();for(var u=0,ay=B.length;u<ay;++u)H+=((cb=as[au=B[u]])&&cb.length===1&&(au<'\\x80'||cb>='\\x80')?cb:au);retur"
+-"n H}function cM(B,cN,cO){var X=0,cP='',cQ=0,cR=0,cS='',cT=0;function cU(cV,cI){return((CC[cV]&cI)!==0)}function cW(B,c"
+-"I){for(var u=B.length-1;u>=0;--u)if((CC[B[u]]&cI)===0)return false;return true}var cX={'D':[cA,true],'d':[cA,false],'S"
+-"':[cy,true],'s':[cy,false],'W':[cz,true],'w':[cz,false],'.':[cx,true]};function cY(cZ){var C=cZ;if(cU(B[X],cA)){C=0;do"
+-"{C=C*10+(k(B,X)-48);++X}while(cU(B[X],cA))}return C}function d0(){var d1=0,d2=h,d3=true;switch(B[X]){case'*':++X;break"
+-";case'+':++X;d1=1;break;case'?':++X;d2=1;break;case'{':{var y=X;++X;if((d1=d2=cY(-1))<0){X=y;return null}if(B[X]===','"
+-"){++X;d2=cY(h)}if(B[X]!=='}'){X=y;return null}if(d1>d2){throw l(\"Min greater than max in regular expression quantifie"
+-"r\")}++X;break}default:return null}if(B[X]==='?'){++X;d3=false}return{d1:d1,d2:d2,d3:d3}}function d4(au){if(cU(au,cF))"
+-"return au;return(au<='~'?\"\\\\x\":\"\\\\u\")+a1(ad(k(au,0),16),(au<='~'?2:4))}function d5(au){return d4(cN?regExpCano"
+-"nicalize(au):au)}function d6(){var d7,d8,d9;if((d7=B[X])==='\\\\'){switch(d8=B[X+1]){case'0':{if(!cU(B[X+2],cA)){X+=2;"
+-"return'\\0'}break}case'c':{if(cU(B[X+2],cB)){X+=3;return a.fromCharCode(k(B,X-1)&31)}break}case'x':case'u':{var C=(d8="
+-"=='x'?2:4);if(cW(d9=$sub(B,X+2,X+2+C),cC)){X+=2+C;return a.fromCharCode(parseInt(d9,16))}break}default:{if(cU(d8,cD)){"
+-"X+=2;return eval('\"\\\\'+d8+'\"')}else if(cU(d8,cG)){X+=2;return d8}break}}}else if(d7){++X;return d7}}function da(){"
+-"var db=[],G,C=0;while(!cU(B[X],cE)&&(G=d6()))db[C++]=d5(G);return(db.length?db:null)}function dc(){var G,dd,au;if((au="
+-"B[X])!==']'&&(G=d6()))return G;if(au==='\\\\'){if((au=B[X+1])==='b'){X+=2;return'\\b'}if(dd=cX[au]){X+=2;return dd}}}f"
+-"unction de(ba){return(ba===0?'p':((ba<0?'p':'p+')+ba))}function df(db,ba){if(db.length===0)return\"true\";else if(db.l"
+-"ength===1)return\"s[\"+de(ba)+']===\"'+db[0]+'\"';else if(db.length===2)return\"s[\"+de(ba)+']===\"'+db[0]+'\" && s['+"
+-"de(ba+1)+']===\"'+db[1]+'\"';else{for(var u=0,B='',a2=db.length;u<a2;++u)B+=db[u];return\"$match(s,\"+de(ba)+',\"'+B+'"
+-"\")'}}function dg(aM,y){switch(aM){case\"false\":return\"false\";case\"true\":return y;default:return(y===\"true\"?aM:"
+-"aM+\" && \"+y)}}function dh(aM,y){switch(aM){case\"false\":return y;case\"true\":return\"true\";default:return(y===\"f"
+-"alse\"?aM:aM+\" || \"+y)}}function di(name,dj){cP+=\"\\tfunction \"+name+\"(p) { \"+dj+\" }\\n\"}function dk(dl,ba,dm,"
+-"dn,dp,dq){var dr='q'+(++cQ),ds=(dq?\"var h=\"+dq+\",\":\"var \")+(dp.d1?\"b=p+\"+dp.d1+(dq?\"*h\":\"\"):\"b=p\")+(dp.d"
+-"2<h?\",e=p+\"+dp.d2+(dq?\"*h\":\"\"):\"\")+\"; \";if(dq)ds+=\"if (h<=0 || h!==h) return \"+dn+\"; \";if(dp.d3){di(dr,d"
+-"s+\"while (\"+dg((dp.d2<h?\"p<e\":\"true\"),dm)+\") \"+(dq?\"p+=h\":\"++p\")+\"; while (\"+dg(\"p>=b\",\"!(\"+dn+\")\""
+-")+\") \"+(dq?\"p-=h\":\"--p\")+\"; return p>=b\")}else{di(dr,ds+\"while (\"+dh((dp.d1?\"p<b\":\"false\"),\"!(\"+dn+\")"
+-"\")+\") { if (\"+dh((dp.d2<h?\"p>=e\":\"false\"),\"!(\"+dm+\")\")+\") return false; \"+(dq?\"p+=h\":\"++p\")+\" }; ret"
+-"urn true\")}return dg(dl,dr+\"(\"+de(ba)+\")\")}function dt(dl,du,dv,dw){if(du===null&&dv===dw){return\"return \"+dl}e"
+-"lse{var dx='',dy='',dz='';if(du!==null){dx+='r'+du+\"=c\"+du;dy='c'+du+\"=p\";dz='c'+du+\"=r\"+du}if(dw!==void 0){for("
+-"var u=dv;u<dw;++u){var b7=u*2;if(du!==null||u>dv){dx+=',';dz+=',';if(u===dv){dy+=','}}dx+='r'+b7+\"=c\"+b7;dy+='c'+b7+"
+-"'=';dz+='c'+b7+\"=r\"+b7;if(u===dw-1){dy+=\"void 0\"}}}dl=dy+\", \"+dh(dl,'('+dz+\",false)\");return\"var \"+dx+\"; re"
+-"turn \"+dl}}function dA(aU,dd){return(dd[1]?'!':\"!!\")+\"(CC[\"+aU+\"]&\"+(dd[0]|(dd[1]?cw:0))+')'}function dB(ba,dC)"
+-"{var db,dp,dl=\"true\";dD:for(;;){if(db=da()){if(dp=d0()){var dE=db[db.length-1];--db.length;return dk(dg(dl,df(db,ba)"
+-"),ba+db.length,df(dE,0),dB(0,dC),dp)}dl=dg(dl,df(db,ba));ba+=db.length}else{var au,dF,dn,dG,dH;switch(au=B[X]){case'^'"
+-":{++X;dF=de(ba)+\"===0\";if(cO)dF='('+dh(dF,\"!!(CC[s[\"+de(ba-1)+\"]]&\"+cx+')')+')';dl=dg(dl,dF);break}case'$':{++X;"
+-"dF=de(ba)+\"===l\";if(cO)dF='('+dh(dF,\"!!(CC[s[\"+de(ba)+\"]]&\"+cx+')')+')';dl=dg(dl,dF);break}case'[':{var dI=false"
+-",dJ,dK,dL=\"false\";if(B[++X]==='^'){dI=true;++X}while(dJ=dc()){var y=X;if(B[X]==='-'&&(++X,dK=dc())){if(typeof dJ==="
+-"\"string\"&&typeof dK===\"string\"&&dJ<=dK){if(cN&&(dJ>'~'||dK>'~'||(regExpCanonicalize(dJ)!==dJ)!==(regExpCanonicaliz"
+-"e(dK)!==dK))){dJ=d4(dJ);dK=d4(dK);dL=dh(dL,dg('upperToLower[c]>=\"'+dJ+'\"','upperToLower[c]<=\"'+dK+'\"'))}else{dJ=d5"
+-"(dJ);dK=d5(dK)}dL=dh(dL,dg('c>=\"'+dJ+'\"','c<=\"'+dK+'\"'))}else{throw l(\"Invalid character class syntax in regular "
+-"expression\")}}else if(typeof dJ===\"string\"){X=y;dL=dh(dL,'c===\"'+d5(dJ)+'\"')}else{dL=dh(dL,dA('c',dJ))}}if(B[X]!="
+-"=']'){throw l(\"Invalid character class syntax in regular expression\")}++X;var dr='k'+(++cQ);di(dr,\"var c=s[p]; retu"
+-"rn \"+(dI?\"p!==l && !(\"+dL+')':dL));if(dp=d0()){return dk(dl,ba,dr+'('+de(0)+')',dB(0,dC),dp)}dl=dg(dl,dr+'('+de(ba)"
+-"+')');++ba;break}case'\\\\':{var C;++X;if((C=cY(-1))>=0){if(C>cT)cT=C;C=(C-1)*2;dp=d0();var dq='c'+(C+1)+\"-c\"+C,dM="
+-"\"$match(s,\"+de(ba)+\",$sub(s, c\"+C+\",c\"+(C+1)+\"))\";dn=dB(0,dC);var dN='t'+(++cQ);di(dN,\"return \"+dn);return d"
+-"p?dk(dl,ba,dM,dN+'('+de(0)+')',dp,dq):dg(dl,'(c'+C+\"<c\"+(C+1)+\" ? \"+dg(dM,dN+'('+de(ba)+'+'+dq+')')+\" : \"+dN+'('"
+-"+de(ba)+\"))\")}else if((au=B[X])==='b'||au==='B'){++X;dl=dg(dl,(au==='b'?\"!!((CC[s[\":\"!((CC[s[\")+de(ba-1)+\"]]^CC"
+-"[s[\"+de(ba)+\"]])&\"+cz+')');break}}case'.':{var dd;if(!(dd=cX[au]))throw l(\"Invalid escape in regular expression\")"
+-";++X;if(dp=d0()){return dk(dl,ba,dA(\"s[\"+de(0)+']',dd),dB(0,dC),dp)}dl=dg(dl,dA(\"s[\"+de(ba)+']',dd));++ba;break}ca"
+-"se'(':{var dO=++cQ,dP='g'+dO,dQ=dP+'('+de(ba)+')',dR='j'+dO,dS=dR+'('+de(ba)+')',dT=true,dU=false,dV=false;++X;if(B[X]"
+-"==='?'){switch(B[X+1]){case'!':dV=true;case'=':dU=true;case':':dT=false;X+=2}}var dW=null,dX=null;if(dT){(dX=(dW=(cR++"
+-")*2)+1);cS+=\",c\"+dW+\",c\"+dX}var dY=cR,dZ=e0(0,(dU?void 0:dR)),e1=cR;if((au=B[X])!==')'){throw l(au?\"Unterminated "
+-"group in regular expression\":\"Invalid regular expression\")}++X;dp=(dU?null:d0());dn=dB(0,dC);dH=dZ;var e2='',e3=(dp"
+-"&&dp.d2>1);if(e3&&(dp.d2<h||dp.d1>1)){cS+=\",n\"+dO+\"=0\";dH=((dp.d2<h)?dg(\"++n\"+dO+\"<=\"+dp.d2,dH):\"++n\"+dO+\","
+-" \"+dH);if(dp.d1>1){dH=dg(dH,'n'+dO+\">=\"+dp.d1);e2='n'+dO+'<'+dp.d1}dH=dh(dH,\"(--n\"+dO+\",false)\")}if(dU){dG=dR+'"
+-"('+de(0)+')';if(dV){dH=\"!(\"+dH+')';if(dY<e1){var e4='';for(var u=dY;u<e1;++u)e4+='c'+u*2+'=';dG='('+e4+\"void 0, \"+"
+-"dG+')'}}dH=dg(dH,dG)}if(e3){cS+=\",p\"+dO;var e5='p'+dO+\"!=p\";dH=dg(e2?'('+dh(e5,e2)+')':e5,\"(p\"+dO+\"=p, \"+dH+')"
+-"')}di(dP,dt(dH,dW,dY,e1));if(e3){var e6=dP+'('+de(0)+')';dH=(dp.d3?dh(e6,dn):dh(dn,e6));di(dR,dt(dH,dX));dG=(dp.d1===0"
+-"?dS:dQ);dl=dg(dl,'(p'+dO+\"=void 0,\"+dG+')')}else{di(dR,dt(dn,dX));dl=((dp&&dp.d1===0)?dg(dl,(dp.d2===0?dS:'('+(dp.d3"
+-"?dh(dQ,dS):dh(dS,dQ))+')')):dg(dl,dQ))}return dl}default:break dD}}}switch(dC){case void 0:return dl;case'':return dg("
+-"dl,\"(q=\"+de(ba)+\",true)\");default:return dg(dl,dC+'('+de(ba)+')')}}function e0(ba,dC){var dl=dB(ba,dC);if(B[X]==='"
+-"|'){do{++X;dl=dh(dl,dB(ba,dC))}while(B[X]==='|');dl='('+dl+')'}return dl}var dZ=e0(0,'');if(X<B.length)throw l(\"Inval"
+-"id regular expression\");if(cT>cR)throw l(\"Invalid back reference in regular expression\");var dl=\"(function(s, p) {"
+-"\\n\";if(cN)dl+=\"\\ts=regExpCanonicalize(s)\\n\";dl+=\"\\tvar l=s.length,q\";dl+=cS+\";\\n\"+cP+\"\\tif (\"+dZ+\") re"
+-"turn [p,q\";for(var u=0;u<cR*2;++u)dl+=\",c\"+u;dl+=\"];\\n})\";return dl}var e7={'g':\"global\",'i':\"ignoreCase\",'m"
+-"':\"multiline\"},e8={},e9;function ea(b4,a7){a7=P(a7);var u;if((u=(b4.global?M(b4.lastIndex):0))>=0){var aW=i(b4,\"val"
+-"ue\"),ay=a7.length,aT;for(;u<=ay;++u)if(aT=aW(a7,u)){if(b4.global)b4.lastIndex=aT[1];return aT}}b4.lastIndex=0}functio"
+-"n aL(b4,a7){var aT,aM=null;if(aT=ea(b4,a7)){(aM=[]).input=a7;aM.index=aT[0];for(var b7=0;b7<aT.length;b7+=2)aM[aM.leng"
+-"th]=((aT[b7]===void 0)?void 0:$sub(a7,aT[b7],aT[b7+1]))}return aM}function eb(b4){return(b4.global?'g':'')+(b4.ignoreC"
+-"ase?'i':'')+(b4.multiline?'m':'')}var RegExp=a.distinctConstructor(function RegExp(ec,ed){return(i(ec,\"class\")===\"R"
+-"egExp\"&&ed===void 0?ec:new a.createRegExp(ec,ed))},a.createRegExp=function RegExp(ec,ed){if(i(ec,\"class\")===\"RegEx"
+-"p\"){if(ed!==void 0)throw n(\"Cannot supply flags when constructing one RegExp from another\");ed=eb(ec);ec=ec.source}"
+-"ec=(ec===void 0?'':P(ec));ed=(ed===void 0?'':P(ed));var ee={global:false,ignoreCase:false,multiline:false,source:ec};f"
+-"or(var u=ed.length-1;u>=0;--u){var X;if(!(X=e7[ed[u]])||ee[X])throw l(\"Invalid regular expression flags\");ee[X]=true"
+-"}var ef,eg;if(!(eg=e8[ef=ec+','+ee.ignoreCase+','+ee.multiline]))e8[ef]=eg=ah(cM(ec,ee.ignoreCase,ee.multiline));var b"
+-"4=a.createWrapper(\"RegExp\",eg,e9);Q(b4,{dontEnum:true,readOnly:true,dontDelete:true},ee);Q(b4,{dontEnum:true,dontDel"
+-"ete:true},{lastIndex:0});return b4});Q(RegExp,{dontEnum:true,readOnly:true,dontDelete:true},{prototype:e9=RegExp.proto"
+-"type});Q(RegExp.prototype,{dontEnum:true},{exec:c(function exec(a7){Y(this,\"RegExp\",\"exec\");return aL(this,a7)}),t"
+-"est:c(function test(a7){Y(this,\"RegExp\",\"test\");return ea(this,a7)!==void 0}),toString:c(function toString(){Y(thi"
+-"s,\"RegExp\",\"toString\");return'/'+this.source+'/'+eb(this)})});Q(b,{dontEnum:true},{Array:Array,Boolean:Boolean,Dat"
+-"e:Date,Function:Function,Math:a.createWrapper(\"Math\",void 0),Number:Number,Object:Object,RegExp:RegExp,String:String"
+-",isFinite:c(function isFinite(G){return e(+G)}),isNaN:c(function isNaN(G){return d(+G)}),JSON:a.createWrapper(\"JSON\""
+-",void 0),eval:a.evalFunction=c(function eval(bP){return a.eval(bP)}),parseFloat:c(function parseFloat(a7){return a.par"
+-"seFloat(P(a7))}),parseInt:c(function parseInt(a7,af){a7=P(a7);var s=r,u=-1,ag=1;while(s[a7[++u]]===null);switch(a7[u])"
+-"{case'-':ag=-1;case'+':++u}if(((af=N(af))===0||af===16)&&(a7[u]==='0'&&a7[u+1]==='x')){u+=2;af=16}if(af===0)af=10;else"
+-" if(af<2||af>36)return g;var G=0,y,aG=a7.length,C;for(y=u;u<aG&&(C=s[a7[u]])!=null&&C<af;++u)G=G*af+C;return(y===u?g:G"
+-"*ag)})});Q(b,{dontEnum:true,dontDelete:true},{NaN:g,Infinity:h,undefined:a.undefined});Q(Math,{readOnly:true,dontEnum:"
+-"true,dontDelete:true},{E:2.718281828459045235360,LN10:2.302585092994045684018,LN2:0.6931471805599453094172,LOG10E:0.43"
+-"429448190325182765113,LOG2E:1.442695040888963407360,PI:3.1415926535897932,SQRT1_2:0.7071067811865475244008,SQRT2:1.414"
+-"213562373095048802});Q(Math,{dontEnum:true},{abs:c(abs=function abs(G){return((G=+G)<0?-G:G)}),acos:c(function acos(G)"
+-"{return a.acos(+G)}),asin:c(function asin(G){return a.asin(+G)}),atan:c(function atan(G){return a.atan(+G)}),atan2:c(f"
+-"unction atan2(c8,bP){return a.atan2(+c8,+bP)}),ceil:c(function ceil(G){return-f(-G)}),cos:c(function cos(G){return a.c"
+-"os(+G)}),exp:c(function exp(G){return a.exp(+G)}),floor:c(function floor(G){return f(+G)}),log:c(function log(G){retur"
+-"n a.log(+G)}),max:c(function max(bP,c8){var aT=-h,G,ak;for(var u=(ak=arguments).length-1;u>=0;--u)if((G=+ak[u])>aT||d("
+-"G))aT=G;return aT}),min:c(function min(bP,c8){var aT=h,G,ak;for(var u=(ak=arguments).length-1;u>=0;--u)if((G=+ak[u])<a"
+-"T||d(G))aT=G;return aT}),pow:c(function pow(bP,c8){return a.pow(+bP,+c8)}),random:c(function random(){return a.random("
+-")}),round:c(function round(G){return(G===0.0?G:(G>=-0.5&&G<0.0?-0.0:f(G+0.5)))}),sin:c(function sin(G){return a.sin(+G"
+-")}),sqrt:c(function sqrt(G){return a.sqrt(+G)}),tan:c(function tan(G){return a.tan(+G)})});function eh(name,prototype)"
+-"{return function(message){var aG;a.defineProperty(aG=a.createWrapper(\"Error\",name,prototype),\"message\",(message!=="
+-"void 0?P(message):''),false,true,false);return aG}};(function(){var ei=[\"Error\",\"EvalError\",\"RangeError\",\"Refer"
+-"enceError\",\"SyntaxError\",\"TypeError\",\"URIError\"];for(var u=ei.length;--u>=0;){var C,au,X;a.defineProperty(b,C=e"
+-"i[u],au=eh(C,X=a.prototypes[C]),false,true,false);au.name=C;Q(au,{dontEnum:true,readOnly:true,dontDelete:true},{protot"
+-"ype:X});Q(X,{dontEnum:true},{constructor:au});X.name=C}Q(Error.prototype,{dontEnum:true},{message:'',toString:c(functi"
+-"on toString(){return(this.name===void 0?\"Error\":this.name)+(this.message?(\": \"+this.message):'')})});l=SyntaxError"
+-";m=RangeError;n=TypeError})();var ej={'\\\\':\"\\\\\\\\\",'\"':\"\\\\\\\"\",'\\b':\"\\\\b\",'\\f':\"\\\\f\",'\\n':\"\\"
+-"\\n\",'\\r':\"\\\\r\",'\\t':\"\\\\t\"};var ek=61;Q(JSON,{dontEnum:true},{stringify:c(function stringify(ae,el,em){var "
+-"en=[],eo=(typeof el===\"function\"?el:null),ep='',eq;if(i(el,\"class\")===\"Array\"){eq={};for(var u=el.length;--u>=0;"
+-")eq[el[u]]=true}if(typeof em===\"number\"||(typeof em===\"object\"&&i(em,\"class\")===\"Number\")){em=+em;for(var u=(e"
+-"m>10?10:em);--u>=0;)ep+=' '}else if(typeof em===\"string\"||(typeof em===\"object\"&&i(em,\"class\")===\"String\")){ep"
+-"=$sub(P(em),0,10)}function er(B){var H='\"',ay=B.length;for(var u=0;u<ay;++u){var aU=B[u],es;H+=((es=ej[aU])?es:((aU>="
+-"' '&&aU<='~')?aU:\"\\\\u\"+a1(ad(k(aU,0),16),4)))}return H+'\"'}function a7(ef,et,eu){var ae;if((ae=et[ef])&&typeof ae"
+-"===\"object\"&&typeof ae.toJSON===\"function\")ae=ae.toJSON(ef);if(eo)ae=j(eo,et,[ef,ae]);var ev=(ep?'\\n'+eu:'');if(t"
+-"ypeof ae===\"object\"){switch(i(ae,\"class\")){case\"Number\":ae=+ae;break;case\"String\":ae=P(ae);break;case\"Boolean"
+-"\":ae=i(ae,\"value\");break}}switch(typeof ae){case\"object\":{if(!ae)return\"null\";var ay,B=new x,G;for(var u=(ay=en"
+-".length);--u>=0;){if(en[u]===ae)throw n(\"Cannot convert circular structure to JSON\")}if(ay>ek)throw n(\"Structure to"
+-"o deeply nested for JSON conversion\");en[ay]=ae;if(i(ae,\"class\")===\"Array\"){ay=ae.length;for(var u=0;u<ay;++u){B."
+-"A((u==0?'[':',')+ev+ep+(a7(u,ae,eu+ep)||\"null\"))}B.A(ay==0?\"[]\":ev+']')}else{var ew=false;for(var cL in(eq?eq:ae))"
+-"{if(a.hasOwnProperty(ae,cL)){if(G=a7(cL,ae,eu+ep)){B.A((ew?',':'{')+ev+ep+er(cL)+(ep?\": \":':')+G);ew=true}}}B.A(ew?e"
+-"v+'}':\"{}\")}--en.length;return B.D()}case\"string\":return er(ae);case\"number\":return(e(ae)?P(ae):\"null\");case\""
+-"boolean\":return P(ae)}}return a7('',{'':ae},'')}),parse:c(function parse(ex,ey){var ez=0;function em(H,X){var aU;whil"
+-"e((aU=H[X])===' '||aU==='\\t'||aU==='\\r'||aU==='\\n')++X;return X}function eA(H,X){var aU;if(H[X]==='-')++X;if((aU=H["
+-"X])==='0')aU=H[++X];else if(aU>='1'&&aU<='9')do{aU=H[++X]}while(aU>='0'&&aU<='9');else return;if(aU==='.'){if((aU=H[++"
+-"X])<'0'||aU>'9')return;while((aU=H[++X])>='0'&&aU<='9')}if(aU==='e'||aU==='E'){if((aU=H[++X])==='-'||aU==='+')aU=H[++X"
+-"];if(aU<'0'||aU>'9')return;while((aU=H[++X])>='0'&&aU<='9')}return X}function a7(H,X){var aU;if(H[X]!=='\"')return;++X"
+-";while((aU=H[X])!=='\"'&&aU>=' '){if(aU==='\\\\'){switch(H[++X]){default:return;case'\"':case'/':case'\\\\':case'b':ca"
+-"se'f':case'n':case'r':case't':break;case'u':for(var u=4;--u>=0;)if(!(((aU=H[++X])>='0'&&aU<='9')||(aU>='a'&&aU<='f')||"
+-"(aU>='A'&&aU<='F')))return;break}}++X}if(aU==='\"')return++X}function eB(H,X){if($match(H,X,\"true\")||$match(H,X,\"nu"
+-"ll\"))return X+4;else if($match(H,X,\"false\"))return X+5}function R(H,X){if(ez>ek)throw n(\"Structure too deeply nest"
+-"ed for JSON conversion\");++ez;try{var aU,eC=false,eD=H[X],eE=(eD==='['?']':'}');X=em(H,++X);while((aU=H[X])!==eE&&aU)"
+-"{if(eC){if(aU!==',')return;X=em(H,++X)}if(eD==='{'){if(!(X=a7(H,X))||H[X=em(H,X)]!==':')return;X=em(H,++X)}if(!(eF=eG["
+-"H[X]])||!(X=eF(H,X)))return;X=em(H,X);eC=true}if(aU===eE)return++X}finally{--ez}}var eG={'{':R,'[':R,'\"':a7,'t':eB,'f"
+-"':eB,'n':eB,'-':eA,'0':eA,'1':eA,'2':eA,'3':eA,'4':eA,'5':eA,'6':eA,'7':eA,'8':eA,'9':eA};ex=P(ex);var X,eF;if((eF=eG["
+-"ex[X=em(ex,0)]])&&(X=eF(ex,X))&&em(ex,X)===ex.length){var ae=eval('('+ex+')');if(typeof ey===\"function\"){function eH"
+-"(et,ef){var cL,G,J;if(typeof(J=et[ef])===\"object\"&&J){for(cL in J){if(a.hasOwnProperty(J,cL)){if((G=eH(J,cL))!==void"
+-" 0)J[cL]=G;else delete J[cL]}}}return j(ey,et,[ef,J])}ae=eH({\"\":ae},\"\")}return ae}throw l(\"Error parsing JSON\")}"
+-")});Q(Array,{dontEnum:true},{isArray:c(function isArray(J){return i(J,\"class\")===\"Array\"})});Q(Object,{dontEnum:tr"
+-"ue},{defineProperty:c(function defineProperty(J,X,cb){a.defineProperty(J,P(X),cb.value,!cb.writable,!cb.enumerable,!cb"
+-".configurable)}),getPrototypeOf:c(function getPrototypeOf(J){return i(J,\"prototype\")})});if(g.toString()!==\"NaN\")t"
+-"hrow Error(\"Internal self test failed. Check C++ compiler options concerning IEEE 754 compliance.\")})"
++"){return az(this)}),toLocaleLowerCase:c(function toLocaleLowerCase(){return az(this)}),trimLeft:c(function trimLeft(){"
++"var B=P(this),u=0,b6=B.length,au;for(;u<b6;++u){au=B.charCodeAt(u);if(au!==0x20&&(au<0x09||au>0x0D)&&au!==0xA0&&au!==0"
++"x2028&&au!==0x2029&&au!==0xFEFF)break}return $sub(B,u,b6)}),trimRight:c(function trimRight(){var B=P(this),b6=B.length"
++",au;for(;b6>0;--b6){au=B.charCodeAt(b6-1);if(au!==0x20&&(au<0x09||au>0x0D)&&au!==0xA0&&au!==0x2028&&au!==0x2029&&au!=="
++"0xFEFF)break}return $sub(B,0,b6)}),trim:c(function trim(){var B=P(this),u=0,b6=B.length,au;for(;u<b6;++u){au=B.charCod"
++"eAt(u);if(au!==0x20&&(au<0x09||au>0x0D)&&au!==0xA0&&au!==0x2028&&au!==0x2029&&au!==0xFEFF)break}for(;b6>u;--b6){au=B.c"
++"harCodeAt(b6-1);if(au!==0x20&&(au<0x09||au>0x0D)&&au!==0xA0&&au!==0x2028&&au!==0x2029&&au!==0xFEFF)break}return $sub(B"
++",u,b6)}),valueOf:c(function valueOf(){Y(this,\"String\",\"valueOf\");return i(this,\"value\")}),toString:c(function to"
++"String(){Y(this,\"String\",\"toString\");return i(this,\"value\")})});var Array=function Array(G){var aM=[],ak,aB;if(("
++"aB=(ak=arguments).length)===1&&typeof G===\"number\"){if((G>>>0)!==G)throw m(\"Invalid array length\");aM.length=G}els"
++"e{for(var u=0;u<aB;++u)aM[u]=ak[u]}return aM};Q(Array,{dontEnum:true,readOnly:true,dontDelete:true},{prototype:a.proto"
++"types.Array});Q(Array.prototype,{dontEnum:true},{constructor:Array,concat:c(function concat(b7){var aM=[],ak,aB=(ak=ar"
++"guments).length,C=0,G=this;for(var u=-1;u<aB;G=ak[++u]){if(i(G,\"class\")!==\"Array\"){aM[C++]=G}else{for(var b6=0,aG="
++"G.length;b6<aG;++b6)if(b6 in G)aM[C+b6]=G[b6];aM.length=(C+=b6)}}return aM}),join:c(function join(aZ){var B=new x,b8,a"
++"y=O(this.length);aZ=(aZ===void 0?',':P(aZ));for(var u=0;u<ay;++u){if(u>0)B.A(aZ);if((b8=this[u])!=null)B.A(P(b8))}retu"
++"rn B.D()}),pop:c(function pop(){var G=void 0,ay;if((ay=O(this.length))>0)G=this[--ay];this.length=ay;return G}),push:c"
++"(function push(b9){var ak,ba=O(this.length),aY=(ak=arguments).length+ba;for(var u=ba;u<aY;++u)this[u]=ak[u-ba];return("
++"this.length=aY)}),reverse:c(function reverse(){var ay,bb=f((ay=O(this.length))/2);--ay;for(var bc=0;bc<bb;++bc){var bd"
++"=ay-bc;var be=(bd in this),bf=this[bd];if(bc in this)this[bd]=this[bc];else delete this[bd];if(be)this[bc]=bf;else del"
++"ete this[bc]}return this}),shift:c(function shift(){var ay,bg;if(ay=O(this.length)){bg=this[0];for(var u=1;u<ay;++u){i"
++"f(u in this)this[u-1]=this[u];else delete this[u-1]}--ay};this.length=ay;return bg}),slice:c(function slice(aX,aY){var"
++" aM=[],ay=O(this.length);if((aX=M(aX))<0){aX+=ay;if(aX<0)aX=0}if(aY===void 0||(aY=M(aY))>ay)aY=ay;else if(aY<0)aY+=ay;"
++"for(var u=aX,b6=0;u<aY;++u,++b6)if(u in this)aM[b6]=this[u];aM.length=b6;return aM}),sort:c(function sort(bh){var bi=t"
++"his;function b5(bj,bk,bl){var bm=(bk in bj),bn=bj[bk];if(bl in bj)bj[bk]=bj[bl];else delete bj[bk];if(bm)bj[bl]=bn;els"
++"e delete bj[bl]};function bo(bj,bk,bl){if(!(bk in bj)&&!(bl in bj))return 0;else if(!(bk in bj))return 1;else if(!(bl "
++"in bj))return-1;else{var aM=bj[bk];var y=bj[bl];if(aM===void 0&&y===void 0)return 0;else if(aM===void 0)return 1;else "
++"if(y===void 0)return-1;else return bh(aM,y)}};function bp(bq,br){var bs=b5,bt=bo,bj=bi,bb,bu;for(--br;bq+1<br;bq=bu){v"
++"ar bv=br;bu=bq;bb=f((bu+bv)/2);while(bu<bv){while(bu<=bv&&bt(bj,bu,bb)<=0&&bt(bj,bv,bb)>=0){++bu;--bv}while(bu<=bv&&bt"
++"(bj,bv,bb)>0)--bv;while(bu<=bv&&bt(bj,bu,bb)<0)++bu;if(bb===bu||bb===bv)bb^=bv^bu;if(bu<bv)bs(bj,bu,bv)}bp(bq,bu)}if(b"
++"q<br&&bt(bj,bq,br)>0)bs(bj,bq,br)};if(bh===void 0){bh=function(aM,y){return((aM=P(aM))<(y=P(y))?-1:(aM>y?1:0))}};bp(0,"
++"this.length>>>0);return this}),splice:c(function splice(aX,bw){var aM=[],ay=O(this.length),ak,aB=(ak=arguments).length"
++",aY,bx,by;if((aX=M(aX))<0){aX+=ay;if(aX<0)aX=0}else if(aX>ay)aX=ay;if(aB==1||(aY=aX+M(bw))>ay)aY=ay;else if(aY<aX)aY=a"
++"X;for(var u=aX,b6=0;u<aY;++u,++b6)if(u in this)aM[b6]=this[u];aM.length=b6;if((bx=aB-2)<0)bx=0;if((by=aX+bx-aY)!==0){v"
++"ar bz=1,b6=aY;if(by>0){bz=-1;b6=ay-1}for(u=ay-aY;--u>=0;b6+=bz){if(b6 in this)this[b6+by]=this[b6];else delete this[b6"
++"+by]}for(u=ay;--u>=ay+by;)delete this[u]}for(u=2,b6=aX;u<aB;++u,++b6)this[b6]=ak[u];this.length=ay+by;return aM}),toLo"
++"caleString:Object.prototype.toLocaleString,toString:c(function toString(){Y(this,\"Array\",\"toString\");return this.j"
++"oin()}),unshift:c(function unshift(b7){var ay,ak,C=(ak=arguments).length;if(ay=O(this.length)){for(var u=ay;--u>=0;){i"
++"f(u in this)this[u+C]=this[u];else delete this[u+C]}}for(var u=0;u<C;++u)this[u]=ak[u];return(this.length=ay+C)}),forE"
++"ach:c(function forEach(bA){var J=Object(this),ay=O(J.length),H=arguments[1];if(typeof bA!==\"function\")throw TypeErro"
++"r();for(var bB=0;bB<ay;++bB)if(bB in J)bA.call(H,J[bB],bB,J)}),map:c(function map(bA){var J=Object(this),ay=O(J.length"
++"),H=arguments[1],aM=new Array(ay);if(typeof bA!==\"function\")throw TypeError();for(var bB=0;bB<ay;++bB)if(bB in J)aM["
++"bB]=bA.call(H,J[bB],bB,J);return aM}),filter:c(function filter(bA){var J=Object(this),ay=O(J.length),H=arguments[1],aM"
++"=[],br=0;if(typeof bA!==\"function\")throw TypeError();for(var bB=0;bB<ay;++bB)if(bB in J){var G=J[bB];if(bA.call(H,G,"
++"bB,J))aM[br++]=G}aM.length=br;return aM}),indexOf:c(function indexOf(bC){var ay=O(this.length),u=arguments[1];if(ay==="
++"0)return-1;if((u=M(u))<0){u+=ay;if(u<0)u=0}for(;u<ay;++u)if(u in this&&this[u]===bC)return u;return-1}),lastIndexOf:c("
++"function lastIndexOf(bC){var ay=O(this.length),u=arguments[1];if(ay===0)return-1;if(u===void 0)u=ay-1;else{u=M(u);if(u"
++"<0)u+=ay;if(u>=ay)u=ay-1}for(;u>=0;--u)if(u in this&&this[u]===bC)return u;return-1}),reduce:c(function reduce(bA){var"
++" J=Object(this),ay=O(J.length),bB=0,bD;if(typeof bA!==\"function\")throw TypeError();if(arguments.length>1)bD=argument"
++"s[1];else{while(bB<ay&&!(bB in J))++bB;if(bB>=ay)throw TypeError();bD=J[bB++]}for(;bB<ay;++bB)if(bB in J)bD=bA.call(vo"
++"id 0,bD,J[bB],bB,J);return bD}),reduceRight:c(function reduceRight(bA){var J=Object(this),ay=O(J.length),bB=ay-1,bD;if"
++"(typeof bA!==\"function\")throw TypeError();if(arguments.length>1)bD=arguments[1];else{while(bB>=0&&!(bB in J))--bB;if"
++"(bB<0)throw TypeError();bD=J[bB--]}for(;bB>=0;--bB)if(bB in J)bD=bA.call(void 0,bD,J[bB],bB,J);return bD}),every:c(fun"
++"ction every(bA){var J=Object(this),ay=O(J.length),H=arguments[1];if(typeof bA!==\"function\")throw TypeError();for(var"
++" bB=0;bB<ay;++bB)if(bB in J&&!bA.call(H,J[bB],bB,J))return false;return true}),some:c(function some(bA){var J=Object(t"
++"his),ay=O(J.length),H=arguments[1];if(typeof bA!==\"function\")throw TypeError();for(var bB=0;bB<ay;++bB)if(bB in J&&b"
++"A.call(H,J[bB],bB,J))return true;return false})});function bE(){var bF=a.localTimeDifference(14516064e5);var bG=a.loca"
++"lTimeDifference(14673312e5);return(bF>bG?bF:bG)}function bH(){var bF=a.localTimeDifference(14516064e5);var bG=a.localT"
++"imeDifference(14673312e5);return(bF<bG?bF:bG)}function bI(bJ){var a2=a.localTimeDifference(bJ);return(d(a2)?bH():a2)}f"
++"unction bK(bJ){return d(bJ)?bJ:bJ+bI(bJ)}function bL(R){if(i(R,\"class\")!==\"Date\")throw n(\"this is not a Date obje"
++"ct\")}function bM(R){bL(R);return i(R,\"value\")}function bN(R){return bK(bM(R))}function bO(R,G){bL(R);a.updateDateVa"
++"lue(R,G);return G}function bP(G){return d(G=bK(G))?\"Invalid Date\":(bQ(G)+' '+bR(G))}function bS(bT,C){return(bT%C+C)"
++"%C}function bU(bV,bW,bX,bY){return bV*36e5+bW*6e4+bX*1e3+bY}function bZ(bJ){return[bS(f(bJ/36e5),24),bS(f(bJ/6e4),60),"
++"bS(f(bJ/1e3),60),bS(bJ,1e3)]}function c0(bJ){return d(bJ)?bJ:(bJ-bI(bJ-bE()))}function c1(bJ){return bS(f(bJ/864e5)+4,"
++"7)}function c2(bJ){return bS(f(bJ/36e5),24)}function c3(bJ){return bS(f(bJ/6e4),60)}function c4(bJ){return bS(f(bJ/1e3"
++"),60)}function c5(bJ){return bS(bJ,1e3)}function c6(bJ){return(!e(bJ)||abs(bJ)>8.64e15?g:M(bJ))}function c7(bJ){return"
++" c0(c6(bJ))}function c8(bJ){bJ=f(bJ/864e5)+719468;var c9=M((bJ>=0?bJ:bJ-146096)/146097);var ca=bJ-c9*146097;var cb=M(("
++"ca-M(ca/1460)+M(ca/36524)-M(ca/146096))/365);var cc=cb+c9*400;var cd=ca-(365*cb+M(cb/4)-M(cb/100));var ce=M((5*cd+2)/1"
++"53);var aT=ce+(ce<10?2:-10);var cf=cd-M((153*ce+2)/5)+1;return[(cc+(aT<=1)),aT,cf]}function bQ(bJ){var cc,cg=c8(bJ);re"
++"turn(0<=(cc=cg[0])&&cc<=9999?a1(cc,4):(cc<0?\"-\":\"+\")+a1(abs(cc),6))+\"-\"+a1(cg[1]+1,2)+\"-\"+a1(cg[2],2)}function"
++" bR(bJ,bY){var ch=bZ(bJ);return a1(ch[0],2)+\":\"+a1(ch[1],2)+\":\"+a1(ch[2],2)+(bY?\".\"+a1($sub(ch[3],0,3),3):\"\")}"
++"function ci(cj,ck,cl){cj+=f(ck/12)-(bS(ck,12)<=1);var c9=M((cj>=0?cj:cj-399)/400);var cb=cj-c9*400;var cd=M((153*(ck+("
++"ck>1?-2:10))+2)/5)+cl-1;var ca=cb*365+M(cb/4)-M(cb/100)+cd;return(c9*146097+ca-719468)*864e5}function cm(bJ,C,aM){var "
++"u,cf=c8(bJ),aN=bS(bJ,864e5);for(u=0;u<aM.length;++u,++C)cf[C]=M(aM[u]);return j(ci,null,cf)+aN}function cn(bJ,C,aM){va"
++"r u,H=bZ(bJ),aN=f(bJ/864e5)*864e5;for(u=0;u<aM.length;++u,++C)H[C]=M(aM[u]);return j(bU,null,H)+aN}function co(cj,ck,c"
++"p,cq,cr,cs,bY){var aB=arguments.length;return ci((cj=M(cj))+(0<=cj&&cj<=99?1900:0),M(ck),(aB>2?M(cp):1))+bU(aB>3?M(cq)"
++":0,aB>4?M(cr):0,aB>5?M(cs):0,aB>6?M(bY):0)}function ct(cf){var bJ;return d(bJ=bM(cf))?null:bQ(bJ)+\"T\"+bR(bJ,true)+\""
++"Z\"}var cu,Date=a.distinctConstructor(function Date(){return bP(a.getCurrentTime())},function Date(cj,ck,cp,cq,cr,cs,b"
++"Y){var G,aB;if((aB=arguments.length)>=2&&aB<=7)G=c7(j(co,null,arguments));else if(aB===1)G=c6(typeof(G=a.toPrimitive(c"
++"j))===\"string\"?cu(G):+G);else G=a.getCurrentTime();return a.createWrapper(\"Date\",G,a.prototypes.Date)});Q(Date,{do"
++"ntEnum:true,readOnly:true,dontDelete:true},{prototype:a.prototypes.Date});Q(Date,{dontEnum:true},{parse:c(cu=function "
++"parse(B){var bJ,cc,u,aU,cv,cw,cx,u=0;function cy(ay){var G;for(G=0;--ay>=0;)if(\"0\"<=B[u]&&B[u]<=\"9\")G=G*10+(+B[u++"
++"]);else return g;return G}bJ=ci(((aU=B[u])===\"+\"||aU===\"-\")&&(++u,cc=cy(6),aU===\"-\"?-cc:cc)||cy(4),B[u]===\"-\"&"
++"&(++u,cy(2)-1)||0,B[u]===\"-\"&&(++u,cy(2))||1);bJ+=bU(((aU=B[u])===\"T\"||aU===\"t\"||aU===' ')&&(++u,cy(2))||0,B[u]="
++"==\":\"&&(++u,cy(2))||0,B[u]===\":\"&&(++u,cy(2))||0,B[u]===\".\"&&(++u,cy(3))||0);while((aU=B[u])!==void 0&&aU!==\"Z"
++"\"&&aU!==\"z\"&&aU!==\"+\"&&aU!==\"-\")++u;if(aU===\"Z\"||aU===\"z\")cv=0;else if(aU===\"+\"||aU===\"-\"){++u,cw=cy(2)"
++"*36e5,B[u]===\":\"&&++u,cw+=d(cx=cy(2))?0:cx*6e4,d(cw)||(cv=aU===\"-\"?-cw:cw)}return(cv===void 0?c0(bJ):bJ-cv)}),UTC:"
++"c(function UTC(cj,ck,cp,cq,cr,cs,bY){return c6(co(cj,ck,cp,cq,cr,cs,bY))}),now:c(function now(){return a.getCurrentTim"
++"e()})});Q(Date.prototype,{dontEnum:true},{constructor:Date,toISOString:c(function toISOString(){var B;if((B=ct(this))="
++"==null)throw m(\"Invalid time value\");return B}),toUTCString:c(function toUTCString(){var bJ;if(d(bJ=bM(this)))return"
++"\"Invalid Date\";return(bQ(bJ)+' '+bR(bJ))}),toString:c(function toString(){return bP(bM(this))}),toDateString:c(funct"
++"ion toDateString(){var a2;if(d(a2=bN(this)))return\"Invalid Date\";return bQ(a2)}),toTimeString:c(function toTimeStrin"
++"g(){var a2;if(d(a2=bN(this)))return\"Invalid Date\";return bR(a2)}),toLocaleString:Object.prototype.toLocaleString,toL"
++"ocaleDateString:c(function toLocaleDateString(){return this.toDateString()}),toLocaleTimeString:c(function toLocaleTim"
++"eString(){return this.toTimeString()}),valueOf:c(function valueOf(){return bM(this)}),getTime:c(function getTime(){ret"
++"urn bM(this)}),getFullYear:c(function getFullYear(){return c8(bN(this))[0]}),getUTCFullYear:c(function getUTCFullYear("
++"){return c8(bM(this))[0]}),getMonth:c(function getMonth(){return c8(bN(this))[1]}),getUTCMonth:c(function getUTCMonth("
++"){return c8(bM(this))[1]}),getDate:c(function getDate(){return c8(bN(this))[2]}),getUTCDate:c(function getUTCDate(){re"
++"turn c8(bM(this))[2]}),getDay:c(function getDay(){return c1(bN(this))}),getUTCDay:c(function getUTCDay(){return c1(bM("
++"this))}),getHours:c(function getHours(){return c2(bN(this))}),getUTCHours:c(function getUTCHours(){return c2(bM(this))"
++"}),getMinutes:c(function getMinutes(){return c3(bN(this))}),getUTCMinutes:c(function getUTCMinutes(){return c3(bM(this"
++"))}),getSeconds:c(function getSeconds(){return c4(bN(this))}),getUTCSeconds:c(function getUTCSeconds(){return c4(bM(th"
++"is))}),getMilliseconds:c(function getMilliseconds(){return c5(bN(this))}),getUTCMilliseconds:c(function getUTCMillisec"
++"onds(){return c5(bM(this))}),getTimezoneOffset:c(function getTimezoneOffset(){var G=bM(this);return(G-bK(G))/6e4}),set"
++"Time:c(function setTime(time){return bO(c6(+time))}),setMilliseconds:c(function setMilliseconds(bY){return bO(this,c7("
++"cn(bN(this),3,arguments)))}),setUTCMilliseconds:c(function setUTCMilliseconds(bY){return bO(this,c6(cn(bM(this),3,argu"
++"ments)))}),setSeconds:c(function setSeconds(B,bY){return bO(this,c7(cn(bN(this),2,arguments)))}),setUTCSeconds:c(funct"
++"ion setUTCSeconds(B,bY){return bO(this,c6(cn(bM(this),2,arguments)))}),setMinutes:c(function setMinutes(aT,B,bY){retur"
++"n bO(this,c7(cn(bN(this),1,arguments)))}),setUTCMinutes:c(function setUTCMinutes(aT,B,bY){return bO(this,c6(cn(bM(this"
++"),1,arguments)))}),setHours:c(function setHours(cz,aT,B,bY){return bO(this,c7(cn(bN(this),0,arguments)))}),setUTCHours"
++":c(function setUTCHours(cz,aT,B,bY){return bO(this,c6(cn(bM(this),0,arguments)))}),setDate:c(function setDate(cp){retu"
++"rn bO(this,c7(cm(bN(this),2,arguments)))}),setUTCDate:c(function setUTCDate(cp){return bO(this,c6(cm(bM(this),2,argume"
++"nts)))}),setMonth:c(function setMonth(ck,cp){return bO(this,c7(cm(bN(this),1,arguments)))}),setUTCMonth:c(function set"
++"UTCMonth(ck,cp){return bO(this,c6(cm(bM(this),1,arguments)))}),setFullYear:c(function setFullYear(cj,ck,cp){var G;retu"
++"rn bO(this,c7(cm(d(G=bM(this))?0:bK(G),0,arguments)))}),setUTCFullYear:c(function setUTCFullYear(cj,ck,cp){var G;retur"
++"n bO(this,c6(cm(d(G=bM(this))?0:G,0,arguments)))}),toJSON:c(function toJSON(){return ct(this)})});var G=1;var cA=G,cB="
++"(G<<=1),cC=(G<<=1),cD=(G<<=1),cE=(G<<=1),cF=(G<<=1),cG=(G<<=1),cH=(G<<=1),cI=(G<<=1),cJ=(G<<=1),cK=(G<<=1);var CC={};("
++"function(){function cL(cM,cN){for(var u in cN)CC[cN[u]]|=cM}cL(cI,\"^$.*+?()[]{}|\");cL(cE|cG|cD,\"0123456789\");cL(cG"
++"|cF|cD,\"abcdefABCDEF\");cL(cF|cD,\"ghijklmnopqrstuvwxyzGHIJKLMNOPQRSTUVWXYZ\");cL(cB|cC,\"\\n\\r\\u2028\\u2029\");cL("
++"cC,\" \\t\\v\\f\\xA0\");CC['_']|=cD;CC[\"undefined\"]|=cA;CC['']|=cA;cL(cH,\"fnrtv\");for(var u=32;u<=126;++u){var au="
++"a.fromCharCode(u);if(au!=='\"'&&au!=='\\\\')CC[a.fromCharCode(u)]|=cJ}var cO=[0,48,58,65,91,95,96,97,123,128];for(var "
++"u=cO.length-2;u>=0;u-=2)for(var b6=cO[u],bB=cO[u+1];b6<bB;++b6)CC[a.fromCharCode(b6)]|=cK})();function regExpCanonical"
++"ize(B){var H='',au,cf;if(!as)at();for(var u=0,ay=B.length;u<ay;++u)H+=((cf=as[au=B[u]])&&cf.length===1&&(au<'\\x80'||c"
++"f>='\\x80')?cf:au);return H}function cP(B,cQ,cR){var X=0,cS='',cT=0,cU=0,cV='',cW=0;function cX(cY,cM){return((CC[cY]&"
++"cM)!==0)}function cZ(B,cM){for(var u=B.length-1;u>=0;--u)if((CC[B[u]]&cM)===0)return false;return true}var d0={'D':[cE"
++",true],'d':[cE,false],'S':[cC,true],'s':[cC,false],'W':[cD,true],'w':[cD,false],'.':[cB,true]};function d1(d2){var C=d"
++"2;if(cX(B[X],cE)){C=0;do{C=C*10+(k(B,X)-48);++X}while(cX(B[X],cE))}return C}function d3(){var d4=0,d5=h,d6=true;switch"
++"(B[X]){case'*':++X;break;case'+':++X;d4=1;break;case'?':++X;d5=1;break;case'{':{var y=X;++X;if((d4=d5=d1(-1))<0){X=y;r"
++"eturn null}if(B[X]===','){++X;d5=d1(h)}if(B[X]!=='}'){X=y;return null}if(d4>d5){throw l(\"Min greater than max in regu"
++"lar expression quantifier\")}++X;break}default:return null}if(B[X]==='?'){++X;d6=false}return{d4:d4,d5:d5,d6:d6}}funct"
++"ion d7(au){if(cX(au,cJ))return au;return(au<='~'?\"\\\\x\":\"\\\\u\")+a1(ad(k(au,0),16),(au<='~'?2:4))}function d8(au)"
++"{return d7(cQ?regExpCanonicalize(au):au)}function d9(){var da,db,dc;if((da=B[X])==='\\\\'){switch(db=B[X+1]){case'0':{"
++"if(!cX(B[X+2],cE)){X+=2;return'\\0'}break}case'c':{if(cX(B[X+2],cF)){X+=3;return a.fromCharCode(k(B,X-1)&31)}break}cas"
++"e'x':case'u':{var C=(db==='x'?2:4);if(cZ(dc=$sub(B,X+2,X+2+C),cG)){X+=2+C;return a.fromCharCode(parseInt(dc,16))}break"
++"}default:{if(cX(db,cH)){X+=2;return eval('\"\\\\'+db+'\"')}else if(cX(db,cK)){X+=2;return db}break}}}else if(da){++X;r"
++"eturn da}}function dd(){var de=[],G,C=0;while(!cX(B[X],cI)&&(G=d9()))de[C++]=d8(G);return(de.length?de:null)}function "
++"df(){var G,dg,au;if((au=B[X])!==']'&&(G=d9()))return G;if(au==='\\\\'){if((au=B[X+1])==='b'){X+=2;return'\\b'}if(dg=d0"
++"[au]){X+=2;return dg}}}function dh(ba){return(ba===0?'p':((ba<0?'p':'p+')+ba))}function di(de,ba){if(de.length===0)ret"
++"urn\"true\";else if(de.length===1)return\"s[\"+dh(ba)+']===\"'+de[0]+'\"';else if(de.length===2)return\"s[\"+dh(ba)+']"
++"===\"'+de[0]+'\" && s['+dh(ba+1)+']===\"'+de[1]+'\"';else{for(var u=0,B='',a2=de.length;u<a2;++u)B+=de[u];return\"$mat"
++"ch(s,\"+dh(ba)+',\"'+B+'\")'}}function dj(aM,y){switch(aM){case\"false\":return\"false\";case\"true\":return y;default"
++":return(y===\"true\"?aM:aM+\" && \"+y)}}function dk(aM,y){switch(aM){case\"false\":return y;case\"true\":return\"true"
++"\";default:return(y===\"false\"?aM:aM+\" || \"+y)}}function dl(name,dm){cS+=\"\\tfunction \"+name+\"(p) { \"+dm+\" }\\"
++"n\"}function dn(dp,ba,dq,dr,ds,dt){var du='q'+(++cT),dv=(dt?\"var h=\"+dt+\",\":\"var \")+(ds.d4?\"b=p+\"+ds.d4+(dt?\""
++"*h\":\"\"):\"b=p\")+(ds.d5<h?\",e=p+\"+ds.d5+(dt?\"*h\":\"\"):\"\")+\"; \";if(dt)dv+=\"if (h<=0 || h!==h) return \"+dr"
++"+\"; \";if(ds.d6){dl(du,dv+\"while (\"+dj((ds.d5<h?\"p<e\":\"true\"),dq)+\") \"+(dt?\"p+=h\":\"++p\")+\"; while (\"+dj"
++"(\"p>=b\",\"!(\"+dr+\")\")+\") \"+(dt?\"p-=h\":\"--p\")+\"; return p>=b\")}else{dl(du,dv+\"while (\"+dk((ds.d4?\"p<b\""
++":\"false\"),\"!(\"+dr+\")\")+\") { if (\"+dk((ds.d5<h?\"p>=e\":\"false\"),\"!(\"+dq+\")\")+\") return false; \"+(dt?\""
++"p+=h\":\"++p\")+\" }; return true\")}return dj(dp,du+\"(\"+dh(ba)+\")\")}function dw(dp,dx,dy,dz){if(dx===null&&dy===d"
++"z){return\"return \"+dp}else{var dA='',dB='',dC='';if(dx!==null){dA+='r'+dx+\"=c\"+dx;dB='c'+dx+\"=p\";dC='c'+dx+\"=r"
++"\"+dx}if(dz!==void 0){for(var u=dy;u<dz;++u){var b6=u*2;if(dx!==null||u>dy){dA+=',';dC+=',';if(u===dy){dB+=','}}dA+='r"
++"'+b6+\"=c\"+b6;dB+='c'+b6+'=';dC+='c'+b6+\"=r\"+b6;if(u===dz-1){dB+=\"void 0\"}}}dp=dB+\", \"+dk(dp,'('+dC+\",false)\""
++");return\"var \"+dA+\"; return \"+dp}}function dD(aU,dg){return(dg[1]?'!':\"!!\")+\"(CC[\"+aU+\"]&\"+(dg[0]|(dg[1]?cA:"
++"0))+')'}function dE(ba,dF){var de,ds,dp=\"true\";dG:for(;;){if(de=dd()){if(ds=d3()){var dH=de[de.length-1];--de.length"
++";return dn(dj(dp,di(de,ba)),ba+de.length,di(dH,0),dE(0,dF),ds)}dp=dj(dp,di(de,ba));ba+=de.length}else{var au,dI,dr,dJ,"
++"dK;switch(au=B[X]){case'^':{++X;dI=dh(ba)+\"===0\";if(cR)dI='('+dk(dI,\"!!(CC[s[\"+dh(ba-1)+\"]]&\"+cB+')')+')';dp=dj("
++"dp,dI);break}case'$':{++X;dI=dh(ba)+\"===l\";if(cR)dI='('+dk(dI,\"!!(CC[s[\"+dh(ba)+\"]]&\"+cB+')')+')';dp=dj(dp,dI);b"
++"reak}case'[':{var dL=false,dM,dN,dO=\"false\";if(B[++X]==='^'){dL=true;++X}while(dM=df()){var y=X;if(B[X]==='-'&&(++X,"
++"dN=df())){if(typeof dM===\"string\"&&typeof dN===\"string\"&&dM<=dN){if(cQ&&(dM>'~'||dN>'~'||(regExpCanonicalize(dM)!="
++"=dM)!==(regExpCanonicalize(dN)!==dN))){dM=d7(dM);dN=d7(dN);dO=dk(dO,dj('upperToLower[c]>=\"'+dM+'\"','upperToLower[c]<"
++"=\"'+dN+'\"'))}else{dM=d8(dM);dN=d8(dN)}dO=dk(dO,dj('c>=\"'+dM+'\"','c<=\"'+dN+'\"'))}else{throw l(\"Invalid character"
++" class syntax in regular expression\")}}else if(typeof dM===\"string\"){X=y;dO=dk(dO,'c===\"'+d8(dM)+'\"')}else{dO=dk("
++"dO,dD('c',dM))}}if(B[X]!==']'){throw l(\"Invalid character class syntax in regular expression\")}++X;var du='k'+(++cT)"
++";dl(du,\"var c=s[p]; return \"+(dL?\"p!==l && !(\"+dO+')':dO));if(ds=d3()){return dn(dp,ba,du+'('+dh(0)+')',dE(0,dF),d"
++"s)}dp=dj(dp,du+'('+dh(ba)+')');++ba;break}case'\\\\':{var C;++X;if((C=d1(-1))>=0){if(C>cW)cW=C;C=(C-1)*2;ds=d3();var d"
++"t='c'+(C+1)+\"-c\"+C,dP=\"$match(s,\"+dh(ba)+\",$sub(s, c\"+C+\",c\"+(C+1)+\"))\";dr=dE(0,dF);var dQ='t'+(++cT);dl(dQ,"
++"\"return \"+dr);return ds?dn(dp,ba,dP,dQ+'('+dh(0)+')',ds,dt):dj(dp,'(c'+C+\"<c\"+(C+1)+\" ? \"+dj(dP,dQ+'('+dh(ba)+'+"
++"'+dt+')')+\" : \"+dQ+'('+dh(ba)+\"))\")}else if((au=B[X])==='b'||au==='B'){++X;dp=dj(dp,(au==='b'?\"!!((CC[s[\":\"!((C"
++"C[s[\")+dh(ba-1)+\"]]^CC[s[\"+dh(ba)+\"]])&\"+cD+')');break}}case'.':{var dg;if(!(dg=d0[au]))throw l(\"Invalid escape "
++"in regular expression\");++X;if(ds=d3()){return dn(dp,ba,dD(\"s[\"+dh(0)+']',dg),dE(0,dF),ds)}dp=dj(dp,dD(\"s[\"+dh(ba"
++")+']',dg));++ba;break}case'(':{var dR=++cT,dS='g'+dR,dT=dS+'('+dh(ba)+')',dU='j'+dR,dV=dU+'('+dh(ba)+')',dW=true,dX=fa"
++"lse,dY=false;++X;if(B[X]==='?'){switch(B[X+1]){case'!':dY=true;case'=':dX=true;case':':dW=false;X+=2}}var dZ=null,e0=n"
++"ull;if(dW){(e0=(dZ=(cU++)*2)+1);cV+=\",c\"+dZ+\",c\"+e0}var e1=cU,e2=e3(0,(dX?void 0:dU)),e4=cU;if((au=B[X])!==')'){th"
++"row l(au?\"Unterminated group in regular expression\":\"Invalid regular expression\")}++X;ds=(dX?null:d3());dr=dE(0,dF"
++");dK=e2;var e5='',e6=(ds&&ds.d5>1);if(e6&&(ds.d5<h||ds.d4>1)){cV+=\",n\"+dR+\"=0\";dK=((ds.d5<h)?dj(\"++n\"+dR+\"<=\"+"
++"ds.d5,dK):\"++n\"+dR+\", \"+dK);if(ds.d4>1){dK=dj(dK,'n'+dR+\">=\"+ds.d4);e5='n'+dR+'<'+ds.d4}dK=dk(dK,\"(--n\"+dR+\","
++"false)\")}if(dX){dJ=dU+'('+dh(0)+')';if(dY){dK=\"!(\"+dK+')';if(e1<e4){var e7='';for(var u=e1;u<e4;++u)e7+='c'+u*2+'='"
++";dJ='('+e7+\"void 0, \"+dJ+')'}}dK=dj(dK,dJ)}if(e6){cV+=\",p\"+dR;var e8='p'+dR+\"!=p\";dK=dj(e5?'('+dk(e8,e5)+')':e8,"
++"\"(p\"+dR+\"=p, \"+dK+')')}dl(dS,dw(dK,dZ,e1,e4));if(e6){var e9=dS+'('+dh(0)+')';dK=(ds.d6?dk(e9,dr):dk(dr,e9));dl(dU,"
++"dw(dK,e0));dJ=(ds.d4===0?dV:dT);dp=dj(dp,'(p'+dR+\"=void 0,\"+dJ+')')}else{dl(dU,dw(dr,e0));dp=((ds&&ds.d4===0)?dj(dp,"
++"(ds.d5===0?dV:'('+(ds.d6?dk(dT,dV):dk(dV,dT))+')')):dj(dp,dT))}return dp}default:break dG}}}switch(dF){case void 0:ret"
++"urn dp;case'':return dj(dp,\"(q=\"+dh(ba)+\",true)\");default:return dj(dp,dF+'('+dh(ba)+')')}}function e3(ba,dF){var "
++"dp=dE(ba,dF);if(B[X]==='|'){do{++X;dp=dk(dp,dE(ba,dF))}while(B[X]==='|');dp='('+dp+')'}return dp}var e2=e3(0,'');if(X<"
++"B.length)throw l(\"Invalid regular expression\");if(cW>cU)throw l(\"Invalid back reference in regular expression\");va"
++"r dp=\"(function(s, p) {\\n\";if(cQ)dp+=\"\\ts=regExpCanonicalize(s)\\n\";dp+=\"\\tvar l=s.length,q\";dp+=cV+\";\\n\"+"
++"cS+\"\\tif (\"+e2+\") return [p,q\";for(var u=0;u<cU*2;++u)dp+=\",c\"+u;dp+=\"];\\n})\";return dp}var ea={'g':\"global"
++"\",'i':\"ignoreCase\",'m':\"multiline\"},eb={},ec;function ed(b4,a7){a7=P(a7);var u;if((u=(b4.global?M(b4.lastIndex):0"
++"))>=0){var aW=i(b4,\"value\"),ay=a7.length,aT;for(;u<=ay;++u)if(aT=aW(a7,u)){if(b4.global)b4.lastIndex=aT[1];return aT"
++"}}b4.lastIndex=0}function aL(b4,a7){var aT,aM=null;if(aT=ed(b4,a7)){(aM=[]).input=a7;aM.index=aT[0];for(var b6=0;b6<aT"
++".length;b6+=2)aM[aM.length]=((aT[b6]===void 0)?void 0:$sub(a7,aT[b6],aT[b6+1]))}return aM}function ee(b4){return(b4.gl"
++"obal?'g':'')+(b4.ignoreCase?'i':'')+(b4.multiline?'m':'')}var RegExp=a.distinctConstructor(function RegExp(ef,eg){retu"
++"rn(i(ef,\"class\")===\"RegExp\"&&eg===void 0?ef:new a.createRegExp(ef,eg))},a.createRegExp=function RegExp(ef,eg){if(i"
++"(ef,\"class\")===\"RegExp\"){if(eg!==void 0)throw n(\"Cannot supply flags when constructing one RegExp from another\")"
++";eg=ee(ef);ef=ef.source}ef=(ef===void 0?'':P(ef));eg=(eg===void 0?'':P(eg));var eh={global:false,ignoreCase:false,mult"
++"iline:false,source:ef};for(var u=eg.length-1;u>=0;--u){var X;if(!(X=ea[eg[u]])||eh[X])throw l(\"Invalid regular expres"
++"sion flags\");eh[X]=true}var ei,ej;if(!(ej=eb[ei=ef+','+eh.ignoreCase+','+eh.multiline]))eb[ei]=ej=ah(cP(ef,eh.ignoreC"
++"ase,eh.multiline));var b4=a.createWrapper(\"RegExp\",ej,ec);Q(b4,{dontEnum:true,readOnly:true,dontDelete:true},eh);Q(b"
++"4,{dontEnum:true,dontDelete:true},{lastIndex:0});return b4});Q(RegExp,{dontEnum:true,readOnly:true,dontDelete:true},{p"
++"rototype:ec=RegExp.prototype});Q(RegExp.prototype,{dontEnum:true},{exec:c(function exec(a7){Y(this,\"RegExp\",\"exec\""
++");return aL(this,a7)}),test:c(function test(a7){Y(this,\"RegExp\",\"test\");return ed(this,a7)!==void 0}),toString:c(f"
++"unction toString(){Y(this,\"RegExp\",\"toString\");return'/'+this.source+'/'+ee(this)})});Q(b,{dontEnum:true},{Array:A"
++"rray,Boolean:Boolean,Date:Date,Function:Function,Math:a.createWrapper(\"Math\",void 0),Number:Number,Object:Object,Reg"
++"Exp:RegExp,String:String,isFinite:c(function isFinite(G){return e(+G)}),isNaN:c(function isNaN(G){return d(+G)}),JSON:"
++"a.createWrapper(\"JSON\",void 0),eval:a.evalFunction=c(function eval(bT){return a.eval(bT)}),parseFloat:c(function par"
++"seFloat(a7){return a.parseFloat(P(a7))}),parseInt:c(function parseInt(a7,af){a7=P(a7);var s=r,u=-1,ag=1;while(s[a7[++u"
++"]]===null);switch(a7[u]){case'-':ag=-1;case'+':++u}if(((af=N(af))===0||af===16)&&(a7[u]==='0'&&a7[u+1]==='x')){u+=2;af"
++"=16}if(af===0)af=10;else if(af<2||af>36)return g;var G=0,y,aG=a7.length,C;for(y=u;u<aG&&(C=s[a7[u]])!=null&&C<af;++u)G"
++"=G*af+C;return(y===u?g:G*ag)})});Q(b,{dontEnum:true,dontDelete:true},{NaN:g,Infinity:h,undefined:a.undefined});Q(Math,"
++"{readOnly:true,dontEnum:true,dontDelete:true},{E:2.718281828459045235360,LN10:2.302585092994045684018,LN2:0.6931471805"
++"599453094172,LOG10E:0.43429448190325182765113,LOG2E:1.442695040888963407360,PI:3.1415926535897932,SQRT1_2:0.7071067811"
++"865475244008,SQRT2:1.414213562373095048802});Q(Math,{dontEnum:true},{abs:c(abs=function abs(G){return((G=+G)<0?-G:G)})"
++",acos:c(function acos(G){return a.acos(+G)}),asin:c(function asin(G){return a.asin(+G)}),atan:c(function atan(G){retur"
++"n a.atan(+G)}),atan2:c(function atan2(cc,bT){return a.atan2(+cc,+bT)}),ceil:c(function ceil(G){return-f(-G)}),cos:c(fu"
++"nction cos(G){return a.cos(+G)}),exp:c(function exp(G){return a.exp(+G)}),floor:c(function floor(G){return f(+G)}),log"
++":c(function log(G){return a.log(+G)}),max:c(function max(bT,cc){var aT=-h,G,ak;for(var u=(ak=arguments).length-1;u>=0;"
++"--u)if((G=+ak[u])>aT||d(G))aT=G;return aT}),min:c(function min(bT,cc){var aT=h,G,ak;for(var u=(ak=arguments).length-1;"
++"u>=0;--u)if((G=+ak[u])<aT||d(G))aT=G;return aT}),pow:c(function pow(bT,cc){return a.pow(+bT,+cc)}),random:c(function r"
++"andom(){return a.random()}),round:c(function round(G){return(G===0.0?G:(G>=-0.5&&G<0.0?-0.0:f(G+0.5)))}),sin:c(functio"
++"n sin(G){return a.sin(+G)}),sqrt:c(function sqrt(G){return a.sqrt(+G)}),tan:c(function tan(G){return a.tan(+G)})});fun"
++"ction ek(name,prototype){return function(message){var aG;a.defineProperty(aG=a.createWrapper(\"Error\",name,prototype)"
++",\"message\",(message!==void 0?P(message):''),false,true,false);return aG}};(function(){var el=[\"Error\",\"EvalError"
++"\",\"RangeError\",\"ReferenceError\",\"SyntaxError\",\"TypeError\",\"URIError\"];for(var u=el.length;--u>=0;){var C,au"
++",X;a.defineProperty(b,C=el[u],au=ek(C,X=a.prototypes[C]),false,true,false);au.name=C;Q(au,{dontEnum:true,readOnly:true"
++",dontDelete:true},{prototype:X});Q(X,{dontEnum:true},{constructor:au});X.name=C}Q(Error.prototype,{dontEnum:true},{mes"
++"sage:'',toString:c(function toString(){return(this.name===void 0?\"Error\":this.name)+(this.message?(\": \"+this.messa"
++"ge):'')})});l=SyntaxError;m=RangeError;n=TypeError})();var em={'\\\\':\"\\\\\\\\\",'\"':\"\\\\\\\"\",'\\b':\"\\\\b\",'"
++"\\f':\"\\\\f\",'\\n':\"\\\\n\",'\\r':\"\\\\r\",'\\t':\"\\\\t\"};var en=61;Q(JSON,{dontEnum:true},{stringify:c(function"
++" stringify(ae,eo,ep){var eq=[],er=(typeof eo===\"function\"?eo:null),es='',et;if(i(eo,\"class\")===\"Array\"){et={};fo"
++"r(var u=eo.length;--u>=0;)et[eo[u]]=true}if(typeof ep===\"number\"||(typeof ep===\"object\"&&i(ep,\"class\")===\"Numbe"
++"r\")){ep=+ep;for(var u=(ep>10?10:ep);--u>=0;)es+=' '}else if(typeof ep===\"string\"||(typeof ep===\"object\"&&i(ep,\"c"
++"lass\")===\"String\")){es=$sub(P(ep),0,10)}function eu(B){var H='\"',ay=B.length;for(var u=0;u<ay;++u){var aU=B[u],ev;"
++"H+=((ev=em[aU])?ev:((aU>=' '&&aU<='~')?aU:\"\\\\u\"+a1(ad(k(aU,0),16),4)))}return H+'\"'}function a7(ei,ew,ex){var ae;"
++"if((ae=ew[ei])&&typeof ae===\"object\"&&typeof ae.toJSON===\"function\")ae=ae.toJSON(ei);if(er)ae=j(er,ew,[ei,ae]);var"
++" ey=(es?'\\n'+ex:'');if(typeof ae===\"object\"){switch(i(ae,\"class\")){case\"Number\":ae=+ae;break;case\"String\":ae="
++"P(ae);break;case\"Boolean\":ae=i(ae,\"value\");break}}switch(typeof ae){case\"object\":{if(!ae)return\"null\";var ay,B"
++"=new x,G;for(var u=(ay=eq.length);--u>=0;){if(eq[u]===ae)throw n(\"Cannot convert circular structure to JSON\")}if(ay>"
++"en)throw n(\"Structure too deeply nested for JSON conversion\");eq[ay]=ae;if(i(ae,\"class\")===\"Array\"){ay=ae.length"
++";for(var u=0;u<ay;++u){B.A((u==0?'[':',')+ey+es+(a7(u,ae,ex+es)||\"null\"))}B.A(ay==0?\"[]\":ey+']')}else{var ez=false"
++";for(var bB in(et?et:ae)){if(a.hasOwnProperty(ae,bB)){if(G=a7(bB,ae,ex+es)){B.A((ez?',':'{')+ey+es+eu(bB)+(es?\": \":'"
++":')+G);ez=true}}}B.A(ez?ey+'}':\"{}\")}--eq.length;return B.D()}case\"string\":return eu(ae);case\"number\":return(e(a"
++"e)?P(ae):\"null\");case\"boolean\":return P(ae)}}return a7('',{'':ae},'')}),parse:c(function parse(eA,eB){var eC=0;fun"
++"ction ep(H,X){var aU;while((aU=H[X])===' '||aU==='\\t'||aU==='\\r'||aU==='\\n')++X;return X}function eD(H,X){var aU;if"
++"(H[X]==='-')++X;if((aU=H[X])==='0')aU=H[++X];else if(aU>='1'&&aU<='9')do{aU=H[++X]}while(aU>='0'&&aU<='9');else return"
++";if(aU==='.'){if((aU=H[++X])<'0'||aU>'9')return;while((aU=H[++X])>='0'&&aU<='9')}if(aU==='e'||aU==='E'){if((aU=H[++X])"
++"==='-'||aU==='+')aU=H[++X];if(aU<'0'||aU>'9')return;while((aU=H[++X])>='0'&&aU<='9')}return X}function a7(H,X){var aU;"
++"if(H[X]!=='\"')return;++X;while((aU=H[X])!=='\"'&&aU>=' '){if(aU==='\\\\'){switch(H[++X]){default:return;case'\"':case"
++"'/':case'\\\\':case'b':case'f':case'n':case'r':case't':break;case'u':for(var u=4;--u>=0;)if(!(((aU=H[++X])>='0'&&aU<='"
++"9')||(aU>='a'&&aU<='f')||(aU>='A'&&aU<='F')))return;break}}++X}if(aU==='\"')return++X}function eE(H,X){if($match(H,X,"
++"\"true\")||$match(H,X,\"null\"))return X+4;else if($match(H,X,\"false\"))return X+5}function R(H,X){if(eC>en)throw n("
++"\"Structure too deeply nested for JSON conversion\");++eC;try{var aU,eF=false,eG=H[X],eH=(eG==='['?']':'}');X=ep(H,++X"
++");while((aU=H[X])!==eH&&aU){if(eF){if(aU!==',')return;X=ep(H,++X)}if(eG==='{'){if(!(X=a7(H,X))||H[X=ep(H,X)]!==':')ret"
++"urn;X=ep(H,++X)}if(!(eI=eJ[H[X]])||!(X=eI(H,X)))return;X=ep(H,X);eF=true}if(aU===eH)return++X}finally{--eC}}var eJ={'{"
++"':R,'[':R,'\"':a7,'t':eE,'f':eE,'n':eE,'-':eD,'0':eD,'1':eD,'2':eD,'3':eD,'4':eD,'5':eD,'6':eD,'7':eD,'8':eD,'9':eD};e"
++"A=P(eA);var X,eI;if((eI=eJ[eA[X=ep(eA,0)]])&&(X=eI(eA,X))&&ep(eA,X)===eA.length){var ae=eval('('+eA+')');if(typeof eB="
++"==\"function\"){function eK(ew,ei){var bB,G,J;if(typeof(J=ew[ei])===\"object\"&&J){for(bB in J){if(a.hasOwnProperty(J,"
++"bB)){if((G=eK(J,bB))!==void 0)J[bB]=G;else delete J[bB]}}}return j(eB,ew,[ei,J])}ae=eK({\"\":ae},\"\")}return ae}throw"
++" l(\"Error parsing JSON\")})});Q(Array,{dontEnum:true},{isArray:c(function isArray(J){return i(J,\"class\")===\"Array"
++"\"})});Q(Object,{dontEnum:true},{defineProperty:c(function defineProperty(J,X,cf){var bB=P(X);var U=!cf.writable,V=!cf"
++".enumerable,W=!cf.configurable;if(\"get\"in cf||\"set\"in cf){if(\"value\"in cf||\"writable\"in cf)throw TypeError();v"
++"ar eL=cf.get;var B=cf.set;if(eL!==undefined&&typeof eL!==\"function\")throw TypeError();if(B!==undefined&&typeof B!=="
++"\"function\")throw TypeError();a.defineProperty(J,bB,undefined,U,V,W,eL,B)}else{a.defineProperty(J,bB,cf.value,U,V,W)}"
++"}),getPrototypeOf:c(function getPrototypeOf(J){return i(J,\"prototype\")}),keys:c(function keys(J){if(J===undefined||J"
++"===null)throw TypeError();var eM=Object(J);var eN=[];var bB;for(bB in eM){if(Object.prototype.hasOwnProperty.call(eM,b"
++"B))eN[eN.length]=bB}return eN})});if(g.toString()!==\"NaN\")throw Error(\"Internal self test failed. Check C++ compile"
++"r options concerning IEEE 754 compliance.\")})"
+ ;
+ }
+diff --git a/tests/es5/arrayForEach.io b/tests/es5/arrayForEach.io
+new file mode 100644
+index 000000000..194d30765
+--- /dev/null
++++ b/tests/es5/arrayForEach.io
+@@ -0,0 +1,19 @@
++> total = 0;
++> [1, 2, 3].forEach(function(v){ total += v; });
++> print(total);
++< 6
++-
++> seen = [];
++> arr = [ , 5 ];
++> arr.forEach(function(v,i){ seen.push(i); });
++> print(seen.length);
++< 1
++-
++> print(seen[0]);
++< 1
++-
++> ctx = { sum: 0 };
++> [1,2].forEach(function(v){ this.sum += v; }, ctx);
++> print(ctx.sum);
++< 3
++-
+diff --git a/tests/es5/arrayIndexOf.io b/tests/es5/arrayIndexOf.io
+new file mode 100644
+index 000000000..261fda9a1
+--- /dev/null
++++ b/tests/es5/arrayIndexOf.io
+@@ -0,0 +1,23 @@
++> var a = [1, 2, 3, 2];
++-
++> print(a.indexOf(2));
++< 1
++-
++> print(a.indexOf(2, 2));
++< 3
++-
++> print(a.indexOf(4));
++< -1
++-
++> print(a.lastIndexOf(2));
++< 3
++-
++> print(a.lastIndexOf(2, 2));
++< 1
++-
++> print(a.lastIndexOf(2, -3));
++< 1
++-
++> print(a.lastIndexOf(2, -5));
++< -1
++-
+diff --git a/tests/es5/arrayMapFilter.io b/tests/es5/arrayMapFilter.io
+new file mode 100644
+index 000000000..47f314308
+--- /dev/null
++++ b/tests/es5/arrayMapFilter.io
+@@ -0,0 +1,28 @@
++> res = [1,2,3].map(function(v){ return v*2; });
++> print(res.join(','));
++< 2,4,6
++-
++> ctx = { add: 1 };
++> res = [1,2].map(function(v){ return v + this.add; }, ctx);
++> print(res[1]);
++< 3
++-
++> src = [ , 5 ];
++> res = src.map(function(v){ return v; });
++> print(0 in res);
++< false
++-
++> filtered = [1,2,3,4].filter(function(v){ return v % 2 === 0; });
++> print(filtered.join(','));
++< 2,4
++-
++> ctx = { max:2 };
++> filtered = [1,2,3].filter(function(v){ return v > this.max; }, ctx);
++> print(filtered[0]);
++< 3
++-
++> src = [ ,1,2 ];
++> filtered = src.filter(function(v){ return true; });
++> print(filtered.length);
++< 2
++-
+diff --git a/tests/es5/arrayReduce.io b/tests/es5/arrayReduce.io
+new file mode 100644
+index 000000000..8af505de1
+--- /dev/null
++++ b/tests/es5/arrayReduce.io
+@@ -0,0 +1,23 @@
++> print([1,2,3].reduce(function(a,b){ return a + b; }));
++< 6
++-
++> print([1,2,3].reduce(function(a,b){ return a + b; }, 1));
++< 7
++-
++> print([1,2,3].reduceRight(function(a,b){ return a - b; }));
++< 0
++-
++> print([1,2,3].reduceRight(function(a,b){ return a - b; }, 10));
++< 4
++-
++> calls = 0; arr = [ , 1 ];
++> arr.reduce(function(acc, v){ calls++; return acc; }, 0);
++> print(calls);
++< 1
++-
++> try { [].reduce(function(){}); } catch(e){ print(e instanceof TypeError); }
++< true
++-
++> try { [].reduceRight(function(){}); } catch(e){ print(e instanceof TypeError); }
++< true
++-
+diff --git a/tests/es5/arraySomeEvery.io b/tests/es5/arraySomeEvery.io
+new file mode 100644
+index 000000000..17f58c1f3
+--- /dev/null
++++ b/tests/es5/arraySomeEvery.io
+@@ -0,0 +1,21 @@
++> print([1,2,3].some(function(v){ return v > 2; }));
++< true
++-
++> print([1,2,3].some(function(v){ return v > 5; }));
++< false
++-
++> print([1,2,3].every(function(v){ return v < 4; }));
++< true
++-
++> print([1,2,3].every(function(v){ return v < 3; }));
++< false
++-
++> ctx = { t:2 };
++> print([1,2,3].some(function(v){ return v > this.t; }, ctx));
++< true
++-
++> calls = 0; arr = [ , 1 ];
++> arr.every(function(v,i){ calls++; return true; });
++> print(calls);
++< 1
++-
+diff --git a/tests/es5/dateNow.io b/tests/es5/dateNow.io
+new file mode 100644
+index 000000000..9251ce153
+--- /dev/null
++++ b/tests/es5/dateNow.io
+@@ -0,0 +1,8 @@
++> print(typeof Date.now);
++< function
++-
++> delta = Math.abs(Date.now() - new Date().getTime());
++-
++> print(delta < 10);
++< true
++-
+diff --git a/tests/es5/getterSetterProperties.io b/tests/es5/getterSetterProperties.io
+new file mode 100644
+index 000000000..2aed455c3
+--- /dev/null
++++ b/tests/es5/getterSetterProperties.io
+@@ -0,0 +1,26 @@
++> obj = { _v: 1, get value() { return this._v; }, set value(v) { this._v = v; }, get double() { return this._v * 2; }, set double(v) { this._v = v / 2; } };
++-
++> print(obj.value);
++< 1
++-
++> print(obj.double);
++< 2
++-
++> obj.double = 50;
++-
++> print(obj.value);
++< 25
++-
++> obj.value = 15;
++-
++> print(obj.double);
++< 30
++-
++> print(obj._v);
++< 15
++-
++> only = { _v: 0, get value() { return this._v; } };
++> only.value = 5;
++> print(only.value);
++< 0
++-
+diff --git a/tests/es5/objectKeys.io b/tests/es5/objectKeys.io
+new file mode 100644
+index 000000000..bdc0a7f68
+--- /dev/null
++++ b/tests/es5/objectKeys.io
+@@ -0,0 +1,22 @@
++> print(Object.keys({a:1,b:2}).sort().join(','));
++< a,b
++-
++> function F(){}
++> F.prototype.a = 1;
++> var o = new F();
++> o.b = 2;
++> print(Object.keys(o).join(','));
++< b
++-
++> var obj = {};
++> Object.defineProperty(obj, 'x', { value:1, enumerable:false });
++> obj.y = 2;
++> print(Object.keys(obj).join(','));
++< y
++-
++> print(Object.keys('hi').length);
++< 2
++-
++> try { Object.keys(null); } catch(e){ print(e instanceof TypeError); }
++< true
++-
+diff --git a/tests/es5/strictArgumentsObject.io b/tests/es5/strictArgumentsObject.io
+new file mode 100644
+index 000000000..da3fb355d
+--- /dev/null
++++ b/tests/es5/strictArgumentsObject.io
+@@ -0,0 +1,8 @@
++> function f(a){ "use strict"; arguments[0] = 2; return a === 1 && arguments[0] === 2; }
++> print(f(1))
++< true
++-
++> function g(a){ "use strict"; a = 3; return arguments[0] === 1; }
++> print(g(1))
++< true
++-
+diff --git a/tests/es5/strictDeleteIdentifier.io b/tests/es5/strictDeleteIdentifier.io
+new file mode 100644
+index 000000000..8d859e9d6
+--- /dev/null
++++ b/tests/es5/strictDeleteIdentifier.io
+@@ -0,0 +1,7 @@
++> eval("\"use strict\"; var x = 1; delete x;")
++! !!!! SyntaxError: Deleting identifier in strict code
++-
++> function f(){ "use strict"; var y; delete y; }
++! !!!! Line: 1
++! !!!! SyntaxError: Deleting identifier in strict code
++-
+diff --git a/tests/es5/strictDuplicateParam.io b/tests/es5/strictDuplicateParam.io
+new file mode 100644
+index 000000000..60ae8255e
+--- /dev/null
++++ b/tests/es5/strictDuplicateParam.io
+@@ -0,0 +1,11 @@
++> function f(a, a){ "use strict"; }
++! !!!! Line: 1
++! !!!! SyntaxError: Duplicate parameter name not allowed in strict code
++-
++> function g(a, a){ return a; }
++> print(g(1))
++< undefined
++-
++> eval("\"use strict\"; function h(a, a){ return a; }")
++! !!!! SyntaxError: Duplicate parameter name not allowed in strict code
++-
+diff --git a/tests/es5/strictEvalArgsBinding.io b/tests/es5/strictEvalArgsBinding.io
+new file mode 100644
+index 000000000..72f759752
+--- /dev/null
++++ b/tests/es5/strictEvalArgsBinding.io
+@@ -0,0 +1,6 @@
++> eval("\"use strict\"; var eval = 0;")
++! !!!! SyntaxError: Illegal use of eval or arguments in strict code
++-
++> eval("\"use strict\"; function arguments(){}");
++! !!!! SyntaxError: Illegal use of eval or arguments in strict code
++-
+diff --git a/tests/es5/strictEvalScope.io b/tests/es5/strictEvalScope.io
+new file mode 100644
+index 000000000..71ea5d58e
+--- /dev/null
++++ b/tests/es5/strictEvalScope.io
+@@ -0,0 +1,4 @@
++> function f(){ "use strict"; eval("1"); }
++! !!!! Line: 1
++! !!!! SyntaxError: Illegal use of eval or arguments in strict code
++-
+diff --git a/tests/es5/strictImplicitGlobal.io b/tests/es5/strictImplicitGlobal.io
+new file mode 100644
+index 000000000..39614742d
+--- /dev/null
++++ b/tests/es5/strictImplicitGlobal.io
+@@ -0,0 +1,7 @@
++> eval("\"use strict\"; implicit = 1;")
++! !!!! ReferenceError: implicit is not defined
++-
++> f=function(){ "use strict"; implicit2 = 1; }
++> f()
++! !!!! ReferenceError: implicit2 is not defined
++-
+diff --git a/tests/es5/strictThisBinding.io b/tests/es5/strictThisBinding.io
+new file mode 100644
+index 000000000..117112865
+--- /dev/null
++++ b/tests/es5/strictThisBinding.io
+@@ -0,0 +1,8 @@
++> f=function(){ "use strict"; return this===undefined; }
++> print(f())
++< true
++-
++> g=function(){ return this===undefined; }
++> print(g())
++< false
++-
+diff --git a/tests/es5/strictWithStatement.io b/tests/es5/strictWithStatement.io
+new file mode 100644
+index 000000000..362f7bcca
+--- /dev/null
++++ b/tests/es5/strictWithStatement.io
+@@ -0,0 +1,7 @@
++> eval("\"use strict\"; with({}){}")
++! !!!! SyntaxError: "with" is not allowed in strict code
++-
++> function f(){ "use strict"; with({}){} }
++! !!!! Line: 1
++! !!!! SyntaxError: "with" is not allowed in strict code
++-
+diff --git a/tests/es5/stringTrim.io b/tests/es5/stringTrim.io
+new file mode 100644
+index 000000000..9ea2d974a
+--- /dev/null
++++ b/tests/es5/stringTrim.io
+@@ -0,0 +1,6 @@
++> print(" \tfoo \n".trim())
++< foo
++-
++> print("\u00A0bar\u00A0".trim())
++< bar
++-
+diff --git a/tests/es5/stringTrimLeftRight.io b/tests/es5/stringTrimLeftRight.io
+new file mode 100644
+index 000000000..16d13ba3e
+--- /dev/null
++++ b/tests/es5/stringTrimLeftRight.io
+@@ -0,0 +1,14 @@
++> var s = " \tfoo \n";
++-
++> print(s.trimLeft().charCodeAt(0));
++< 102
++-
++> print(s.trimLeft().charCodeAt(s.trimLeft().length - 1));
++< 10
++-
++> print(s.trimRight().charCodeAt(0));
++< 32
++-
++> print(s.trimRight().charCodeAt(s.trimRight().length - 1));
++< 111
++-
diff --git a/tools/stdlibMinifier.ppeg b/tools/stdlibMinifier.ppeg
index 122dd41..c96b519 100644
--- a/tools/stdlibMinifier.ppeg
+++ b/tools/stdlibMinifier.ppeg
@@ -1,39 +1,46 @@
 {
-    $$parser.nextName = '9';
     $$parser.symbolChars = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
     $$parser.createNextName => {
+        defaults(@[$$parser.state].nextName, '9');
         for (; {
-            for ($nn = $$parser.nextName; {
+            for ($nn = [$$parser.state].nextName; {
                     $nn !== '' && {
                         $nc = $$parser.symbolChars{find($$parser.symbolChars, right($nn, 1)) + 1};
                         $nc === ''
                     }
                 }; $nn = chop($nn, 1));
             if ($nn === '') {
-                $nn = 'a' # repeat('0', length($$parser.nextName));
+                $nn = 'a' # repeat('0', length([$$parser.state].nextName));
             } else {
                 $nn = chop($nn, 1) # $nc;
-                $nn #= repeat('0', length($$parser.nextName) - length($nn));
+                $nn #= repeat('0', length([$$parser.state].nextName) - length($nn));
             };
-            $$parser.nextName = $nn;
-            exists(@$$parser.preserved[$nn])
+            [$$parser.state].nextName = $nn;
+            exists(@[$$parser.state].preserved[$nn])
         }; );
-        ( $$parser.nextName )
+        ( [$$parser.state].nextName )
     };
 
     $$parser.rename => {
         args(@$s);
-        if (!exists(@$$parser.preserved[$s])) {
-            if (!exists(@$$parser.renames[$s])) {
-                $$parser.renames[$s] = $$parser.createNextName();
+        if (!exists(@[$$parser.state].preserved[$s])) {
+            if (!exists(@[$$parser.state].renames[$s])) {
+                [$$parser.state].renames[$s] = $$parser.createNextName();
             };
-            $s = $$parser.renames[$s];
+            $s = [$$parser.state].renames[$s];
         };
         ( $s )
     };
+
+    $$parser.preserve => {
+        args(@$s);
+        if (exists($r = @[$$parser.state].preserved[$s])) throw('already preserved: ' # $s);
+        if (exists(@[$$parser.state].renames[$s])) throw('preserved word: ' # $s # ' used before preservation');
+        [$r] = true;
+    }
 }
 
-root            <-                                          { $$ = '' }
+root            <-                                          { $$parser.state = @$$; $$ = '' }
                     (ws
 # can't differentiate regexp literal / from two divisions y / x / z without more advanced parsing, so lets not use regexp literals in stdlib
 #                   / c=(qString / aString / regexp)        { $$ #= $c }
@@ -43,7 +50,7 @@ root            <-                                          { $$ = '' }
                         )*
                     / ';' ws '}'                            { $$ #= '}'}
                     / c=.                                   { $$ #= $c }
-                    )* eof
+                    )* eof                                  { [$$parser.state].output = $$ }
 
 token           <-  n=number                                { $$ = $n }
                     / i=identifier                          { $$ = $$parser.rename($i) }
@@ -57,7 +64,7 @@ comment         <-  '/*' (preserveList / !'*/' .)* '*/' / "//" (preserveList / !
 
 preserveList    <-  '@preserve:' [ \t]* preserveId ([ \t]* ',' [ \t]* preserveId)*
 
-preserveId      <-  i=identifier                            { $$parser.preserved[$i] = true }
+preserveId      <-  i=identifier                            { $$parser.preserve($i); }
 
 identifier      <-  [$a-zA-Z_0-9]+
 
diff --git a/tools/stdlibToCpp.pika b/tools/stdlibToCpp.pika
index 7cba475..a2698af 100755
--- a/tools/stdlibToCpp.pika
+++ b/tools/stdlibToCpp.pika
@@ -1,7 +1,10 @@
 #! /usr/local/bin/PikaCmd
 
 include('stdlib.pika');
-run('./initPPEG.pika');
+include('debug.pika');
+include('systools.pika');
+// Use run.root from systools so paths resolve relative to this script regardless of CWD.
+run(run.root # 'initPPEG.pika');
 
 vargs(@exe,, @inputFile, @outputFile);
 defaults(@inputFile, 'stdlib.js', @outputFile, 'stdlibJS.cpp');
@@ -9,30 +12,54 @@ defaults(@inputFile, 'stdlib.js', @outputFile, 'stdlibJS.cpp');
 print(bake('Loading {inputFile}'));
 src = load(inputFile);
 
+// Probe optional ES5 source next to the base stdlib (no-op unless present).
+baseDir = dirOfPath(inputFile);
+es5path = baseDir # 'stdlibES5.js';
+hasES5 = (try(>es5src = load(es5path)) == void);
+
 print('Compiling parser');
 
-ok = ppeg.compileFunction(load('./stdlibMinifier.ppeg'), @minifier);
+ok = ppeg.compileFunction(load(run.root # 'stdlibMinifier.ppeg'), @minifier);
 if (!ok) throw("Error compiling the stdlib parser peg");
 
 print('Shrinking code');
 
-ok = minifier(src, @minified, @i);
+ok = minifier(src, @state, @i);
 if (!ok) throw("Failed parsing at offset " # i);
+minifiedBase = state.output;
+print(bake('Code shrunk from {length(src)} to {length(minifiedBase)}'));
 
-print(bake('Code shrunk from {length(src)} to {length(minified)}'));
-
-code = '';
-for (offset = 0; offset < length(minified); offset += n) {
-	for (n = min(length(minified) - offset, 118)
-			; { line = '"' # (escape("\n" # minified{offset:n}){3:}); length(line) > 120 }
+codeBase = '';
+for (offset = 0; offset < length(minifiedBase); offset += n) {
+	for (n = min(length(minifiedBase) - offset, 118)
+			; { line = '"' # (escape("\n" # minifiedBase{offset:n}){3:}); length(line) > 120 }
 			; --n);
-	code #= line # LF;
+	codeBase #= line # LF;
+};
+
+if (hasES5) {
+	ok = minifier(es5src, @state, @i2);
+	if (!ok) throw("Failed parsing ES5 at offset " # i2);
+	minifiedES5 = state.output;
+	print(bake('ES5 shrunk from {length(es5src)} to {length(minifiedES5)}'));
+
+	codeES5 = '';
+	for (o2 = 0; o2 < length(minifiedES5); o2 += n2) {
+		for (n2 = min(length(minifiedES5) - o2, 118)
+				; { w = '"' # (escape("\n" # minifiedES5{o2:n2}){3:}); length(w) > 120 }
+				; --n2);
+		codeES5 #= w # LF;
+	};
 };
 
 save(outputFile, bake(
 'namespace NuXJS {
 const char* STDLIB_JS =
---{code}--;
+--{codeBase}--;
+#if (!defined(NUXJS_ES5) || NUXJS_ES5)
+const char* STDLIB_ES5_JS =
+--{codeES5}--;
+#endif
 }
 ', '--{', '}--'));
 
