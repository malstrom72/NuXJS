{
    $$parser.symbolChars = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
    $$parser.createNextName => {
        defaults(@[$$parser.state].nextName, '9');
        for (; {
            for ($nn = [$$parser.state].nextName; {
                    $nn !== '' && {
                        $nc = $$parser.symbolChars{find($$parser.symbolChars, right($nn, 1)) + 1};
                        $nc === ''
                    }
                }; $nn = chop($nn, 1));
            if ($nn === '') {
                $nn = 'a' # repeat('0', length([$$parser.state].nextName));
            } else {
                $nn = chop($nn, 1) # $nc;
                $nn #= repeat('0', length([$$parser.state].nextName) - length($nn));
            };
            [$$parser.state].nextName = $nn;
            exists(@[$$parser.state].preserved[$nn])
        }; );
        ( [$$parser.state].nextName )
    };

    $$parser.rename => {
        args(@$s);
        if (!exists(@[$$parser.state].preserved[$s])) {
            if (!exists(@[$$parser.state].renames[$s])) {
                [$$parser.state].renames[$s] = $$parser.createNextName();
            };
            $s = [$$parser.state].renames[$s];
        };
        ( $s )
    };

    $$parser.preserve => {
        args(@$s);
        if (exists($r = @[$$parser.state].preserved[$s])) throw('already preserved: ' # $s);
        if (exists(@[$$parser.state].renames[$s])) throw('preserved word: ' # $s # ' used before preservation');
        [$r] = true;
    }
}

root            <-                                          { $$parser.state = @$$; $$ = '' }
                    (ws
# can't differentiate regexp literal / from two divisions y / x / z without more advanced parsing, so lets not use regexp literals in stdlib
#                   / c=(qString / aString / regexp)        { $$ #= $c }
                    / c=(qString / aString)                 { $$ #= $c }
                    / t:token                               { $$ #= $t }
                        (ws t:token                         { $$ #= ' ' # $t }
                        )*
                    / ';' ws '}'                            { $$ #= '}'}
                    / c=.                                   { $$ #= $c }
                    )* eof                                  { [$$parser.state].output = $$ }

token           <-  n=number                                { $$ = $n }
                    / i=identifier                          { $$ = $$parser.rename($i) }

number          <-  '0x' hex+
                    / ([0-9] [0-9]*) ('.' [0-9]+)? ( [eE][-+]? [0-9]+ )?

ws              <-  ([ \t\r\n] / comment)+

comment         <-  '/*' (preserveList / !'*/' .)* '*/' / "//" (preserveList / !eol .)* (eol / eof)

preserveList    <-  '@preserve:' [ \t]* preserveId ([ \t]* ',' [ \t]* preserveId)*

preserveId      <-  i=identifier                            { $$parser.preserve($i); }

identifier      <-  [$a-zA-Z_0-9]+

qString         <-  '"' ( !["\\\0-\37] . / escape )* '"'

aString         <-  "'" ( !['\\\0-\37] . / escape )* "'"

# regexp          <-  "/" ( ![/\\\0-\37] . / "\\" .)+ "/" identifier?

escape          <-  "\\" ( 'x' hex hex / 'u' hex hex hex hex / . )

hex             <-  [0-9a-fA-F]

eol             <-  "\r\n" / "\n" / "\r"

eof             <-  !.

