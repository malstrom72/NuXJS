#! /usr/local/bin/PikaCmd

include('stdlib.pika');
include('systools.pika');

// benchmark.pika <test(s)> <exe>|<rev-rev>|<rev>|makegold ignoregold

vargs(@me,, @tests, @exe, @ignoregold, @runs);
defaults(@ignoregold, '');
defaults(@runs, '5');
runs += 0;

if (!exists(@tests) || tests === '-') tests = '*.js'
else if (right(tests, 3) != '.js') tests #= '.js';

revs.n = 0;
makeGold = false;
doRevRange = false;
fromRev = toRev = '';
if (exists(@exe)) {
	if (exe === 'makegold') {
		makeGold = true;
		delete(@exe);
	} else {
		doRevRange = wildmatch(exe, '{[0-9]?*}[-:]{[0-9]?*}', @fromRev, @toRev);
		if (!doRevRange) {
			if (doRevRange = wildmatch(exe, '{[0-9]?*}', @fromRev)) toRev = fromRev;
		};
		if (doRevRange) {
			print('Listing revisions...');
			svnlog = pipe(bake("svn log -q -r{fromRev}:{toRev} svn://svn.elysian.se/nuedgesvn/NuXJS/trunk src/NuXJS.h src/NuXJS.cpp src/stdlibJS.cpp"));
			tokenize(svnlog, >{ if (wildmatch($0, 'r{[0-9]?*} *', @r)) append(@revs, r); });
			s = '';
			iterate(@revs, >s #= (if (s != '') ',') # $2);
			print('Revs: ' # s);
			delete(@exe);
		};
	};
};
if (revs.n == 0) append(@revs, '');

if (PLATFORM === 'UNIX') {
	defaults(@exe, './output/NuXJS -s -t');
	// TIME_COMMAND_FORMAT = '(time -p {exe} benchmarks/{fn} >{outPath}) 2>{timePath}';
	TIME_COMMAND_FORMAT = '{exe} -t benchmarks/{fn} >{outPath} 2>{timePath}';
	BUILD_CPP_COMMAND = './tools/BuildCpp.sh release x64 ./output/NuXJS tools/NuXJSREPL.cpp src/NuXJS.cpp src/stdlibJS.cpp';
	parseTimeOutput = function { a = $1; tokenize($0, >append(a, $0)); }
} else if (PLATFORM == 'WINDOWS') {
	defaults(@exe, '.\output\NuXJS -s -t');
	// TIME_COMMAND_FORMAT = 'timeit -s {exe} benchmarks/{fn} >{outPath} 2>{timePath}';
	// parseTimeOutput = function { a = $1; count = 0; tokenize($0, >if (count++ >= 3 && $0 != void) append(a, $0{20:})); [a][0] = 'E=' # [a][0]; [a][1] = 'P=' # [a][1];}
	TIME_COMMAND_FORMAT = '{exe} -t benchmarks/{fn} >{outPath} 2>{timePath}';
	BUILD_CPP_COMMAND = '.\tools\BuildCpp.cmd release x64 .\output\NuXJS tools\NuXJSREPL.cpp src\NuXJS.cpp src\stdlibJS.cpp';
	parseTimeOutput = function { a = $1; tokenize($0, >append(a, $0)); }
} else {
	throw("EH!?");
};

tempDir = makeTempDir();
outPath = tempDir # 'out';
timePath = tempDir # 'time';
overallMedians.n = 0;
timeLines.n = 0;

names.n = 0;
widths.n = 0;
dir("benchmarks" # DIR_SLASH # tests, >{
fn = $0;
name = basenameOfPath(fn);
append(@names, name);
defaults(@widths[name], length(name));
timeLines[name].n = 0;
});

iterate(@revs, >{
rev = $2;
revKey = rev;
if (revKey == '') revKey = 'current';
err = try(>{
if (rev != '' && rev !== void) {
			print('Checking out ' # rev # '...');
			pipe('svn update -r' # rev # ' src\NuXJS.cpp src\NuXJS.h src\stdlib.js src\stdlibJS.cpp');
			print('Building...');
			pipe(BUILD_CPP_COMMAND);
			print('Done.');
		};
		iterate(@names, >{
			name = $2;
			fn = name # '.js';
				print(name);
				print(repeat('-', length(name)));
                                cmd = bake(TIME_COMMAND_FORMAT);
                                runLines.n = 0;
                                timeSamples.n = 0;
for (i = 0; i < runs; ++i) {
                                        rc = system(cmd);
                                        times = load(timePath);
                                        if (times == 'FAIL') break;
                                        runLines.n = 0;
                                        parseTimeOutput(times, @runLines);
                                        append(@timeSamples, evaluate(runLines[0]{0:length(runLines[0]) - 1}));
                                        if (i == 0) {
                                                output = load(outPath);
                                                output = replace(output, "\r\n", "\n");
                                                goldenFile = bake('benchmarks{DIR_SLASH}golden{DIR_SLASH}{name}.txt');
                                                if (makeGold) {
                                                        save(goldenFile, output);
                                                } else if (ignoregold !== 'ignoregold') {
                                                        expected = load(goldenFile);
                                                        if (output != expected) {
                                                                times = 'FAIL';
                                                                save('.\\failed.txt', output);
                                                                save('.\\expected.txt', expected);
                                                        }
                                                };
                                                mem1 = runLines[1];
                                                mem2 = runLines[2];
                                                mem3 = runLines[3];
                                        }
};
                                timeLines[name][revKey].n = 0;
                                a = @timeLines[name][revKey];
                                if (times == 'FAIL') {
                                        print('FAIL');
                                        append(a, 'FAIL');
                                } else {
                                        sort(@timeSamples);
					m = floor(timeSamples.n / 2);
					if ((timeSamples.n % 2) != 0) medianTime = timeSamples[m]
					else medianTime = (timeSamples[m - 1] + timeSamples[m]) / 2;
					medianStr = medianTime # 's';
					append(a, medianStr);
					append(a, mem1);
					append(a, mem2);
					append(a, mem3);
					iterate(a, >widths[name] = max(widths[name], length($2)));
                                       print('median: ' # medianStr);
                                }
                });
        });
        if (err != void && err != '') print(err);
});

prune(@lines);
lines[0] = '        ';
lines[1] = '        ';
labels.n = 0;
append(@labels, 'median');
append(@labels, 'mem1');
append(@labels, 'mem2');
append(@labels, 'mem3');
for (l = 0; l < labels.n; ++l) lines[l + 2] = labels[l] # repeat(' ', 8 - length(labels[l]));
lines.n = 2 + labels.n;
iterate(@names, >{
       name = $2;
       lines[0] #= name # repeat(' ', widths[name] - length(name)) # '  ';
       lines[1] #= repeat('-', widths[name]) # '  ';
       iterate(@revs, >{
               rev = $2;
               revKey = rev;
               if (revKey == '') revKey = 'current';
               for (l = 0; l < 4; ++l) {
                       r = @timeLines[name][revKey][l];
                       if (exists(r)) { s = [r]; } else { s = ''; };
                       lines[l + 2] #= s # repeat(' ', widths[name] - length(s)) # '  ';
               }
       });
});
overallMedians.n = 0;
revKey = 'current';
iterate(@names, >{
       r = @timeLines[$2][revKey][0];
       if (exists(r)) { medianStr = [r]; } else { medianStr = void; };
       if (medianStr != void && medianStr != 'FAIL') append(@overallMedians, evaluate(medianStr{0:length(medianStr) - 1}));
});
iterate(@lines, >print($2));

if (overallMedians.n != 0) {
sort(@overallMedians);
m = floor(overallMedians.n / 2);
if ((overallMedians.n % 2) != 0) allMedian = overallMedians[m]
else allMedian = (overallMedians[m - 1] + overallMedians[m]) / 2;
print('median of all tests: ' # allMedian # 's');
}
