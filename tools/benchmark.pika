#! /usr/local/bin/PikaCmd

include('stdlib.pika');
include('systools.pika');
include('debug.pika');

// benchmark.pika <test(s)> <exe>|makegold ignoregold

vargs(@me,, @tests, @exe, @ignoregold, @runs);
defaults(@ignoregold, '');
defaults(@runs, 5);

if (!exists(@tests) || tests === '-') tests = '*.js'
else if (right(tests, 3) != '.js') tests #= '.js';

makeGold = false;
if (exists(@exe) && exe === 'makegold') {
	makeGold = true;
	delete(@exe);
};

if (PLATFORM === 'UNIX') {
	defaults(@exe, './output/NuXJS -s -t');
	// TIME_COMMAND_FORMAT = '(time -p {exe} benchmarks/{fn} >{outPath}) 2>{timePath}';
	TIME_COMMAND_FORMAT = '{exe} -t benchmarks/{fn} >{outPath} 2>{timePath}';
	BUILD_CPP_COMMAND = './tools/BuildCpp.sh release x64 ./output/NuXJS tools/NuXJSREPL.cpp src/NuXJS.cpp src/stdlibJS.cpp';
	parseTimeOutput = function { a = $1; tokenize($0, >append(a, $0)); }
} else if (PLATFORM == 'WINDOWS') {
	defaults(@exe, '.\output\NuXJS -s -t');
	// TIME_COMMAND_FORMAT = 'timeit -s {exe} benchmarks/{fn} >{outPath} 2>{timePath}';
	// parseTimeOutput = function { a = $1; count = 0; tokenize($0, >if (count++ >= 3 && $0 != void) append(a, $0{20:})); [a][0] = 'E=' # [a][0]; [a][1] = 'P=' # [a][1];}
	TIME_COMMAND_FORMAT = '{exe} -t benchmarks/{fn} >{outPath} 2>{timePath}';
	BUILD_CPP_COMMAND = '.\tools\BuildCpp.cmd release x64 .\output\NuXJS tools\NuXJSREPL.cpp src\NuXJS.cpp src\stdlibJS.cpp';
	parseTimeOutput = function { a = $1; tokenize($0, >append(a, $0)); }
} else {
	throw("EH!?");
};

tempDir = makeTempDir();
outPath = tempDir # 'out';
timePath = tempDir # 'time';

names.n = 0;
widths.n = 0;
dir("benchmarks" # DIR_SLASH # tests, >{
	fn = $0;
	name = basenameOfPath(fn);
	append(@names, name);
	defaults(@widths[name], length(name));
	timeLines[name].n = 0;
});

err = try(>{
	iterate(@names, >{
		name = $2;
		fn = name # '.js';
		print(name);
		print(repeat('-', length(name)));
		cmd = bake(TIME_COMMAND_FORMAT);
		runLines.n = 0;
		timeSamples.n = 0;
		times = '';
		for (i = 0; i < runs && times !== 'FAIL'; ++i) {
			rc = system(cmd);
			times = load(timePath);
			if (times !== 'FAIL') {
				runLines.n = 0;
				parseTimeOutput(times, @runLines);
				print(runLines[0]);
				append(@timeSamples, chop(runLines[0], 1));
				mem1 = runLines[1];
				mem2 = runLines[2];
				mem3 = runLines[3];
			}
		};
		output = load(outPath);
		output = replace(output, "\r\n", "\n");
		goldenFile = bake('benchmarks{DIR_SLASH}golden{DIR_SLASH}{name}.txt');
		if (makeGold) {
			save(goldenFile, output);
		} else if (ignoregold !== 'ignoregold') {
			expected = load(goldenFile);
			if (output !== expected) {
				times = 'FAIL';
				save("output" # DIR_SLASH # 'failed.txt', output);
				save("output" # DIR_SLASH # 'expected.txt', expected);
			}
		};
		a = @timeLines[name];
		if (times == 'FAIL') {
			print(LF # '!!! FAIL !!!' # LF);
			append(a, 'FAIL');
		} else {
			sort(@timeSamples);
			m = floor(timeSamples.n / 2);
			if ((timeSamples.n % 2) != 0) medianTime = timeSamples[m]
			else medianTime = (timeSamples[m - 1] + timeSamples[m]) / 2;
			medianString = medianTime # 's';
			append(a, medianString);
			append(a, mem1);
			append(a, mem2);
			append(a, mem3);
			iterate(a, >widths[name] = max(widths[name], length($2)));
			print('median: ' # medianString # LF);
		}
	});
});
if (err != void) print(err);

prune(@lines);
lines[0] = '        ';
lines[1] = '        ';
compose(@labels, 'median', 'mem1', 'mem2', 'mem3');
for (l = 0; l < labels.n; ++l) lines[l + 2] = labels[l] # repeat(' ', 8 - length(labels[l]));
overallMedians.n = 0;
iterate(@names, >{
	name = $2;
	lines[0] #= name # repeat(' ', widths[name] - length(name)) # '  ';
	lines[1] #= repeat('-', widths[name]) # '  ';
	for (l = 0; l < 4; ++l) {
		s = coalesce(@timeLines[name][l], '');
		lines[l + 2] #= s # repeat(' ', widths[name] - length(s)) # '  ';
	};
	lines.n = l + 2;
	append(@overallMedians, chop(timeLines[name][0], 1));
});
iterate(@lines, >print($2));

wipeTempDir(tempDir);
if (overallMedians.n != 0) {
	sort(@overallMedians);
	m = floor(overallMedians.n / 2);
	if ((overallMedians.n % 2) != 0) allMedian = overallMedians[m]
	else allMedian = (overallMedians[m - 1] + overallMedians[m]) / 2;
	print(LF # 'median of all tests: ' # allMedian # 's');
}

