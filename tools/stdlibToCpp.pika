#! /usr/local/bin/PikaCmd

include('stdlib.pika');
include('systools.pika');
// Use run.root from systools so paths resolve relative to this script regardless of CWD.
run(run.root # 'initPPEG.pika');

vargs(@exe,, @inputFile, @outputFile);
defaults(@inputFile, 'stdlib.js', @outputFile, 'stdlibJS.cpp');

print(bake('Loading {inputFile}'));
src = load(inputFile);

// Probe optional ES5 source next to the base stdlib (no-op unless present).
baseDir = dirOfPath(inputFile);
es5path = baseDir # 'stdlibES5.js';
hasES5 = (try(>es5src = load(es5path)) == void);

print('Compiling parser');

ok = ppeg.compileFunction(load(run.root # 'stdlibMinifier.ppeg'), @minifier);
if (!ok) throw("Error compiling the stdlib parser peg");

print('Shrinking code');

ok = minifier(src, @minifiedBase, @i);
if (!ok) throw("Failed parsing at offset " # i);
print(bake('Code shrunk from {length(src)} to {length(minifiedBase)}'));

if (hasES5) {
	ok = minifier(es5src, @minifiedES5, @i2);
	if (!ok) throw("Failed parsing ES5 at offset " # i2);
	print(bake('ES5 shrunk from {length(es5src)} to {length(minifiedES5)}'));
};

codeBase = '';
for (offset = 0; offset < length(minifiedBase); offset += n) {
	for (n = min(length(minifiedBase) - offset, 118)
			; { line = '"' # (escape("\n" # minifiedBase{offset:n}){3:}); length(line) > 120 }
			; --n);
	codeBase #= line # LF;
};

if (hasES5) {
	codeES5 = '';
	for (o2 = 0; o2 < length(minifiedES5); o2 += n2) {
		for (n2 = min(length(minifiedES5) - o2, 118)
				; { w = '"' # (escape("\n" # minifiedES5{o2:n2}){3:}); length(w) > 120 }
				; --n2);
		codeES5 #= w # LF;
	};
};

save(outputFile, bake(
'namespace NuXJS {
const char* STDLIB_JS =
--{codeBase}--;
#if (NUXJS_ES5)
const char* STDLIB_ES5_JS =
--{codeES5}--;
#endif
}
', '--{', '}--'));

print(bake('Updated {outputFile}'));
