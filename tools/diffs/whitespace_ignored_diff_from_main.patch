--- /tmp/main_NuXJS.cpp	2025-09-03 12:27:46.009622667 +0000
+++ /tmp/NuXJS_es3.cpp	2025-09-03 12:27:44.277641768 +0000
@@ -180,6 +180,7 @@
 		, E_RROR_STRING("Error"), F_UNCTION_STRING("Function"), N_UMBER_STRING("Number"), O_BJECT_STRING("Object")
 		, S_TRING_STRING("String");
 
+
 static const String ANONYMOUS_STRING("anonymous"), ARGUMENTS_STRING("arguments")
 		, BRACKET_OBJECT_STRING("[object "), CALLEE_STRING("callee")
 		, CANNOT_CONVERT_TO_OBJECT_STRING("Cannot convert undefined or null to object")
@@ -1316,6 +1317,7 @@
 	return NONEXISTENT;
 }
 
+
 bool Object::setProperty(Runtime& rt, const Value& key, const Value& v) {
 	if (updateOwnProperty(rt, key, v)) {
 		return true;
@@ -1330,6 +1332,7 @@
 	return setOwnProperty(rt, key, v);
 }
 
+
 Enumerator* Object::getPropertyEnumerator(Runtime& rt) const {
 	Heap& heap = rt.getHeap();
 	Enumerator* enumerator = getOwnPropertyEnumerator(rt);
@@ -1482,6 +1485,8 @@
 	return update(insert(key.toString(rt.getHeap())), v, flags);
 }
 
+
+
 bool JSObject::updateOwnProperty(Runtime& rt, const Value& key, const Value& v) {
 	Table::Bucket* bucket = lookup(key.toString(rt.getHeap()));
 	return (bucket != 0 && update(bucket, v));
@@ -1495,7 +1500,6 @@
 	}
 	return NONEXISTENT;
 }
-
 bool JSObject::deleteOwnProperty(Runtime& rt, const Value& key) {
 	Table::Bucket* bucket = lookup(key.toString(rt.getHeap()));
 	return (bucket == 0 || erase(bucket));
@@ -1599,6 +1603,7 @@
 	return false;
 }
 
+
 /* --- JSArray --- */
 
 JSArray::JSArray(GCList& gcList) : super(gcList), length(0), denseVector(&gcList.getHeap()) { }
@@ -1697,6 +1702,7 @@
 	return super::setOwnProperty(rt, index, v, STANDARD_FLAGS);
 }
 
+
 bool JSArray::setOwnProperty(Runtime& rt, const Value& key, const Value& v, Flags flags) {
 	UInt32 index;
 	if (key.toArrayIndex(index) && index != 0xFFFFFFFFU) {
@@ -1754,6 +1760,7 @@
 	return getCompleteObject(rt)->setOwnProperty(rt, key, v, flags);
 }
 
+
 template<class SUPER> bool LazyJSObject<SUPER>::deleteOwnProperty(Runtime& rt, const Value& key) {
 	return getCompleteObject(rt)->deleteOwnProperty(rt, key);
 }
@@ -1828,6 +1835,7 @@
 	message = (getProperty(rt, &MESSAGE_STRING, &v) != NONEXISTENT ? v.toString(rt.getHeap()) : 0);
 }
 
+
 bool Error::setOwnProperty(Runtime& rt, const Value& key, const Value& v, Flags flags) {
 	const bool result = super::setOwnProperty(rt, key, v, flags);
 	updateReflection(rt);
@@ -1884,6 +1892,7 @@
 	return (p == 0 ? super::getOwnProperty(rt, key, v) : ((void)(*v = *p), (DONT_ENUM_FLAG | EXISTS_FLAG)));
 }
 
+
 bool Arguments::setOwnProperty(Runtime& rt, const Value& key, const Value& v, Flags flags) {
 	Value* p = findProperty(key);
 	if (p != 0 && (flags & (READ_ONLY_FLAG | DONT_ENUM_FLAG | DONT_DELETE_FLAG)) != 0) {
@@ -1961,6 +1970,7 @@
 	if (code->getArgumentsCount() > argc) {
 		std::fill(e, locals.end(), UNDEFINED_VALUE);
 	}
+
 }
 
 JSObject* FunctionScope::getDynamicVars(Runtime& rt) const {
@@ -2334,6 +2344,7 @@
 	}
 }
 
+
 void Processor::enterFunctionCode(JSFunction* func, UInt32 argc, const Value* argv, Object* thisObject) {
 	enter(func->code, new(heap) FunctionScope(heap.managed(), func, argc, argv), thisObject);
 }
@@ -2453,7 +2464,6 @@
 			break;
 			case WRITE_NAMED_OP:		scope->writeVar(rt, constants[im].getString(), sp[0]); break;
 			case WRITE_NAMED_POP_OP:	scope->writeVar(rt, constants[im].getString(), sp[0]); pop(1); break;
-
 			case GET_PROPERTY_OP: {
 				const Object* o = convertToObject(sp[-1], false);
 				if (o == 0) {
@@ -2466,6 +2476,7 @@
 				break;
 			}
 			
+			
 			case SET_PROPERTY_OP: {
 				Object* o = convertToObject(sp[-2], false);
 				if (o == 0) {
@@ -2477,6 +2488,7 @@
 				break;
 			}
 			
+			
 			case SET_PROPERTY_POP_OP: {
 				Object* o = convertToObject(sp[-2], false);
 				if (o == 0) {
@@ -2487,6 +2499,7 @@
 				break;
 			}
 
+
 			case OBJ_TO_PRIMITIVE_OP:
 			case OBJ_TO_NUMBER_OP:
 			case OBJ_TO_STRING_OP: {
@@ -3459,8 +3472,13 @@
 				case ExpressionResult::PUSHED_PRIMITIVE: emit(Processor::POP_OP, 1); /* fall through */
 				case ExpressionResult::NONE:
 				case ExpressionResult::CONSTANT: xr = ExpressionResult(ExpressionResult::CONSTANT, true); break;
-				case ExpressionResult::LOCAL: xr = ExpressionResult(ExpressionResult::CONSTANT, false); break;
-				case ExpressionResult::NAMED: emitWithConstant(Processor::DELETE_NAMED_OP, xr.v); xr = ExpressionResult(ExpressionResult::PUSHED_PRIMITIVE); break;
+				case ExpressionResult::LOCAL:
+					xr = ExpressionResult(ExpressionResult::CONSTANT, false);
+					break;
+				case ExpressionResult::NAMED:
+					emitWithConstant(Processor::DELETE_NAMED_OP, xr.v);
+					xr = ExpressionResult(ExpressionResult::PUSHED_PRIMITIVE);
+					break;
 				case ExpressionResult::PROPERTY: emit(Processor::DELETE_OP); xr = ExpressionResult(ExpressionResult::PUSHED_PRIMITIVE); break;
 				default: assert(0);
 			}
@@ -4461,6 +4479,9 @@
 	p = b;
 	this->e = e;
 	acceptInOperator = true;
+	const Char* directiveStart = p;
+	white();
+	p = directiveStart;
 	
 	// FIX : not 100% necessary now because we should always start with undefined on top of stack
 	if (compilingFor == FOR_EVAL) {
@@ -4496,6 +4517,7 @@
 	white();
 	Table& nameIndexes = code->nameIndexes;
 	Vector<const String*>& argumentNames = code->argumentNames;
+	bool hasDuplicateParameters = false;
 	while (!token(")", false)) {
 		if (eof()) {
 			error(SYNTAX_ERROR, argumentNames.size() == 0 ? "Expected ')'" : "Expected ',' or ')'");
@@ -4507,6 +4529,12 @@
 			white();
 		}
 		const String* name = identifier(true, false);
+		for (size_t i = 0; i < argumentNames.size(); ++i) {
+			if (argumentNames[i]->isEqualTo(*name)) {
+				hasDuplicateParameters = true;
+				break;
+			}
+		}
 		nameIndexes.update(nameIndexes.insert(name), static_cast<Int32>(argumentNames.size()));
 		argumentNames.push(name);
 		code->bloomSet |= name->createBloomCode();
@@ -4655,6 +4683,7 @@
 	}
 }
 
+
 template<class F> struct UnaryMathFunction : public Function {
 	UnaryMathFunction(F& f) : f(f) { }
 	virtual Value invoke(Runtime&, Processor&, UInt32 argc, const Value* argv, Object*) {
@@ -4734,16 +4763,18 @@
 		if (argc >= 2) {
 			Object* o = argv[0].asObject();
 			if (o != 0) {
-				success = o->setOwnProperty(rt, argv[1], (argc >= 3 ? argv[2] : UNDEFINED_VALUE)
-						, (argc >= 4 && argv[3].toBool() ? READ_ONLY_FLAG : 0)
+						Flags flags = (argc >= 4 && argv[3].toBool() ? READ_ONLY_FLAG : 0)
 						| (argc >= 5 && argv[4].toBool() ? DONT_ENUM_FLAG : 0)
 						| (argc >= 6 && argv[5].toBool() ? DONT_DELETE_FLAG : 0)
-						| EXISTS_FLAG);
+									 | EXISTS_FLAG;
+						success = o->setOwnProperty(rt, argv[1],
+										(argc >= 3 ? argv[2] : UNDEFINED_VALUE), flags);
 			}
 		}
 		return success;
 	}
 
+
 	static Value compileFunction(Runtime& rt, Processor&, UInt32 argc, const Value* argv, Object*) {
 		if (argc >= 1) {
 			Heap& heap = rt.getHeap();
@@ -4908,12 +4939,12 @@
 	FunctorAdapter<NativeFunction> func;
 } SUPPORT_FUNCTIONS[] = {
 	{ "getInternalProperty", Support::getInternalProperty }, { "createWrapper", Support::createWrapper },
-	{ "defineProperty", Support::defineProperty }, { "compileFunction", Support::compileFunction },
-	{ "distinctConstructor", Support::distinctConstructor }, { "callWithArgs", Support::callWithArgs },
-	{ "hasOwnProperty", Support::hasOwnProperty }, { "fromCharCode", Support::fromCharCode },
-	{ "isPropertyEnumerable", Support::isPropertyEnumerable }, { "atan2", Support::atan2 },
-	{ "pow", Support::pow }, { "parseFloat", Support::parseFloat }, { "charCodeAt", Support::charCodeAt },
-	{ "substring", Support::substring }, { "submatch", Support::submatch },
+{ "defineProperty", Support::defineProperty },
+{ "compileFunction", Support::compileFunction }, { "distinctConstructor", Support::distinctConstructor },
+	   { "callWithArgs", Support::callWithArgs }, { "hasOwnProperty", Support::hasOwnProperty },
+	   { "fromCharCode", Support::fromCharCode }, { "isPropertyEnumerable", Support::isPropertyEnumerable },
+	   { "atan2", Support::atan2 }, { "pow", Support::pow }, { "parseFloat", Support::parseFloat },
+	   { "charCodeAt", Support::charCodeAt }, { "substring", Support::substring }, { "submatch", Support::submatch },
 	{ "getCurrentTime", Support::getCurrentTime }, { "localTimeDifference", Support::localTimeDifference },
 	{ "random", Support::random }, { "updateDateValue", Support::updateDateValue }
 };
@@ -5073,6 +5104,7 @@
 	}
 }
 
+
 Code* Runtime::compileGlobalCode(const String& source, const String* filename) {
 	Code* code = new(heap) Code(heap.managed());
 	Compiler compiler(heap.roots(), code, Compiler::FOR_GLOBAL);
@@ -5126,6 +5158,7 @@
 	supportObject->setOwnProperty(*this, &UNDEFINED_STRING, UNDEFINED_VALUE);
 	supportObject->setOwnProperty(*this, &NAN_STRING, NAN_VALUE);
 	supportObject->setOwnProperty(*this, &INFINITY_STRING, INFINITY_VALUE);
+
 	supportObject->setOwnProperty(*this, &MAX_NUMBER_STRING, std::numeric_limits<double>::max());
 	supportObject->setOwnProperty(*this, &MIN_NUMBER_STRING, std::numeric_limits<double>::denorm_min());
 
--- /tmp/main_NuXJS.h	2025-09-03 12:27:48.861592329 +0000
+++ /tmp/NuXJS_es3.h	2025-09-03 12:27:44.361640827 +0000
@@ -24,6 +24,15 @@
 #ifndef NuXJS_h
 #define NuXJS_h
 
+// ---------------------------------------------------------------------------
+// ES version toggle
+//
+// NUXJS_ES5 controls ES5 features and semantics. Keep default at 0 so that
+// building without an explicit -DNUXJS_ES5=1 matches legacy ES3 behavior from
+// the main branch exactly.
+// ---------------------------------------------------------------------------
+#define NUXJS_ES5 1
+
 #include "assert.h"
 #include <algorithm>
 #include <string>
@@ -833,6 +842,8 @@
 		const String* getName() const { return name; }
 		const String* getSource() const { return source; }
 		UInt32 getMaxStackDepth() const { return maxStackDepth; }
+		bool isStrict() const { return false; }
+		void setStrict(bool) { }
 		UInt32 calcLocalsSize(UInt32 argc) const { return getVarsCount() + std::max(getArgumentsCount(), argc); }
 
 	protected:
@@ -883,6 +894,7 @@
 		Function(GCList& gcList) : super(gcList) { }
 };
 
+
 typedef Value (*NativeFunction)(Runtime&, Processor&, UInt32, const Value*, Object*);
 
 // FIX : overkill?
@@ -1007,6 +1019,7 @@
 class Arguments : public LazyJSObject<Object> {
 	public:
 		typedef LazyJSObject<Object> super;
+		friend class FunctionScope;
 
         Arguments(GCList& gcList, const FunctionScope* scope, UInt32 argumentsCount);
 		virtual const String* getClassName() const;	// &A_RGUMENTS_STRING
@@ -1090,7 +1103,6 @@
 **/
 class Runtime : public GCItem {
 	friend class Processor;
-	friend struct Support;
 	
 	protected:
 		struct GlobalScope : public Scope {
@@ -1338,14 +1350,26 @@
 	friend class AccessorBase;
 	
 	public:
-		template<typename T> const Property& operator=(const T& v) const { object->setProperty(rt, key, Var(rt, v)); return *this; }
-		template<typename T> const Property& operator+=(const T& r) const { object->setProperty(rt, key, get().add(rt.getHeap(), makeValue(r))); return *this; }
+	template <typename T> const Property &operator=(const T &v) const {
+		object->setProperty(rt, key, Var(rt, v));
+		return *this;
+	}
+	template <typename T> const Property &operator+=(const T &r) const {
+		object->setProperty(rt, key, get().add(rt.getHeap(), makeValue(r)));
+		return *this;
+	}
 
 	protected:
 		typedef AccessorBase super;
 		Property(Runtime& rt, Object* object, const Var& key) : super(rt), object(object), key(key) { }
-		virtual Value get() const { Value v(UNDEFINED_VALUE); object->getProperty(rt, key, &v); return v; }
-		virtual Var call(int argc, const Value* argv) const { return rt.call(*this, argc, argv, object); }
+	virtual Value get() const {
+		Value v(UNDEFINED_VALUE);
+				object->getProperty(rt, key, &v);
+				return v;
+	}
+	virtual Var call(int argc, const Value *argv) const {
+		return rt.call(*this, argc, argv, object);
+	}
 		Object* const object;
 		const Var key;
 };
@@ -1585,7 +1609,12 @@
 		};
 	
 		struct OpcodeInfo {
-			enum { TERMINAL = 1, POP_OPERAND = 2, POP_ON_BRANCH = 4, NO_POP_ON_BRANCH = 8 };
+			enum {
+				TERMINAL = 1,			/// instruction ends current basic block
+				POP_OPERAND = 2,	/// pop `operand` values after execution
+				POP_ON_BRANCH = 4,	/// branch path pops the top of stack
+				NO_POP_ON_BRANCH = 8	/// branch path keeps the top of stack
+			};
 			Opcode opcode;
 			const char* mnemonic;
 			Int32 stackUse;
