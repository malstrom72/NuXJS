diff --git a/src/NuXJS.cpp b/src/NuXJS.cpp
index 091635a..7222764 100644
--- a/src/NuXJS.cpp
+++ b/src/NuXJS.cpp
@@ -27,8 +27,8 @@
 #pragma GCC optimize ("no-finite-math-only")
 // older gcc might need this too:
 // #pragma GCC optimize ("float-store")
-#endif
-#endif
+			#endif
+			#endif
 
 #ifdef _MSC_VER
 #pragma float_control(precise, on, push)  
@@ -49,7 +49,7 @@
 // Since these can be called during static initialization we allow heap == 0 to use standard new/delete.
 void* operator new(size_t size, NuXJS::Heap* heap) {
 	return (heap != 0 ? heap->allocate(size) : ::operator new(size));
-}
+	}
 
 void* operator new[](size_t size, NuXJS::Heap* heap) {
 	return (heap != 0 ? heap->allocate(size) : ::operator new[](size));
@@ -167,7 +167,7 @@ const UInt16 IDENTIFIER_PART_OFFSETS[256] = {
 
 static inline bool testUnicodeChar(Char c, const UInt16* offsets) {
 	return (UNICODE_MASKS[offsets[c >> 8] + ((c & 255) >> 5)] & (1 << (c & 31))) != 0;
-}
+	}
 
 /* --- String constants --- */
 
@@ -180,6 +180,10 @@ const String A_RGUMENTS_STRING("Arguments"), A_RRAY_STRING("Array"), B_OOLEAN_ST
 				, E_RROR_STRING("Error"), F_UNCTION_STRING("Function"), N_UMBER_STRING("Number"), O_BJECT_STRING("Object")
 				, S_TRING_STRING("String");
 
+			#if (NUXJS_ES5)
+const String GET_STRING("get"), SET_STRING("set");
+#endif
+
 static const String ANONYMOUS_STRING("anonymous"), ARGUMENTS_STRING("arguments")
 		, BRACKET_OBJECT_STRING("[object "), CALLEE_STRING("callee")
 		, CANNOT_CONVERT_TO_OBJECT_STRING("Cannot convert undefined or null to object")
@@ -1277,6 +1281,9 @@ const String* Object::getClassName() const { return &O_BJECT_STRING; }
 Object* Object::getPrototype(Runtime& rt) const { return rt.getObjectPrototype(); }
 Value Object::getInternalValue(Heap&) const { return UNDEFINED_VALUE; }
 Flags Object::getOwnProperty(Runtime&, const Value&, Value*) const { return NONEXISTENT; }
+#if (NUXJS_ES5)
+bool Object::setOwnProperty(Runtime& rt, const String* key, const Value& v, Flags flags) { return setOwnProperty(rt, Value(key), v, flags); }
+#endif
 bool Object::setOwnProperty(Runtime&, const Value&, const Value&, Flags) { return false; }
 bool Object::deleteOwnProperty(Runtime&, const Value&) { return false; }
 Enumerator* Object::getOwnPropertyEnumerator(Runtime&) const { return &EMPTY_ENUMERATOR; }
@@ -1316,6 +1323,32 @@ Flags Object::getProperty(Runtime& rt, const Value& key, Value* v) const {
 	return NONEXISTENT;
 }
 
+#if (NUXJS_ES5)
+Flags Object::getProperty(Runtime& rt, Processor& processor, const Value& key, Value* v) const {
+const Object* o = this;
+do {
+Value current;
+Flags flags = o->getOwnProperty(rt, key, &current);
+if (flags != NONEXISTENT) {
+if ((flags & ACCESSOR_FLAG) != 0) {
+Accessor* acc = static_cast<Accessor*>(current.asObject());
+Function* getter = (acc != 0 ? acc->getter : 0);
+if (getter != 0) {
+processor.invokeFunction(getter, 0, static_cast<const Value*>(0), const_cast<Object*>(this));
+} else {
+*v = UNDEFINED_VALUE;
+}
+} else {
+*v = current;
+}
+return flags;
+}
+o = o->getPrototype(rt);
+} while (o != 0);
+return NONEXISTENT;
+}
+#endif
+
 bool Object::setProperty(Runtime& rt, const Value& key, const Value& v) {
 	if (updateOwnProperty(rt, key, v)) {
 		return true;
@@ -1330,6 +1363,25 @@ bool Object::setProperty(Runtime& rt, const Value& key, const Value& v) {
 	return setOwnProperty(rt, key, v);
 }
 
+#if (NUXJS_ES5)
+bool Object::setProperty(Runtime& rt, Processor& processor, const Value& key, const Value& v) {
+Value current;
+Flags flags = getProperty(rt, key, &current);
+if (flags != NONEXISTENT && (flags & ACCESSOR_FLAG) != 0) {
+Accessor* acc = static_cast<Accessor*>(current.asObject());
+Function* setter = (acc != 0 ? acc->setter : 0);
+if (setter != 0) {
+Value arg(v);
+processor.invokeFunction(setter, 1, &arg, const_cast<Object*>(this));
+return true;
+}
+return false;
+}
+setProperty(rt, key, v);
+return false;
+}
+#endif
+
 Enumerator* Object::getPropertyEnumerator(Runtime& rt) const {
 	Heap& heap = rt.getHeap();
 	Enumerator* enumerator = getOwnPropertyEnumerator(rt);
@@ -1347,7 +1399,7 @@ UInt32 Table::calcMaxLoad(UInt32 bucketCount) { return (bucketCount - (bucketCou
 Table::Table(Heap* heap) : buckets(1U << TABLE_BUILT_IN_N, heap), loadCount(0) { }
 UInt32 Table::getLoadCount() const { return loadCount; }
 Table::Bucket* Table::getFirst() const { return getNext(buckets.begin() - 1); }
-const Table::Bucket* Table::lookup(const String* key) const { return const_cast<Table*>(this)->lookup(key); }	// OK because lookup does not modify, only exposes non-const pointer
+	const Table::Bucket* Table::lookup(const String* key) const { return const_cast<Table*>(this)->lookup(key); }	// OK because lookup does not modify, only exposes non-const pointer
 
 Table::Bucket* Table::getNext(Bucket* bucket) const {
 	assert(bucket != 0);
@@ -1479,8 +1531,31 @@ JSObject::JSObject(GCList& gcList, Object* prototype)
 Object* JSObject::getPrototype(Runtime&) const { return prototype; }
 
 bool JSObject::setOwnProperty(Runtime& rt, const Value& key, const Value& v, Flags flags) {
-	return update(insert(key.toString(rt.getHeap())), v, flags);
+#if (NUXJS_ES5)
+return setOwnProperty(rt, key.toString(rt.getHeap()), v, flags);
+#else
+return update(insert(key.toString(rt.getHeap())), v, flags);
+#endif
+}
+
+#if (NUXJS_ES5)
+bool JSObject::setOwnProperty(Runtime& rt, const String* key, const Value& v, Flags flags) {
+Table::Bucket* bucket = insert(key);
+if ((flags & ACCESSOR_FLAG) != 0 && bucket->valueExists() && (bucket->getFlags() & ACCESSOR_FLAG) != 0) {
+Accessor* acc = static_cast<Accessor*>(bucket->getValue().getObject());
+Accessor* nv = static_cast<Accessor*>(v.getObject());
+if (nv->getter != 0) {
+acc->getter = nv->getter;
+}
+if (nv->setter != 0) {
+acc->setter = nv->setter;
 }
+return true;
+}
+return update(bucket, v, flags);
+}
+#endif
+
 
 bool JSObject::updateOwnProperty(Runtime& rt, const Value& key, const Value& v) {
 	Table::Bucket* bucket = lookup(key.toString(rt.getHeap()));
@@ -1495,7 +1570,6 @@ Flags JSObject::getOwnProperty(Runtime& rt, const Value& key, Value* v) const {
 	}
 	return NONEXISTENT;
 }
-
 bool JSObject::deleteOwnProperty(Runtime& rt, const Value& key) {
 	Table::Bucket* bucket = lookup(key.toString(rt.getHeap()));
 	return (bucket == 0 || erase(bucket));
@@ -1553,7 +1627,7 @@ Code::Code(GCList& gcList, Constants* sharedConstants)
 	: super(gcList), codeWords(0, &gcList.getHeap())
 	, constants(sharedConstants ? sharedConstants : new(gcList.getHeap()) Constants(gcList.getHeap().managed()))
 	, nameIndexes(&gcList.getHeap()), varNames(&gcList.getHeap()), argumentNames(&gcList.getHeap()), name(0)
-	, selfName(0), source(0), bloomSet(0), maxStackDepth(0)
+, selfName(0), source(0), bloomSet(0), maxStackDepth(0), strict(false)
 {
 	assert(constants != 0);
 }
@@ -1599,13 +1673,19 @@ bool Function::hasInstance(Runtime& rt, Object* object) const {
 	return false;
 }
 
+			#if (NUXJS_ES5)
+Function* Function::getConstructTarget() {
+	return this;
+}
+#endif
+
 /* --- JSArray --- */
 
 JSArray::JSArray(GCList& gcList) : super(gcList), length(0), denseVector(&gcList.getHeap()) { }
 JSArray::JSArray(GCList& gcList, UInt32 initialLength)
 		: super(gcList), length(initialLength), denseVector(initialLength, &gcList.getHeap()) {
 	std::fill(denseVector.begin(), denseVector.end(), UNDEFINED_VALUE);
-}
+	}
 JSArray::JSArray(GCList& gcList, UInt32 initialLength, const Value* initialElements) : super(gcList)
 		, length(initialLength), denseVector(initialElements, initialElements + initialLength, &gcList.getHeap()) { }
 
@@ -1697,6 +1777,12 @@ bool JSArray::setElement(Runtime& rt, UInt32 index, const Value& v) {
 	return super::setOwnProperty(rt, index, v, STANDARD_FLAGS);
 }
 
+#if (NUXJS_ES5)
+bool JSArray::setOwnProperty(Runtime& rt, const String* key, const Value& v, Flags flags) {
+return setOwnProperty(rt, Value(key), v, flags);
+}
+#endif
+
 bool JSArray::setOwnProperty(Runtime& rt, const Value& key, const Value& v, Flags flags) {
 	UInt32 index;
 	if (key.toArrayIndex(index) && index != 0xFFFFFFFFU) {
@@ -1754,6 +1840,12 @@ template<class SUPER> bool LazyJSObject<SUPER>::setOwnProperty(Runtime& rt, cons
 	return getCompleteObject(rt)->setOwnProperty(rt, key, v, flags);
 }
 
+#if (NUXJS_ES5)
+template<class SUPER> bool LazyJSObject<SUPER>::setOwnProperty(Runtime& rt, const String* key, const Value& v, Flags flags) {
+return getCompleteObject(rt)->setOwnProperty(rt, key, v, flags);
+}
+#endif
+
 template<class SUPER> bool LazyJSObject<SUPER>::deleteOwnProperty(Runtime& rt, const Value& key) {
 	return getCompleteObject(rt)->deleteOwnProperty(rt, key);
 }
@@ -1828,6 +1920,14 @@ void Error::updateReflection(Runtime& rt) {
 	message = (getProperty(rt, &MESSAGE_STRING, &v) != NONEXISTENT ? v.toString(rt.getHeap()) : 0);
 }
 
+#if (NUXJS_ES5)
+bool Error::setOwnProperty(Runtime& rt, const String* key, const Value& v, Flags flags) {
+const bool result = super::setOwnProperty(rt, key, v, flags);
+updateReflection(rt);
+return result;
+}
+#endif
+
 bool Error::setOwnProperty(Runtime& rt, const Value& key, const Value& v, Flags flags) {
 	const bool result = super::setOwnProperty(rt, key, v, flags);
 	updateReflection(rt);
@@ -1850,7 +1950,7 @@ void Error::constructCompleteObject(Runtime& rt) const {
 
 Arguments::Arguments(GCList& gcList, const FunctionScope* scope, UInt32 argumentsCount) : super(gcList)
 	, scope(scope), function(scope->function), argumentsCount(argumentsCount)
-	   , deletedArguments(argumentsCount, &gcList.getHeap()), values(0, &gcList.getHeap()) {
+	, deletedArguments(argumentsCount, &gcList.getHeap()), values(0, &gcList.getHeap()), owner(const_cast<FunctionScope*>(scope)) {
 	std::fill(deletedArguments.begin(), deletedArguments.end(), false);
 }
 
@@ -1884,6 +1984,12 @@ Flags Arguments::getOwnProperty(Runtime& rt, const Value& key, Value* v) const {
 	return (p == 0 ? super::getOwnProperty(rt, key, v) : ((void)(*v = *p), (DONT_ENUM_FLAG | EXISTS_FLAG)));
 }
 
+#if (NUXJS_ES5)
+bool Arguments::setOwnProperty(Runtime& rt, const String* key, const Value& v, Flags flags) {
+return setOwnProperty(rt, Value(key), v, flags);
+}
+#endif
+
 bool Arguments::setOwnProperty(Runtime& rt, const Value& key, const Value& v, Flags flags) {
 	Value* p = findProperty(key);
 	if (p != 0 && (flags & (READ_ONLY_FLAG | DONT_ENUM_FLAG | DONT_DELETE_FLAG)) != 0) {
@@ -1910,8 +2016,8 @@ void Arguments::constructCompleteObject(Runtime& rt) const {
 }
 
 Arguments::~Arguments() {
-	if (scope != 0) {
-		scope->arguments = 0;
+	if (owner != 0) {
+		owner->arguments = 0;
 	}
 }
 
@@ -1961,13 +2067,28 @@ FunctionScope::FunctionScope(GCList& gcList, JSFunction* function, UInt32 argc,
 	if (code->getArgumentsCount() > argc) {
 		std::fill(e, locals.end(), UNDEFINED_VALUE);
 	}
+#if (NUXJS_ES5)
+	if (code->strict) {
+		Heap& heap = gcList.getHeap();
+		arguments = new(heap) Arguments(heap.managed(), this, passedArgumentsCount);
+		arguments->detach();
+	}
+#endif
+
 }
 
 JSObject* FunctionScope::getDynamicVars(Runtime& rt) const {
 	if (dynamicVars == 0) {
 		Heap& heap = rt.getHeap();
 		dynamicVars = new(heap) JSObject(heap.managed(), 0);
+		if (arguments == 0) {
 			arguments = new(heap) Arguments(heap.managed(), this, passedArgumentsCount);
+		#if (NUXJS_ES5)
+			if (function->code->strict) {
+				arguments->detach();
+			}
+		#endif
+		}
 		dynamicVars->setOwnProperty(rt, &ARGUMENTS_STRING, arguments, DONT_DELETE_FLAG);
 	}
 	return dynamicVars;
@@ -2062,6 +2183,7 @@ void FunctionScope::declareVar(Runtime& rt, const String* name, const Value& ini
 
 FunctionScope::~FunctionScope() {
 		if (arguments != 0) {
+				arguments->owner = 0;
 				arguments->detach();
 				arguments = 0;
 		}
@@ -2093,10 +2215,15 @@ static struct EvalFunction : public Function {
 			return argv[0];
 		}
 
-		Heap& heap = rt.getHeap();
-		const String* expression = argv[0].toString(heap);
-		processor.enterEvalCode(rt.compileEvalCode(expression), direct);
-		return UNDEFINED_VALUE;
+Heap& heap = rt.getHeap();
+const String* expression = argv[0].toString(heap);
+#if (NUXJS_ES5)
+const bool strict = direct && processor.isCurrentStrict();
+processor.enterEvalCode(rt.compileEvalCode(expression, strict), direct);
+#else
+processor.enterEvalCode(rt.compileEvalCode(expression), direct);
+#endif
+return UNDEFINED_VALUE;
 	}
 	bool direct;
 } EVAL_FUNCTION(false), DIRECT_EVAL_FUNCTION(true);
@@ -2119,6 +2246,10 @@ const Processor::OpcodeInfo Processor::opcodeInfo[Processor::OP_COUNT] = {
 	{ SET_PROPERTY_OP			 , "SET_PROPERTY"			 , -2	  , 0 },
 	{ SET_PROPERTY_POP_OP		 , "SET_PROPERTY_POP"		 , -3	  , 0 },
 	{ ADD_PROPERTY_OP					, "ADD_PROPERTY"					, -1	 , 0 },
+#if (NUXJS_ES5)
+	{ ADD_GETTER_OP					, "ADD_GETTER"				 , -1	 , 0 },
+	{ ADD_SETTER_OP					, "ADD_SETTER"				 , -1	 , 0 },
+#endif
 	{ PUSH_ELEMENTS_OP			, "PUSH_ELEMENTS_OP"		, 0		, OpcodeInfo::POP_OPERAND },
 	{ OBJ_TO_PRIMITIVE_OP		 , "OBJ_TO_PRIMITIVE"		 , 0	  , 0 },
 	{ OBJ_TO_NUMBER_OP			 , "OBJ_TO_NUMBER"			 , 0	  , 0 },
@@ -2202,10 +2333,49 @@ const Processor::OpcodeInfo& Processor::getOpcodeInfo(const Opcode opcode) {
 */
 struct Processor::EvalScope : public Scope {
 		typedef Scope super;
-	EvalScope(GCList& gcList, Scope* parentScope) : super(gcList, parentScope) { }
-	virtual void declareVar(Runtime& rt, const String* name, const Value& initValue, bool) {
+		EvalScope(GCList& gcList, Scope* parentScope, bool isolated) : super(gcList, parentScope), vars(0), isolated(isolated) { }
+		virtual Flags readVar(Runtime& rt, const String* name, Value* v) const {
+			if (isolated && vars != 0) {
+				const Flags flags = vars->getOwnProperty(rt, name, v);
+				if (flags != NONEXISTENT) {
+					return flags;
+				}
+			}
+			return parentScope->readVar(rt, name, v);
+		}
+		virtual void writeVar(Runtime& rt, const String* name, const Value& value) {
+			if (isolated && vars != 0) {
+				Value tmp;
+				if (vars->getOwnProperty(rt, name, &tmp) != NONEXISTENT) {
+					vars->setOwnProperty(rt, name, value);
+					return;
+				}
+			}
+			parentScope->writeVar(rt, name, value);
+		}
+		virtual bool deleteVar(Runtime& rt, const String* name) {
+			if (isolated && vars != 0 && vars->deleteOwnProperty(rt, name)) {
+				return true;
+			}
+			return parentScope->deleteVar(rt, name);
+		}
+		virtual void declareVar(Runtime& rt, const String* name, const Value& initValue, bool dontDelete) {
+			if (isolated) {
+				if (vars == 0) {
+					Heap& heap = rt.getHeap();
+					vars = new(heap) JSObject(heap.managed(), 0);
+				}
+				vars->setOwnProperty(rt, name, initValue.isUndefined() ? UNDEFINED_VALUE : initValue, dontDelete ? DONT_DELETE_FLAG : 0);
+			} else {
 				parentScope->declareVar(rt, name, initValue, false);
 			}
+		}
+		JSObject* vars;
+		bool isolated;
+		virtual void gcMarkReferences(Heap& heap) const {
+			gcMark(heap, vars);
+			super::gcMarkReferences(heap);
+		}
 };
 	
 /*
@@ -2313,7 +2483,8 @@ void Processor::enter(const Code* code, Scope* scope, Object* thisObject) {
 	if (sp + code->getMaxStackDepth() > stack.end()) {
 		ScriptException::throwError(heap, RANGE_ERROR, &STACK_OVERFLOW_STRING); // Notice: we can't use virtual throw here, cause we need to abort any sp changes etc that could happen if we continued execution beyond this point.
 	} else {
-		pushFrame(code, scope, (thisObject == 0 ? rt.getGlobalObject() : thisObject));
+Object* obj = (thisObject == 0 && !code->isStrict() ? rt.getGlobalObject() : thisObject);
+pushFrame(code, scope, obj);
 		ip = code->getCodeWords();
 	}
 }
@@ -2326,14 +2497,16 @@ void Processor::enterGlobalCode(const Code* code) {
 	enter(code, rt.getGlobalScope(), rt.getGlobalObject());
 }
 
-void Processor::enterEvalCode(const Code* code, bool local) {
-	if (local && currentFrame != 0) {
-		enter(code, new(heap) Processor::EvalScope(heap.managed(), currentFrame->scope), currentFrame->thisObject);
+void Processor::enterEvalCode(const Code* code, bool direct) {
+	bool isolate = direct && code->isStrict();
+	if (direct && currentFrame != 0) {
+		enter(code, new(heap) Processor::EvalScope(heap.managed(), currentFrame->scope, isolate), currentFrame->thisObject);
 	} else {
-		enter(code, new(heap) Processor::EvalScope(heap.managed(), rt.getGlobalScope()), rt.getGlobalObject());
+		enter(code, new(heap) Processor::EvalScope(heap.managed(), rt.getGlobalScope(), isolate), rt.getGlobalObject());
 	}
 }
 
+
 void Processor::enterFunctionCode(JSFunction* func, UInt32 argc, const Value* argv, Object* thisObject) {
 	enter(func->code, new(heap) FunctionScope(heap.managed(), func, argc, argv), thisObject);
 }
@@ -2405,9 +2578,14 @@ void Processor::invokeFunction(Function* f, Int32 popCount, Int32 argc, Object*
 
 void Processor::newOperation(const Int32 argc) {
 	   Function* f = asFunction(sp[-argc]);
-	if (f != 0) { // FIX : sub
+if (f != 0) { // FIX : sub
 	Value v(UNDEFINED_VALUE);
-		f->getProperty(rt, &PROTOTYPE_STRING, &v);
+#if (NUXJS_ES5)
+	Function* target = f->getConstructTarget();
+#else
+	Function* target = f;
+#endif
+target->getProperty(rt, &PROTOTYPE_STRING, &v);
 			   Object* prototype = v.asObject();
 			   Int32 counter = 0;
 			   for (Object* p = prototype; p != 0; p = p->getPrototype(rt)) {
@@ -2451,41 +2629,79 @@ void Processor::innerRun() {
 				}
 			}
 			break;
-			case WRITE_NAMED_OP:		scope->writeVar(rt, constants[im].getString(), sp[0]); break;
-			case WRITE_NAMED_POP_OP:	scope->writeVar(rt, constants[im].getString(), sp[0]); pop(1); break;
-
-			case GET_PROPERTY_OP: {
-				const Object* o = convertToObject(sp[-1], false);
-				if (o == 0) {
+			case WRITE_NAMED_OP: {
+				const String* name = constants[im].getString();
+				if (code->isStrict()) {
+					Value dummy;
+					if (scope->readVar(rt, name, &dummy) == NONEXISTENT) {
+						error(REFERENCE_ERROR, new(heap) String(heap.managed(), *name, IS_NOT_DEFINED_STRING));
 						return;
 					}
-				if (o->getProperty(rt, sp[0], sp - 1) == NONEXISTENT) {
-					sp[-1] = UNDEFINED_VALUE;
 				}
-				pop(1);
-				break;
+				scope->writeVar(rt, name, sp[0]);
 			}
-			
-			case SET_PROPERTY_OP: {
-				Object* o = convertToObject(sp[-2], false);
-				if (o == 0) {
+			break;
+			case WRITE_NAMED_POP_OP: {
+				const String* name = constants[im].getString();
+				if (code->isStrict()) {
+					Value dummy;
+					if (scope->readVar(rt, name, &dummy) == NONEXISTENT) {
+						error(REFERENCE_ERROR, new(heap) String(heap.managed(), *name, IS_NOT_DEFINED_STRING));
 						return;
 					}
-				o->setProperty(rt, sp[-1], sp[0]);
-				sp[-2] = sp[0];
-				pop(2);
-				break;
 				}
-			
-			case SET_PROPERTY_POP_OP: {
-				Object* o = convertToObject(sp[-2], false);
-				if (o == 0) {
-					return;
+				scope->writeVar(rt, name, sp[0]);
+				pop(1);
 			}
-				o->setProperty(rt, sp[-1], sp[0]);
-				pop(3);
 			break;
-			}
+case GET_PROPERTY_OP: {
+const Object* o = convertToObject(sp[-1], false);
+if (o == 0) {
+return;
+}
+Flags f = o->getProperty(rt, *this, sp[0], sp - 1);
+if (f == NONEXISTENT) {
+sp[-1] = UNDEFINED_VALUE;
+pop(1);
+break;
+}
+pop(1);
+if ((f & ACCESSOR_FLAG) != 0) {
+return;
+}
+break;
+}
+
+			
+case SET_PROPERTY_OP: {
+Object* o = convertToObject(sp[-2], false);
+if (o == 0) {
+return;
+}
+Value v = sp[0];
+bool acc = o->setProperty(rt, *this, sp[-1], sp[0]);
+sp[-2] = v;
+pop(2);
+if (acc) {
+return;
+}
+break;
+}
+
+			
+case SET_PROPERTY_POP_OP: {
+Object* o = convertToObject(sp[-2], false);
+if (o == 0) {
+return;
+}
+bool acc = o->setProperty(rt, *this, sp[-1], sp[0]);
+pop(3);
+if (acc) {
+return;
+}
+break;
+}
+
 
 			case OBJ_TO_PRIMITIVE_OP:
 			case OBJ_TO_NUMBER_OP:
@@ -2596,7 +2812,7 @@ void Processor::innerRun() {
 			case NEW_ARRAY_OP: push(new(heap) JSArray(heap.managed())); break;
 			case NEW_REG_EXP_OP: invokeFunction(rt.createRegExpFunction, 1, 2); return;
 			case RETURN_OP: ip = currentFrame->returnIP; popFrame(); return;
-			case THIS_OP: push(thisObject); break;
+case THIS_OP: push(thisObject != 0 ? Value(thisObject) : UNDEFINED_VALUE); break;
 			case VOID_OP: push(UNDEFINED_VALUE); break;
 			
 			case GEN_FUNC_OP: {
@@ -2615,6 +2831,22 @@ void Processor::innerRun() {
 				pop(1);
 				break;
 			}
+		#if (NUXJS_ES5)
+			case ADD_GETTER_OP: {
+				Object* o = sp[-1].getObject();
+				Accessor* acc = new(heap) Accessor(heap.managed(), sp[0].asFunction(), 0);
+				o->setOwnProperty(rt, constants[im], acc, ACCESSOR_FLAG);
+				pop(1);
+				break;
+			}
+			case ADD_SETTER_OP: {
+				Object* o = sp[-1].getObject();
+				Accessor* acc = new(heap) Accessor(heap.managed(), 0, sp[0].asFunction());
+				o->setOwnProperty(rt, constants[im], acc, ACCESSOR_FLAG);
+				pop(1);
+				break;
+			}
+		#endif
 
 			case PUSH_ELEMENTS_OP: {
 				Object* o = sp[-im].getObject();
@@ -3123,7 +3355,13 @@ const String* Compiler::identifier(bool required, bool allowKeywords) {
 		if (!allowKeywords && findReservedKeyword(parsed.size(), parsed.begin()) >= 0) {
 				error(SYNTAX_ERROR, "Illegal use of keyword");
 		}
-	return newHashedString(heap, parsed.begin(), parsed.end());
+		const String* name = newHashedString(heap, parsed.begin(), parsed.end());
+	#if (NUXJS_ES5)
+		if (code->isStrict() && name->isEqualTo(EVAL_STRING)) {
+				error(SYNTAX_ERROR, "Illegal use of eval or arguments in strict code");
+		}
+	#endif
+		return name;
 }
 
 static UInt32 unescapedMaxLength(const Char* p, const Char* e) {
@@ -3367,17 +3605,39 @@ Compiler::ExpressionResult Compiler::objectInitialiser() { // FIX : share stuff
 	
 	white();
 	while (!token("}", false)) {
+		bool handled = false;
 		const Char* b = p;
 		Value key = stringOrNumberConstant();
 		if (p == b) {
-			key = identifier(false, true);
-			if (key.equalsString(EMPTY_STRING)) {
+			const String* id = identifier(false, true);
+			if (id->isEqualTo(EMPTY_STRING)) {
 			error(SYNTAX_ERROR, "Expected property name");
 			}
+				white();
+			#if (NUXJS_ES5)
+				if ((id->isEqualTo(GET_STRING) || id->isEqualTo(SET_STRING)) && *p != ':') {
+						bool isGetter = id->isEqualTo(GET_STRING);
+						const Char* b2 = p;
+						Value accKey = stringOrNumberConstant();
+						if (p == b2) {
+								accKey = identifier(true, true);
+						}
+						white();
+						const String* funcName = accKey.toString(heap);
+						functionDefinition(funcName, funcName);
+						emitWithConstant(isGetter ? Processor::ADD_GETTER_OP : Processor::ADD_SETTER_OP, accKey);
+						handled = true;
+				} else
+			#endif
+				{
+						key = id;
 				}
+		}
+		if (!handled) {
 				expectToken(":", true);
 				rvalueExpression(COMMA_PREC);
 				emitWithConstant(Processor::ADD_PROPERTY_OP, key);
+		}
 			if (token("}", true)) {
 				break;
 			}
@@ -3459,8 +3719,23 @@ bool Compiler::preOperate(ExpressionResult& xr, Precedence precedence) {
 				case ExpressionResult::PUSHED_PRIMITIVE: emit(Processor::POP_OP, 1); /* fall through */
 				case ExpressionResult::NONE:
 				case ExpressionResult::CONSTANT: xr = ExpressionResult(ExpressionResult::CONSTANT, true); break;
-				case ExpressionResult::LOCAL: xr = ExpressionResult(ExpressionResult::CONSTANT, false); break;
-				case ExpressionResult::NAMED: emitWithConstant(Processor::DELETE_NAMED_OP, xr.v); xr = ExpressionResult(ExpressionResult::PUSHED_PRIMITIVE); break;
+				case ExpressionResult::LOCAL:
+				#if (NUXJS_ES5)
+					if (code->isStrict()) {
+						error(SYNTAX_ERROR, "Deleting identifier in strict code");
+					}
+				#endif
+					xr = ExpressionResult(ExpressionResult::CONSTANT, false);
+					break;
+				case ExpressionResult::NAMED:
+				#if (NUXJS_ES5)
+					if (code->isStrict()) {
+						error(SYNTAX_ERROR, "Deleting identifier in strict code");
+					}
+				#endif
+					emitWithConstant(Processor::DELETE_NAMED_OP, xr.v);
+					xr = ExpressionResult(ExpressionResult::PUSHED_PRIMITIVE);
+					break;
 				case ExpressionResult::PROPERTY: emit(Processor::DELETE_OP); xr = ExpressionResult(ExpressionResult::PUSHED_PRIMITIVE); break;
 				default: assert(0);
 			}
@@ -3665,6 +3940,7 @@ bool Compiler::postOperate(ExpressionResult& xr, Precedence precedence) {
 void Compiler::functionDefinition(const String* functionName, const String* selfName) {
 	assert(functionName != 0);
 	Code* func = new(heap) Code(heap.managed(), code->constants);
+	func->strict = code->strict;
 	Compiler funcCompiler(heap.roots(), func, Compiler::FOR_FUNCTION, nestCounter);
 	try {
 		p = funcCompiler.compileFunction(p, e, functionName, selfName);
@@ -3819,6 +4095,11 @@ void Compiler::rvalueGroup() {
 
 // FIX : ok, this is serious mess
 Compiler::ExpressionResult Compiler::declareIdentifier(const String* name, bool func) {
+#if (NUXJS_ES5)
+	if (code->isStrict() && (name->isEqualTo(EVAL_STRING) || name->isEqualTo(ARGUMENTS_STRING))) {
+		error(SYNTAX_ERROR, "Illegal use of eval or arguments in strict code");
+	}
+#endif
 	ExpressionResult lxr(ExpressionResult::NAMED, name);
 	if (compilingFor != FOR_FUNCTION) {
 		CodeSection* previousSection = changeSection(&setupSection);
@@ -3974,6 +4255,11 @@ void Compiler::functionStatement() {
 }
 
 void Compiler::withStatement(SemanticScope* currentScope) {
+#if (NUXJS_ES5)
+	if (code->isStrict()) {
+		error(SYNTAX_ERROR, "\"with\" is not allowed in strict code");
+	}
+#endif
 	rvalueGroup();
 	emit(Processor::WITH_SCOPE_OP);
 	{
@@ -4461,6 +4747,38 @@ const Char* Compiler::compile(const Char* b, const Char* e) {
 	p = b;
 	this->e = e;
 	acceptInOperator = true;
+	const Char* directiveStart = p;
+	white();
+#if (NUXJS_ES5)
+	bool foundStrict = false;
+#endif
+#if (NUXJS_ES5)
+	while (p < e && (*p == '"' || *p == '\'')) {
+		Char q = *p++;
+		const Char* litStart = p;
+		while (p < e && *p != q) {
+			++p;
+		}
+		if (p >= e) {
+			break;
+		}
+		if (!foundStrict && p - litStart == 10 && strncmp(litStart, "use strict", 10) == 0) {
+			foundStrict = true;
+		}
+		++p;
+		white();
+		if (p < e && *p == ';') {
+			++p;
+			white();
+			continue;
+		}
+		break;
+	}
+	if (foundStrict) {
+		code->setStrict(true);
+	}
+#endif
+	p = directiveStart;
 	
 	// FIX : not 100% necessary now because we should always start with undefined on top of stack
 	if (compilingFor == FOR_EVAL) {
@@ -4496,6 +4814,7 @@ const Char* Compiler::compileFunction(const Char* b, const Char* e, const String
 	white();
 	Table& nameIndexes = code->nameIndexes;
 	Vector<const String*>& argumentNames = code->argumentNames;
+	bool hasDuplicateParameters = false;
 	while (!token(")", false)) {
 		if (eof()) {
 			error(SYNTAX_ERROR, argumentNames.size() == 0 ? "Expected ')'" : "Expected ',' or ')'");
@@ -4507,6 +4826,17 @@ const Char* Compiler::compileFunction(const Char* b, const Char* e, const String
 			white();
 		}
 			const String* name = identifier(true, false);
+		#if (NUXJS_ES5)
+			if (code->isStrict() && (name->isEqualTo(EVAL_STRING) || name->isEqualTo(ARGUMENTS_STRING))) {
+				error(SYNTAX_ERROR, "Illegal use of eval or arguments in strict code");
+			}
+		#endif
+		for (size_t i = 0; i < argumentNames.size(); ++i) {
+			if (argumentNames[i]->isEqualTo(*name)) {
+				hasDuplicateParameters = true;
+				break;
+			}
+		}
 		nameIndexes.update(nameIndexes.insert(name), static_cast<Int32>(argumentNames.size()));
 		argumentNames.push(name);
 		code->bloomSet |= name->createBloomCode();
@@ -4515,6 +4845,11 @@ const Char* Compiler::compileFunction(const Char* b, const Char* e, const String
 	expectToken("{", true);
 	compile(p, e); // FIX: ugly as it sets p and e again, although it doesn't hurt
 	expectToken("}", false);
+	#if (NUXJS_ES5)
+		if (code->strict && hasDuplicateParameters) {
+			error(SYNTAX_ERROR, "Duplicate parameter name not allowed in strict code");
+		}
+	#endif
 	code->name = functionName;
 	code->selfName = selfName;
 	code->source = String::concatenate(heap, String(heap.roots(), FUNCTION_SPACE, *functionName), String(heap.roots(), b, p));
@@ -4655,6 +4990,98 @@ void SeparateConstructorFunction::constructCompleteObject(Runtime& rt) const {
 	}
 }
 
+#if (NUXJS_ES5)
+struct BoundFunction : public ExtensibleFunction {
+	typedef ExtensibleFunction super;
+
+	BoundFunction(GCList& gc,
+			Function* target,
+			const Value& boundThis,
+			UInt32 boundArgc,
+			const Value* boundArgv);
+
+	virtual Value invoke(Runtime& rt, Processor& proc,
+			UInt32 argc, const Value* argv, Object* thisObj);
+
+		virtual Value construct(Runtime& rt, Processor& proc,
+				UInt32 argc, const Value* argv, Object* thisObj);
+
+		virtual bool hasInstance(Runtime& rt, Object* object) const;
+	   virtual Function* getConstructTarget();
+
+protected:
+	virtual void constructCompleteObject(Runtime& rt) const;
+	virtual void gcMarkReferences(Heap& heap) const;
+
+private:
+	Function* const target;
+	Value		   boundThis;
+	UInt32		   boundArgc;
+	Value*		   boundArgv;	 /// GC-managed array of pre-bound args
+};
+
+BoundFunction::BoundFunction(GCList& gc,
+		Function* target,
+		const Value& boundThis,
+		UInt32 boundArgc,
+		const Value* boundArgv)
+	: super(gc), target(target), boundThis(boundThis), boundArgc(boundArgc), boundArgv(0) {
+	if (boundArgc > 0) {
+		Heap& heap = gc.getHeap();
+		Value* argvCopy = new(&heap) Value[boundArgc];
+		std::copy(boundArgv, boundArgv + boundArgc, argvCopy);
+		this->boundArgv = argvCopy;
+	}
+}
+
+Value BoundFunction::invoke(Runtime& rt, Processor& proc,
+		UInt32 argc, const Value* argv, Object* thisObj) {
+	VarList args(rt, boundArgc + argc);
+	std::copy(boundArgv, boundArgv + boundArgc, args.begin());
+	std::copy(argv, argv + argc, args.begin() + boundArgc);
+	Object* thisObject = boundThis.toObjectOrNull(rt.getHeap(), false);
+	return target->invoke(rt, proc, boundArgc + argc, args.begin(), thisObject);
+}
+
+Value BoundFunction::construct(Runtime& rt, Processor& proc,
+		UInt32 argc, const Value* argv, Object* thisObj) {
+	VarList args(rt, boundArgc + argc);
+	std::copy(boundArgv, boundArgv + boundArgc, args.begin());
+	std::copy(argv, argv + argc, args.begin() + boundArgc);
+	return target->construct(rt, proc, boundArgc + argc, args.begin(), thisObj);
+}
+
+bool BoundFunction::hasInstance(Runtime& rt, Object* object) const {
+		return target->hasInstance(rt, object);
+}
+
+Function* BoundFunction::getConstructTarget() {
+	   return target->getConstructTarget();
+}
+
+void BoundFunction::constructCompleteObject(Runtime& rt) const {
+	Value v;
+	Flags flags = target->getProperty(rt, &NAME_STRING, &v);
+	if (flags != NONEXISTENT) {
+		completeObject->setOwnProperty(rt, &NAME_STRING, v, flags);
+	}
+	flags = target->getProperty(rt, &LENGTH_STRING, &v);
+	double l = 0;
+	if (flags != NONEXISTENT) {
+		l = v.toDouble() - boundArgc;
+		if (l < 0) l = 0;
+	}
+	completeObject->setOwnProperty(rt, &LENGTH_STRING, Value(l), HIDDEN_CONST_FLAGS);
+}
+
+void BoundFunction::gcMarkReferences(Heap& heap) const {
+	   gcMark(heap, target);
+	   gcMark(heap, boundThis);
+	   gcMark(heap, boundArgv, boundArgv + boundArgc);
+	   super::gcMarkReferences(heap);
+}
+#endif
+
 template<class F> struct UnaryMathFunction : public Function {
 	UnaryMathFunction(F& f) : f(f) { }
 	virtual Value invoke(Runtime&, Processor&, UInt32 argc, const Value* argv, Object*) {
@@ -4729,21 +5156,41 @@ struct Support {
 		return UNDEFINED_VALUE;
 	}
 
-	static Value defineProperty(Runtime& rt, Processor&, UInt32 argc, const Value* argv, Object*) {
+	   static Value defineProperty(Runtime &rt, Processor &, UInt32 argc, const Value *argv, Object *) {
 			   bool success = false;
 			   if (argc >= 2) {
-			Object* o = argv[0].asObject();
+					   Object *o = argv[0].asObject();
 					   if (o != 0) {
-				success = o->setOwnProperty(rt, argv[1], (argc >= 3 ? argv[2] : UNDEFINED_VALUE)
-						, (argc >= 4 && argv[3].toBool() ? READ_ONLY_FLAG : 0)
-						| (argc >= 5 && argv[4].toBool() ? DONT_ENUM_FLAG : 0)
-						| (argc >= 6 && argv[5].toBool() ? DONT_DELETE_FLAG : 0)
-						| EXISTS_FLAG);
+							   Flags flags = (argc >= 4 && argv[3].toBool() ? READ_ONLY_FLAG : 0) |
+											 (argc >= 5 && argv[4].toBool() ? DONT_ENUM_FLAG : 0) |
+											 (argc >= 6 && argv[5].toBool() ? DONT_DELETE_FLAG : 0) | EXISTS_FLAG;
+							   if (argc >= 7) {
+									   Heap &heap = rt.getHeap();
+									   Accessor *acc = new (heap)
+										   Accessor(heap.managed(), argv[6].asFunction(), (argc >= 8 ? argv[7].asFunction() : 0));
+									   success = o->setOwnProperty(rt, argv[1], acc, flags | ACCESSOR_FLAG);
+							   } else {
+									   success = o->setOwnProperty(rt, argv[1], (argc >= 3 ? argv[2] : UNDEFINED_VALUE), flags);
+							   }
 					   }
 			   }
 			   return success;
 	   }
 
+#if (NUXJS_ES5)
+static Value bind(Runtime& rt, Processor&, UInt32 argc, const Value* argv, Object*) {
+	if (argc >= 2) {
+		Function* target = argv[0].asFunction();
+		if (target != 0) {
+			Heap& heap = rt.getHeap();
+			UInt32 boundArgc = (argc > 2 ? argc - 2 : 0);
+			return new(heap) BoundFunction(heap.managed(), target, argv[1], boundArgc, argv + 2);
+		}
+	}
+	return UNDEFINED_VALUE;
+}
+#endif
+
 	   static Value compileFunction(Runtime& rt, Processor&, UInt32 argc, const Value* argv, Object*) {
 			   if (argc >= 1) {
 					   Heap& heap = rt.getHeap();
@@ -4908,12 +5355,15 @@ static struct {
 	FunctorAdapter<NativeFunction> func;
 } SUPPORT_FUNCTIONS[] = {
 	   { "getInternalProperty", Support::getInternalProperty }, { "createWrapper", Support::createWrapper },
-	{ "defineProperty", Support::defineProperty }, { "compileFunction", Support::compileFunction },
-	{ "distinctConstructor", Support::distinctConstructor }, { "callWithArgs", Support::callWithArgs },
-	{ "hasOwnProperty", Support::hasOwnProperty }, { "fromCharCode", Support::fromCharCode },
-	{ "isPropertyEnumerable", Support::isPropertyEnumerable }, { "atan2", Support::atan2 },
-	{ "pow", Support::pow }, { "parseFloat", Support::parseFloat }, { "charCodeAt", Support::charCodeAt },
-	{ "substring", Support::substring }, { "submatch", Support::submatch },
+{ "defineProperty", Support::defineProperty },
+#if (NUXJS_ES5)
+{ "bind", Support::bind },
+#endif
+{ "compileFunction", Support::compileFunction }, { "distinctConstructor", Support::distinctConstructor },
+	   { "callWithArgs", Support::callWithArgs }, { "hasOwnProperty", Support::hasOwnProperty },
+	   { "fromCharCode", Support::fromCharCode }, { "isPropertyEnumerable", Support::isPropertyEnumerable },
+	   { "atan2", Support::atan2 }, { "pow", Support::pow }, { "parseFloat", Support::parseFloat },
+	   { "charCodeAt", Support::charCodeAt }, { "substring", Support::substring }, { "submatch", Support::submatch },
 	   { "getCurrentTime", Support::getCurrentTime }, { "localTimeDifference", Support::localTimeDifference },
 	   { "random", Support::random }, { "updateDateValue", Support::updateDateValue }
 };
@@ -5058,20 +5508,39 @@ Var Runtime::eval(const String& expression) {
 	return runUntilReturn(processor);
 }
 
+#if (NUXJS_ES5)
+Code* Runtime::compileEvalCode(const String* expression, bool strict) {
+const Table::Bucket* bucket = (strict ? 0 : evalCodeCache.lookup(expression));
+if (bucket != 0) {
+Object* o = bucket->getValue().getObject();
+assert(dynamic_cast<Code*>(o) != 0);
+return reinterpret_cast<Code*>(o);
+} else {
+Code* code = new(heap) Code(heap.managed());
+if (strict) { code->setStrict(true); }
+Compiler compiler(heap.roots(), code, Compiler::FOR_EVAL);
+compiler.compile(*expression);
+if (!strict) { evalCodeCache.update(evalCodeCache.insert(expression), code); }
+return code;
+}
+}
+#else
 Code* Runtime::compileEvalCode(const String* expression) {
-	const Table::Bucket* bucket = evalCodeCache.lookup(expression);
-	if (bucket != 0) {
-		Object* o = bucket->getValue().getObject();
-		assert(dynamic_cast<Code*>(o) != 0);
-		return reinterpret_cast<Code*>(o);
-	} else {
-		Code* code = new(heap) Code(heap.managed());
-		Compiler compiler(heap.roots(), code, Compiler::FOR_EVAL);
-		compiler.compile(*expression);
-		evalCodeCache.update(evalCodeCache.insert(expression), code);
-		return code;
-	}
+const Table::Bucket* bucket = evalCodeCache.lookup(expression);
+if (bucket != 0) {
+Object* o = bucket->getValue().getObject();
+assert(dynamic_cast<Code*>(o) != 0);
+return reinterpret_cast<Code*>(o);
+} else {
+Code* code = new(heap) Code(heap.managed());
+Compiler compiler(heap.roots(), code, Compiler::FOR_EVAL);
+compiler.compile(*expression);
+evalCodeCache.update(evalCodeCache.insert(expression), code);
+return code;
 }
+}
+#endif
+
 
 Code* Runtime::compileGlobalCode(const String& source, const String* filename) {
 	Code* code = new(heap) Code(heap.managed());
@@ -5094,6 +5563,9 @@ void Runtime::fetchFunction(const Object* supportObject, const char* name, Funct
 }
 
 extern const char* STDLIB_JS;
+#if (NUXJS_ES5)
+extern const char* STDLIB_ES5_JS;
+#endif
 
 double Runtime::getCurrentEpochTime() {
 	std::time_t t;
@@ -5126,6 +5598,7 @@ void Runtime::setupStandardLibrary() {
 	supportObject->setOwnProperty(*this, &UNDEFINED_STRING, UNDEFINED_VALUE);
 	supportObject->setOwnProperty(*this, &NAN_STRING, NAN_VALUE);
 	supportObject->setOwnProperty(*this, &INFINITY_STRING, INFINITY_VALUE);
+
 	supportObject->setOwnProperty(*this, &MAX_NUMBER_STRING, std::numeric_limits<double>::max());
 	supportObject->setOwnProperty(*this, &MIN_NUMBER_STRING, std::numeric_limits<double>::denorm_min());
 
@@ -5138,8 +5611,12 @@ void Runtime::setupStandardLibrary() {
 	}
 	
 	const Var func = eval(*String::allocate(heap, STDLIB_JS));
-	Value argv[1] = { protectedSupportObject };
-	call(func, 1, argv);
+	Value argv[2] = { protectedSupportObject, UNDEFINED_VALUE };
+#if (NUXJS_ES5)
+	const Var es5(*this, String::allocate(heap, STDLIB_ES5_JS));
+	argv[1] = es5;
+#endif
+	call(func, 2, argv);
 	
 	fetchFunction(supportObject, "toPrimitive", toPrimitiveFunctions + 0);
 	fetchFunction(supportObject, "toPrimitiveNumber", toPrimitiveFunctions + 1);
diff --git a/src/NuXJS.h b/src/NuXJS.h
index 98904d6..402bb79 100644
--- a/src/NuXJS.h
+++ b/src/NuXJS.h
@@ -24,6 +24,17 @@
 #ifndef NuXJS_h
 #define NuXJS_h
 
+// ---------------------------------------------------------------------------
+// ES version toggle
+//
+// NUXJS_ES5 controls ES5 features and semantics. Keep default at 0 so that
+// building without an explicit -DNUXJS_ES5=1 matches legacy ES3 behavior from
+// the main branch exactly.
+// ---------------------------------------------------------------------------
+#ifndef NUXJS_ES5
+#define NUXJS_ES5 1
+			#endif
+
 #include "assert.h"
 #include <algorithm>
 #include <string>
@@ -447,16 +458,19 @@ const Flags READ_ONLY_FLAG = 2;
 const Flags DONT_ENUM_FLAG = 4;
 const Flags DONT_DELETE_FLAG = 8;
 const Flags INDEX_TYPE_FLAG = 16;	///< internal index type, only used as an optimization for faster name -> local index lookup
+const Flags ACCESSOR_FLAG = 32;		  ///< property stores accessor pair
 const Flags STANDARD_FLAGS = EXISTS_FLAG;	///< use with setOwnProperty()
 const Flags HIDDEN_CONST_FLAGS = READ_ONLY_FLAG | DONT_ENUM_FLAG | DONT_DELETE_FLAG | EXISTS_FLAG;
 const Flags NONEXISTENT = 0;		///< use with getOwnProperty() to check for existence, e.g. getOwnProperty(o, k, v) != NONEXISTENT
 const UInt32 TABLE_BUILT_IN_N = 3; ///< 1 << 3 == 8
 
+class Accessor;
 /**
 	Table implements a hash table for storing object properties. It provides fast lookup and is used internally by JS
 	objects.
 **/
 class Table {
+	   friend struct Support;
 	   public:
 		/**
 			The main reason why Bucket doesn't contain the Value class, but rather holds it's own Byte type and Variant
@@ -465,6 +479,7 @@ class Table {
 		**/
 			   class Bucket {
 					   friend class Table;
+					   friend struct Support;
 
 			public:
 				Bucket() : key(0) { };
@@ -538,13 +553,22 @@ class Object : public GCItem {
 		virtual Object* getPrototype(Runtime& rt) const;		///< Default returns the Object prototype.
 
 		virtual Flags getOwnProperty(Runtime& rt, const Value& key, Value* v) const;								///< Don't touch v if you return NONEXISTENT. Default returns NONEXISTENT.
+		#if (NUXJS_ES5)
+		virtual bool setOwnProperty(Runtime& rt, const String* key, const Value& v, Flags flags = STANDARD_FLAGS);	///< Insert a new or update an existing property. Return false if not possible (e.g. read-only property already exists). Default returns false.
+		#endif
 		virtual bool setOwnProperty(Runtime& rt, const Value& key, const Value& v, Flags flags = STANDARD_FLAGS);	///< Insert a new or update an existing property. Return false if not possible (e.g. read-only property already exists). Default returns false.
 		virtual bool updateOwnProperty(Runtime& rt, const Value& key, const Value& v);								///< Update existing property. Return false if it doesn't exist or can't be updated (e.g. read-only property exists). Can be overriden for optimization. (Default implementation checks existence with hasOwnProperty() first.)
 		virtual bool deleteOwnProperty(Runtime& rt, const Value& key);												///< Default returns false.
 		virtual Enumerator* getOwnPropertyEnumerator(Runtime& rt) const;											///< Default returns an empty enumerator.
 
 		Flags getProperty(Runtime& rt, const Value& key, Value* v) const;	///< Searches prototype chain.
+		#if (NUXJS_ES5)
+		Flags getProperty(Runtime& rt, Processor& processor, const Value& key, Value* v) const;
+		#endif
 		bool setProperty(Runtime& rt, const Value& key, const Value& v);	///< First tries updateOwnProperty(). If that fails, checks prototype chain for read-only property with the same name and returns false if found. Otherwise attempts to insert a new property with setOwnProperty() and returns its outcome.
+		#if (NUXJS_ES5)
+		bool setProperty(Runtime& rt, Processor& processor, const Value& key, const Value& v);
+		#endif
 		bool isOwnPropertyEnumerable(Runtime& rt, const Value& key) const;
 		bool hasOwnProperty(Runtime& rt, const Value& key) const;			///< Checks via getOwnProperty().
 		bool hasProperty(Runtime& rt, const Value& key) const;				///< Checks via getProperty().
@@ -707,6 +731,12 @@ class JSObject : public Object, public Table {
 		JSObject(GCList& gcList, Object* prototype);
 		virtual Object* getPrototype(Runtime& rt) const;
 		virtual Flags getOwnProperty(Runtime& rt, const Value& key, Value* v) const;
+		#if (NUXJS_ES5)
+		#if (NUXJS_ES5)
+
+		virtual bool setOwnProperty(Runtime& rt, const String* key, const Value& v, Flags flags = STANDARD_FLAGS);
+		#endif
+		#endif
 		virtual bool setOwnProperty(Runtime& rt, const Value& key, const Value& v, Flags flags = STANDARD_FLAGS);
 		virtual bool updateOwnProperty(Runtime& rt, const Value& key, const Value& v);
 		virtual bool deleteOwnProperty(Runtime& rt, const Value& key);
@@ -738,10 +768,14 @@ class JSObject : public Object, public Table {
 	This class is a template so this concept can be used with different super classes.
 **/
 template<class SUPER> class LazyJSObject : public SUPER {
+	friend struct Support;
 	public:
 			typedef SUPER super;
 			LazyJSObject(GCList& gcList) : super(gcList), completeObject(0) { }
 			virtual Flags getOwnProperty(Runtime& rt, const Value& key, Value* v) const;
+			#if (NUXJS_ES5)
+			virtual bool setOwnProperty(Runtime& rt, const String* key, const Value& v, Flags flags = STANDARD_FLAGS);
+			#endif
 			virtual bool setOwnProperty(Runtime& rt, const Value& key, const Value& v, Flags flags = STANDARD_FLAGS);
 			virtual bool deleteOwnProperty(Runtime& rt, const Value& key);
 			   virtual Enumerator* getOwnPropertyEnumerator(Runtime& rt) const;
@@ -773,6 +807,9 @@ class JSArray : public LazyJSObject<Object> {
 		virtual Object* getPrototype(Runtime& rt) const;
 		// FIX : toString too?
 		virtual Flags getOwnProperty(Runtime& rt, const Value& key, Value* v) const;
+		#if (NUXJS_ES5)
+		virtual bool setOwnProperty(Runtime& rt, const String* key, const Value& v, Flags flags = STANDARD_FLAGS);
+		#endif
 		virtual bool setOwnProperty(Runtime& rt, const Value& key, const Value& v, Flags flags = STANDARD_FLAGS);
 		virtual bool updateOwnProperty(Runtime& rt, const Value& key, const Value& v);
 		virtual bool deleteOwnProperty(Runtime& rt, const Value& key);
@@ -833,6 +870,8 @@ class Code : public Object {
 		const String* getName() const { return name; }
 		const String* getSource() const { return source; }
 		UInt32 getMaxStackDepth() const { return maxStackDepth; }
+		bool isStrict() const { return strict; }
+		void setStrict(bool v) { strict = v; }
 		UInt32 calcLocalsSize(UInt32 argc) const { return getVarsCount() + std::max(getArgumentsCount(), argc); }
 
 	protected:
@@ -846,6 +885,7 @@ class Code : public Object {
 		const String* source;
 		UInt32 bloomSet;							///< Bloom bits of all local variables, arguments (+ self name and "arguments"). For faster scope resolution.
 		UInt32 maxStackDepth;
+		bool strict;
 
 		virtual void gcMarkReferences(Heap& heap) const {
 			gcMark(heap, constants);
@@ -873,6 +913,9 @@ class Function : public Object {
 			   virtual const String* toString(Heap& heap) const;
 			   virtual Value getInternalValue(Heap& heap) const;
 			   virtual Object* getPrototype(Runtime& rt) const;
+			   #if (NUXJS_ES5)
+			   virtual Function* getConstructTarget();
+			   #endif
 			   virtual Value construct(Runtime& rt, Processor& processor, UInt32 argc, const Value* argv, Object* thisObject);
 		virtual bool hasInstance(Runtime& rt, Object* object) const;
 		virtual const Code* getScriptCode() const { return 0; }
@@ -883,6 +926,20 @@ class Function : public Object {
 		Function(GCList& gcList) : super(gcList) { }
 };
 
+class Accessor : public Object {
+	public:
+		Accessor(GCList& gcList, Function* g, Function* s)
+			: Object(gcList), getter(g), setter(s) { }
+		Function* getter;
+		Function* setter;
+	protected:
+		virtual void gcMarkReferences(Heap& heap) const {
+			gcMark(heap, getter);
+			gcMark(heap, setter);
+			super::gcMarkReferences(heap);
+		}
+};
+
 typedef Value (*NativeFunction)(Runtime&, Processor&, UInt32, const Value*, Object*);
 
 // FIX : overkill?
@@ -983,6 +1040,9 @@ class Error : public LazyJSObject<Object> {
 		virtual const String* toString(Heap& heap) const;
 		virtual Value getInternalValue(Heap& heap) const; // error type name
 		virtual Object* getPrototype(Runtime& rt) const;
+		#if (NUXJS_ES5)
+		virtual bool setOwnProperty(Runtime& rt, const String* key, const Value& v, Flags flags = STANDARD_FLAGS);
+		#endif
 		virtual bool setOwnProperty(Runtime& rt, const Value& key, const Value& v, Flags flags = STANDARD_FLAGS);
 		virtual bool deleteOwnProperty(Runtime& rt, const Value& key);
 		ErrorType getErrorType() const;
@@ -1007,12 +1067,16 @@ class FunctionScope;
 class Arguments : public LazyJSObject<Object> {
 	public:
 		typedef LazyJSObject<Object> super;
+		friend class FunctionScope;
 
 		Arguments(GCList& gcList, const FunctionScope* scope, UInt32 argumentsCount);
 		virtual const String* getClassName() const; // &A_RGUMENTS_STRING
 		virtual const String* toString(Heap& heap) const;
 		virtual Object* getPrototype(Runtime& rt) const;
 		virtual Flags getOwnProperty(Runtime& rt, const Value& key, Value* v) const;
+		#if (NUXJS_ES5)
+		virtual bool setOwnProperty(Runtime& rt, const String* key, const Value& v, Flags flags = STANDARD_FLAGS);
+		#endif
 		virtual bool setOwnProperty(Runtime& rt, const Value& key, const Value& v, Flags flags = STANDARD_FLAGS);
 		virtual bool deleteOwnProperty(Runtime& rt, const Value& key);
 		virtual Enumerator* getOwnPropertyEnumerator(Runtime& rt) const;
@@ -1027,6 +1091,7 @@ class Arguments : public LazyJSObject<Object> {
 		UInt32 const argumentsCount;
 		Vector<Byte> deletedArguments;
 		Vector<Value> values;	// Contains copied values after the Argument has been detached from its closure.
+		FunctionScope* owner;	// Weak reference to owning FunctionScope for cleanup.
 
 		/**
 			Notice that we do not mark the scope reference, thus creating a "weak" reference that is handled by
@@ -1133,7 +1198,11 @@ class Runtime : public GCItem {
 		JSArray* newJSArray(UInt32 initialLength = 0) const;	///< Convenience routine for `new(heap) JSArray(heap.managed(), initialLength)`
 		const String* newStringConstant(const char* s);
 
-		Code* compileEvalCode(const String* expression);
+#if (NUXJS_ES5)
+Code* compileEvalCode(const String* expression, bool strict = false);
+#else
+Code* compileEvalCode(const String* expression);
+#endif
 		Code* compileGlobalCode(const String& source, const String* filename = 0);
 
 		Var getGlobalsVar();							///< Convenience routine for `Var(rt, rt.getGlobalObject())`
@@ -1338,15 +1407,43 @@ class Property : public AccessorBase {
 	friend class AccessorBase;
 
   public:
-		template<typename T> const Property& operator=(const T& v) const { object->setProperty(rt, key, Var(rt, v)); return *this; }
-		template<typename T> const Property& operator+=(const T& r) const { object->setProperty(rt, key, get().add(rt.getHeap(), makeValue(r))); return *this; }
+	template <typename T> const Property &operator=(const T &v) const {
+		Value current;
+		Flags flags = object->getProperty(rt, key, &current);
+		if (flags != NONEXISTENT && (flags & ACCESSOR_FLAG) != 0) {
+			Accessor *acc = static_cast<Accessor *>(current.asObject());
+			Function *setter = (acc != 0 ? acc->setter : 0);
+			if (setter != 0) {
+				Value arg = Var(rt, v);
+				rt.call(setter, 1, &arg, object);
+				return *this;
+			}
+		}
+		object->setProperty(rt, key, Var(rt, v));
+		return *this;
+	}
+	template <typename T> const Property &operator+=(const T &r) const {
+		object->setProperty(rt, key, get().add(rt.getHeap(), makeValue(r)));
+		return *this;
+	}
 
   protected:
 	typedef AccessorBase super;
-		Property(Runtime& rt, Object* object, const Var& key) : super(rt), object(object), key(key) { }
-		virtual Value get() const { Value v(UNDEFINED_VALUE); object->getProperty(rt, key, &v); return v; }
-		virtual Var call(int argc, const Value* argv) const { return rt.call(*this, argc, argv, object); }
-		Object* const object;
+	Property(Runtime &rt, Object *object, const Var &key) : super(rt), object(object), key(key) {}
+	virtual Value get() const {
+		Value v(UNDEFINED_VALUE);
+		Flags flags = object->getProperty(rt, key, &v);
+		if (flags != NONEXISTENT && (flags & ACCESSOR_FLAG) != 0) {
+			Accessor *acc = static_cast<Accessor *>(v.asObject());
+			Function *getter = (acc != 0 ? acc->getter : 0);
+			return (getter != 0 ? rt.call(getter, 0, 0, object) : UNDEFINED_VALUE);
+		}
+		return v;
+	}
+	virtual Var call(int argc, const Value *argv) const {
+		return rt.call(*this, argc, argv, object);
+	}
+	Object *const object;
 	const Var key;
 };
 
@@ -1530,7 +1627,11 @@ class Processor : public GCItem {
 			, GET_PROPERTY_OP								// stack: object, name -> value
 			, SET_PROPERTY_OP								// stack: object, name, value -> value
 			, SET_PROPERTY_POP_OP							// stack: object, name, value ->
-			, ADD_PROPERTY_OP								// operand: const_index (name), stack: object, value -> object
+				, ADD_PROPERTY_OP							// operand: const_index(name), stack: object, value -> object
+			#if (NUXJS_ES5)
+						, ADD_GETTER_OP							 // operand: const_index(name), stack: object, function -> object
+						, ADD_SETTER_OP							 // operand: const_index(name), stack: object, function -> object
+			#endif
 				, PUSH_ELEMENTS_OP							// operand: count, stack: object, count * elements ... -> object
 			, OBJ_TO_PRIMITIVE_OP							// stack: value -> primitive_value (no preference)	// these three must be in this exact order
 			, OBJ_TO_NUMBER_OP								// stack: value -> primitive_value (number preferred)
@@ -1585,7 +1686,12 @@ class Processor : public GCItem {
 		};
 	
 		struct OpcodeInfo {
-			enum { TERMINAL = 1, POP_OPERAND = 2, POP_ON_BRANCH = 4, NO_POP_ON_BRANCH = 8 };
+			enum {
+				TERMINAL = 1,			/// instruction ends current basic block
+				POP_OPERAND = 2,	/// pop `operand` values after execution
+				POP_ON_BRANCH = 4,	/// branch path pops the top of stack
+				NO_POP_ON_BRANCH = 8	/// branch path keeps the top of stack
+			};
 			Opcode opcode;
 			const char* mnemonic;
 			Int32 stackUse;
@@ -1600,12 +1706,13 @@ class Processor : public GCItem {
 		Processor(Runtime& rt);
 		void invokeFunction(Function* f, Int32 argc, const Value* argv, Object* thisObject = 0);
 		void enterGlobalCode(const Code* code);
-		void enterEvalCode(const Code* code, bool local = false);
+		void enterEvalCode(const Code* code, bool direct = false);
 		void enterFunctionCode(JSFunction* func, UInt32 argc, const Value* argv, Object* thisObject = 0);
 		void throwVirtualException(const Value& exception);
 		void error(ErrorType errorType, const String* message = 0);
 		bool run(Int32 maxCycles);
 		Value getResult() const;	// make sure you've called run() until it returns false before calling this
+		bool isCurrentStrict() const { return currentFrame != 0 && currentFrame->code->isStrict(); }
 
 	protected:
 		struct Frame : public GCItem {
