class GCItem {
	friend class GCList;
	friend class Heap;

	// The overloaded `new` operator enforces allocation of GCItems on Heaps because:
	// 1) The item's memory will be accounted for in the total memory used by the Heap.
	// 2) Performance is improved by reusing recently deallocated memory through memory pools.
	public:
		// Allocates memory for a GCItem on a Heap.
		static void* operator new(size_t n, Heap& heap);

		// Deletes a GCItem and its associated memory, using the stored Heap pointer.
		static void operator delete(void* ptr);

		// Deletes a GCItem and its associated memory, using the provided Heap.
		static void operator delete(void* ptr, Heap& heap);

	protected:
		// Default constructor initializes the GCItem with no associated GCList.
		GCItem() throw();

		// Constructor initializes the GCItem with the specified GCList.
		GCItem(GCList& gcList) throw();

		// Copy constructor.
		GCItem(const GCItem& copy) throw();

		// Assignment operator (no-op).
		GCItem& operator=(const GCItem&) throw();

		// Returns the Heap associated with the GCItem.
		Heap& gcGetHeap() const;

		// Marks all GCItems referenced by this item. Subclasses should override this method.
		virtual void gcMarkReferences(Heap&) const;

		// Destructor removes the GCItem from its associated GCList.
		virtual ~GCItem();

		// Utility function for marking a GCItem during garbage collection.
		friend void gcMark(Heap& heap, const GCItem* item);

		// GCList associated with the GCItem.
		GCList* _gcList;

		// Previous and next GCItems in the GCList.
		GCItem* _gcPrev;
		GCItem* _gcNext;

	#ifndef NDEBUG
		// In debug target, we check that sub-classes call gcMarkReferences() all the way up to the GCItem.
		mutable bool _gcReferenceMarkingComplete;
	#endif

	private:
		// Disallow new[] and delete[] operators.
		static void* operator new[](size_t, Heap* heap);
		static void operator delete[](void*);
};

// GCList represents a double-linked circular list with a dummy node for managing GCItems.
class GCList : public GCItem {
	friend class GCItem;
	friend class Heap;

	public:
		// Returns the Heap associated with the GCList.
		Heap& getHeap() const throw();

		// Returns true if the GCList owns the specified GCItem.
		bool owns(const GCItem* item) throw();

		// Claims ownership of the specified GCItem.
		void claim(GCItem* item) throw();

		// Releases ownership of the specified GCItem.
		void relinquish(GCItem* item) throw();

		// Deletes all GCItems in the GCList.
		void deleteAll() throw();

	protected:
		// Constructor initializes the GCList with the specified Heap.
		GCList(Heap& heap);

		// Associated Heap.
		Heap& heap;

		// Number of GCItems in the GCList.
		UInt32 count;
};

// Heap class manages memory allocation, garbage collection, and GCLists for GCItems.
class Heap {
	public:
		// Constructor initializes the Heap.
		Heap();

		// Returns the managed GCList.
		GCList& managed() throw();

	
		// Returns the root GCList.
		GCList& roots() throw();

		// Allocates memory of the specified size.
		// Allocated memory is *not* automatically released when Heap is destroyed
		// (unless it is indirectly freed via the deletion of all managed GCItems).
		void* allocate(size_t size);

		// Frees the memory pointed to by ptr. Null pointer is not ok, and
		// you must not free an already freed pointer.
		void free(void* ptr);

		// Frees pooled blocks. Suggestion: call before each gc to only hold on
		// to as much memory as required since the last gc.
		void drain();

		// Returns the count of allocated GCItems.
		UInt32 count() const;

		// Returns the total size of allocated memory.
		size_t size() const;

		// Returns the size of pooled memory.
		size_t pooled() const;

		// Performs garbage collection.
		void gc();

		// Destructor frees all allocated memory.
		virtual ~Heap();

		// Utility function for marking a GCItem during garbage collection.
		friend void gcMark(Heap& heap, const GCItem* item);

	protected:
		// Acquires memory of the specified size. Subclasses can override
		// for custom memory allocation.
		virtual void* acquireMemory(size_t size);

		// Releases memory of the specified size. Subclasses can override
		// for custom memory deallocation.
		virtual void releaseMemory(void* ptr, size_t size);

		// Calculates the pool index for a given allocation size.
		static int calcPoolIndex(size_t size);

		// Array of memory pools.
		void* pools[MAX_POOLED_SIZE / POOL_SIZE_GRANULARITY];

		// Count of allocated GCItems.
		UInt32 allocatedCount;

		// Total size of allocated memory.
		size_t allocatedSize;

		// Size of pooled memory.
		size_t pooledSize;

		// GCLists for managing and rooting GCItems.
		GCList managedListA;
		GCList managedListB;
		GCList rootList;

		// Pointers to the current and new GCLists during garbage collection.
		GCList* currentList;
		GCList* newList;

	private:
		// Disallow copy constructor and assignment operator.
		Heap(const Heap& that);
		Heap& operator=(const Heap& that);
};
