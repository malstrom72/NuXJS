# NuXJS Documentation

## Introduction

NuXJS is a sandboxed JavaScript engine implemented in portable C++03. It has been tested with GCC and Clang on x86-64 and ARM, as well as with MSVC on Windows. The core consists of a single `.cpp` file, a single `.h` file, and a `.js` standard library (also available as a `.cpp` array for embedding). It features a fast, stack-based virtual machine, is fully compatible with ECMAScript 3, and includes partial support for useful ECMAScript 5 features like JSON and indexed string access.

## Building NuXJS

Helper scripts are available under `tools/` for building and running the test suite. The recommended entry point is:

'''bash
./build.sh
'''

On Windows, use `build.cmd` instead.

This wrapper builds and tests both the `beta` and `release` configurations by invoking `tools/buildAndTest.sh`. Each build runs its own tests. When both complete, the native release REPL is saved as `output/NuXJScript`.

The implementation depends on IEEE-compliant floating-point math. `src/NuXJScript.cpp` includes `#error` directives that trigger if `__FAST_MATH__` is defined. Avoid compiler flags like `-Ofast`, `-ffast-math`, or similar, at least for `src/NuXJScript.cpp`.

The standard library lives in `src/stdlib.js`. During the build, it is minified and converted to C++ via `tools/stdlibToCpp.pika` using `PikaCmd`. The build scripts automatically regenerate `src/stdlibJS.cpp` when `stdlib.js` changes.

## Embedding NuXJS

The high-level C++ API allows easy embedding of the interpreter into an existing application. Functions exposed to JavaScript typically have the signature `Var func(Runtime& rt, const Var& thisVar, const VarList& args)` and are stored in the global object like any other value. Source code may be executed with `Runtime::run()` or evaluated with `Runtime::eval()`.

A minimal "hello world" program looks like this:

```cpp
#include <NuXJScript.h>
using namespace NuXJS;

int main() {
    Heap heap;
    Runtime rt(heap);
    rt.setupStandardLibrary();
    Var msg = rt.eval("'hello ' + 'world'");
    std::wcout << msg << std::endl;
}
```

### The Var Type

`Var` represents a JavaScript value tied to a particular runtime. It derives from `AccessorBase`, which provides conversions and property access. A `Var` automatically roots its value, so it will not be garbage collected while C++ code holds it. Conversions such as `operator double()` and `operator std::wstring()` return primitives (without invoking custom `valueOf` or `toString`). `Var` instances can be called like functions and indexed like objects. The companion `VarList` class stores argument arrays for function calls.

### Extended Example

The following program shows how to expose a native function, enforce memory and time limits, and call back and forth between C++ and JavaScript:

```cpp
#include <NuXJScript.h>
using namespace NuXJS;

// Native function used from JavaScript.
static Var sum(Runtime& rt, const Var&, const VarList& args) {
    double total = 0.0;
    for (int i = 0; i < args.size(); ++i)
        total += args[i];
    return Var(rt, total);
}

int main() {
    Heap heap;
    Runtime rt(heap);
    rt.setupStandardLibrary();
    rt.setMemoryCap(1024 * 1024); // 1 MB cap
    rt.resetTimeOut(10);          // 10‑second time limit
    Var globals = rt.getGlobalsVar();

    globals["sum"] = sum;
    rt.run("function demo(a,b,c){return 'a+b+c = ' + sum(a,b,c);}");
    std::wcout << globals["demo"](7, 15, 20) << std::endl;

    Var silly = rt.eval("(function(){return arguments;})");
    Var arg0(rt, "131");
    const Value nums[10] = { arg0, 535, 236, 984, 456.5, 666, 626, 585, 382, 109.5 };
    Var list = silly(VarList(rt, 10, nums));
    std::wcout << globals["sum"]["apply"](Value::NUL, list) << std::endl;

    const int y = 2008, m = 7, d = 20;
    Var date = rt.eval("(function(y,m,d){return new Date(y,m,d)})")(y, m, d);
    std::wcout << date << std::endl;
    std::wcout << date["toString"]() << std::endl;

    Var arr = rt.eval("[4,8,15,16,23,42]");
    for (Var::const_iterator it = arr.begin(); it != arr.end(); ++it)
        std::wcout << arr[*it] << ' ';
    std::wcout << std::endl;
}
```

This mirrors the JavaScript idioms used in the engine's high‑level API and illustrates how `Var` and `VarList` manage lifetime and conversions between the two languages.

## Runtime Architecture

NuXJS utilizes a simple stack machine that runs bytecode generated by a single-pass compiler. `Processor` objects interpret the code on behalf of a `Runtime`. You can create multiple processors for the same runtime, for instance, when a C++ callback calls back into JavaScript. Because the interpreter is asynchronous, applications can call `Processor::run(maxCycles)` repeatedly to interleave JavaScript execution with other tasks.

## Memory Management

A `Heap` in NuXJS is a shallow class that implements a simple "mark and sweep" ("stop-the-world") garbage collector. It also maintains "memory pools" for improved performance, but uses the standard C++ heap for allocating larger objects and for expanding the pools. An application may spawn and use several JavaScript engines simultaneously and normally, each engine (or `Runtime`) has its own `Heap`. `Heap` can be subclassed for custom allocation methods.

Virtually every object that is dynamically allocated in NuXJS inherits from `GCItem`. A `GCItem` normally belongs to one of two lists inside a `Heap`: the list of root items or the list of managed items. You place them there by passing the list to the `GCItem` constructor (e.g. `GCItem(myHeap.managed())`) or by calling `GCList::claim(...)`. (You obtain the list of root items with `Heap::roots()` and the list of managed items with `Heap::managed()`.)

Managed items are subject to garbage collection (via the `Heap::gc()` routine). When a managed item is not reachable directly or indirectly from any of the root items, it will be deleted from the heap. Thus, managed items must be dynamically allocated. You need to allocate such items on a `Heap` using the overloaded `new` operator like this: `new(myHeap) MyItem(myHeap.managed())`.

Root items do not need to be allocated on a `Heap`. They can be constructed and destructed in any way you wish. For example, it is okay to have root items on the C++ stack. It is important to ensure that other items do not reference root items when they go out of scope / are deallocated. You can move an item from one list to the other by calling `GCList::claim(...)`. E.g., to turn a root item that was allocated with `new(heap)` into a managed item, write: `myHeap.managed().claim(myFormerRootItem)`.

In rare circumstances, it is ok not to place a `GCItem` on a heap at all. The item will, in this case, never be a candidate for garbage collection, but it will also never mark any of its references. In other words, this item must be a terminal leaf that has no further unique references. (One use case of this is for global constant Strings, e.g., `const String MAGNUS_STRING("Magnus")`.)

When a `GCItem` is destructed (regardless of whether it is from automatic garbage collection or not), it is removed from the list it belongs to. This enables heaps to contain a mixture of automatically garbage-collected and manually memory-managed items. It also means that it is always ok to manually delete an item (including managed items) once you are done with it provided that you can guarantee that it can no longer be reached, of course. This might ease the burden on the garbage collector and speed up allocation.

Every sub-class of `GCItem` is responsible for overriding `gcMarkReferences(Heap& heap)` to mark all `GCItem`s it references (via the overloaded `gcMark(heap, ...)` functions). Remember also to call the super-class's `gcMarkReferences` in the overridden method. If `gcMarkReferences` is implemented incorrectly, items that are still in use may get garbage collected (= deadly sin).

Garbage collection is either invoked manually with `Heap::gc()` or automatically via `Runtime::autoGC()`. Automatic garbage collection occurs when the number of bytes on a heap reaches a threshold that is two times the heap's size after the last garbage collection. It is also possible to impose a hard limit on the heap's size.

## Creating Strings

Strings store UTF‑16 data. When a new string should live on a heap, you may allocate it directly with `new(heap) String(heap.managed(), text)` or use the helper `String::allocate(heap, "text")`. Temporary root strings can be constructed on the stack using `String(heap.roots(), ...)`. Global constant strings can be created without a heap using `String string("text")`.

Note: `wchar_t` strings are converted based on the native size of `wchar_t` — UTF‑16 when it is 16 bits and UTF‑32 when it is 32 bits. Plain `char*` and `std::string` values are treated as ISO‑8859‑1 text for fast byte‑for‑byte copying. Use wide strings when full Unicode input is required.

NuXJS provides several convenience routines for constructing managed strings:

```
String::allocate(heap, "foo")            // copy from ISO-8859-1 literal
String::concatenate(heap, left, right)   // join two existing strings
String::fromInt(heap, 42)                // formatted integer (cached for -1000..1000)
String::fromDouble(heap, 3.14)           // formatted double with special handling for NaN/Inf
```

`String::fromInt` and `String::fromDouble` return pointers to static constant strings for small integers and special floating point values. For other values, a fresh heap string is created every call.

## Exception Handling

JavaScript code uses ordinary `throw` statements and `try`/`catch` blocks. When an exception propagates to C++, a `ScriptException` is thrown. It owns the underlying `Error` object and exposes its message through `what()`. Compilation errors are reported via `CompilationError`, which additionally stores the filename, character offset, and line number. The runtime may also throw a `ConstStringException` for conditions such as running out of memory or hitting a timeout. Embedding code typically catches `ScriptException`:

```cpp
try {
    rt.run("someScript();");
} catch (const ScriptException& ex) {
    std::wcerr << ex.what() << std::endl;
}
```

Native functions can raise script errors using `ScriptException::throwError(heap, type, message)`. This helper creates a JavaScript `Error` instance and throws it as a `ScriptException` so that JavaScript can catch it normally:

```cpp
if (touchFunction.typeOf() != &FUNCTION_STRING) {
    ScriptException::throwError(heap, GENERIC_ERROR, "cannot compile JS gui-variable (touch is not a function)");
}
```

When your native code may throw exceptions of its own, convert them to script errors so JavaScript callers can handle them:

```cpp
Var loadFile(Runtime& rt, const Var&, const VarList& args) {
    Heap& heap = rt.getHeap();
    try {
		const String* filenameString = args[0];
		const std::string filenameUTF8 = filenameString->toUTF8String();
        std::ifstream f(filenameUTF8.c_str());
        if (!f) {
            ScriptException::throwError(heap, GENERIC_ERROR, "failed to open file");
        }
        // read file here
    } catch (const std::exception& e) {
        ScriptException::throwError(heap, GENERIC_ERROR, e.what());
    } catch (...) {
        ScriptException::throwError(heap, GENERIC_ERROR, "native exception");
    }
    return Var(rt);
}
```

## Standard Library and JavaScript Features

The engine ships with a standard library implemented in JavaScript, providing the objects described in ECMAScript&nbsp;3. It also offers selected ECMAScript&nbsp;5 functionality including JSON and string indexing.

## Conformance and Known Limitations

### ES3 deviations

* `\0` is interpreted as a null character even if digits follow (octal escapes are not supported).
* Unicode line separator (`\u2028`) and paragraph separator (`\u2029`) are treated as linefeeds. The non‑breaking space (`\u00A0`) counts as white space, but the zero-width no‑break space (`\uFEFF`) does not. No other Unicode "space separator" characters are recognised.
* Custom property getters and setters are not implemented.
* Implicit `valueOf` and `toString` conversions may happen earlier than specified, for example, `v[o]++` only invokes `toString()` once.
* Octal (`0o`) and binary (`0b`) prefixes are not understood when converting strings to numbers.
* The `arguments` object follows ES3 mapping semantics; changing element attributes does not fully emulate the ES5 behaviour.
* Every created function has a writable, enumerable, and configurable `name` property.
* Evaluation order of member expressions follows the ES3 order (object and arguments evaluated before selecting the member).
* When the identifier of a `catch` clause is called as a function, its `this` value is the global object.
* Assignments evaluate the right-hand side before resolving the reference on the left-hand side.
* Property access may convert the property key before converting the base object.
* In regular expressions the lookahead operators `?=` and `?!` cannot be quantified as in ES3; they behave like the ES5 assertions.
* Case-insensitive ranges in regular expressions and zero-length captures inside repeats may not perfectly match other engines.
* A semicolon is required after `do ... while` statements. This matches the ES3 and ES5 grammar, even though ES6 made the semicolon optional.
* Creating a numeric property on an object can shadow a read-only numeric property in the prototype chain.
* Several tests under `tests/unconforming` demonstrate additional corner cases.
* Assigning an object to an array's `length` property is unsupported.
* Recursive grammar constructs are limited to 64 levels to avoid a C++ stack overflow.

### Partial ES5 features

| Feature | Support |
| ------- | ------- |
| `Array.isArray` | yes |
| `Object.prototype.hasOwnProperty` | yes |
| `Object.prototype.isPrototypeOf` | yes |
| `Object.getPrototypeOf` | yes |
| `Object.defineProperty` | data properties only |
| `JSON.parse` / `JSON.stringify` | yes |
| String indexing | yes |
| `eval()` direct vs indirect | yes |
| `String.prototype.match` | ES5 behaviour |
| `Date` object | most ES5 methods |
| Unicode format control | preserved |

### ES6-inspired extras

* `Array.prototype.splice` with a single argument deletes the rest of the array.
* Regular expression flags cannot contain Unicode escapes.

## Testing and Benchmarking

The test suite resides in the `tests/` directory and is exercised by running the helper script `tools/buildAndTest.sh`. Additional benchmark programs are found under `benchmarks/`.

## Contributing

Patches should be validated by running `./build.sh` before submission. Follow the existing C++03 style (avoid STL containers) and adhere to the naming conventions listed above.

### Source Code Conventions

- `const String&` arguments never saves pointer to the argument, temporary (unmanaged) instances of `String()` are
  allowed.
- `getXXX()` implies that there will be an assertion failure if the value is not of type XXX.
- `asXXX()` implies that zero will be returned if the value is not of type XXX.
- `toXXX()` implies that the value will be converted to type XXX if necessary and an exception might be thrown if it is
  not possible.

## License

NuXJS is released under the terms of the BSD&nbsp;2‑Clause license.  See the `LICENSE` file for details.
