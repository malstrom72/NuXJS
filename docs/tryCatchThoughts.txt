try { try { throw "hej" } catch (x) { console.log(x) } } catch (x) { console.log(x) }
hej
undefined
try { throw "hej" } catch (x) { console.log(x); try { throw "du" } catch (x) { console.log(x) }; console.log(x) }
hej
du
hej

f=function() { try { var x = 7; print(x); throw "hej" } catch (x) { print(x); throw x } finally { print("final"); }; print("yeah") }

 
	PUSH_CATCH @c
		PUSH_CATCH @a -> push catch address
			blahblah
		POP_CATCH -> pop catch address
		JMP @b
a:			catchblock
b:		POP_CATCH @c
c:
 
 
 
	try { } catch (x) { }
	 
	CATCH @a
		{ try block }
	NO_CATCH @b
a:		WRITE_INDEXED x
		POP
		{ catch block }
b:
 
 
 
	try { } finally { }
	
	CATCH @a
		{ try block }
	PUSH #false
	NO_CATCH @b
a:		PUSH #true
b:		{ finally block }
	JF @c
		THROW
c:
 
 
 
	try { } catch (x) { } finally { }
 
	CATCH @a
	CATCH @d
		{ try block }
	NO_CATCH @e
d:		WRITE_INDEXED x
		POP
		{ catch block }
e:	PUSH #false
	NO_CATCH @b
a:		PUSH #true
b:		{ finally block }
	JF @c
		THROW
c:


	try { } catch (x) { } finally { }

	CATCH @d
		{ try block }
	NO_CATCH
	JMP @e
d:		CATCH @a
			WRITE_INDEXED x
			POP
			{ catch block }
		NO_CATCH
e:	PUSH #false
	JMP @b
a:		PUSH #true
b:		{ finally block }
	JF @c
		THROW
c:


	CATCH @d
		{ try block }
	POP_CATCH_JMP @e
g:	WRITE_INDEXED x
	POP
	{ catch block }
	PUSH #false
	POP_CATCH_JMP @b
d:	NO_CATCH @g
a:	PUSH #true
b:		{ finally block }
	JF @c
		THROW
c:

	
	try { ... } catch (x) { ... }					=  try { ... } catch (x) { ... } finally { }
	try { ... } finally { ... }						=  try { ... } catch (x) { throw x } finally { ... }
	try { ... } catch (x) { ... } finally { ... }	=  try { ... } catch (x) { ... } finally { ... }
	
	TRY @a, @b
		{ ... }
@a	CATCH x
		{ ... }
@b	FINALLY
		{ ... }
	END



	try { } catch (x) { } finally { }
 
	PUSH_CATCH @a @d
		{ try block }
	POP_CATCH @e
d:		WRITE_INDEXED x
		POP
		{ catch block }
e:	PUSH #false
	POP_CATCH @b
a:		PUSH #true
b:		{ finally block }
	JF @c
		THROW
c:




	try { } catch (x) { }
 
	PUSH_CATCH @a @d
		{ try block }
	POP_CATCH @e
d:		WRITE_INDEXED x
		POP
		{ catch block }
e:	POP_CATCH @c
a:		THROW
c:


















	try { } catch (x) { }
 
	ENTER_TRY @a
		{ try block }
	LEAVE_TRY
	JMP @b
a:		(JMP 0 placeholder)
		WRITE_INDEXED x
		POP
		{ catch block }
b:	...




	try { } finally { }
 
	ENTER_TRY @a
		{ try block }
	LEAVE_TRY
	CONST #<nonexistent>
a:	{ finally block }
	THROW


	try { } catch (x) { } finally { }
 
	{ try block }
	JMP @a
b:	{ catch block }
	LEAVE_CATCH
c:	{ finally block }
	THROW




	try { } catch (x) { } finally { }
 
	{ try block }				catch -> b
	JMP @b
b:	{ catch block }
	RETURN
b:	CONST #<nonexistent>
c:	{ finally block }
	THROW






	try {
		// regardless of how we leave the try block (exception, break, return etc), we must always invoke finally
	}
	catch (x) {
		// a scope is created where x is accessible, although all other variable declarations are still in the function scope
		// if the catch doesn't end in throw we continue (executing finally as usual, then leaving the try-catch-finally block)
	}
	finally {
		// if we get here with an exception and don't leave with break, return etc we end with re-throwing
	}

	// we treat all try statements as having both catch and finally, like this:
	// try { ... } catch (x) { ... }	->  try { ... } catch (x) { ... } finally { }
	// try { ... } finally { ... }		->  try { ... } catch (x) { throw x } finally { ... }

	// inside a try and catch blocks we always JSR to finally before leaving the block and on breaks, returns,
	// throws etc that leaves the block (after unregistering the exception handler of course)
	// if we leave the finally block with breaks, returns etc we pop the call stack first
	
	// we need:
	//
	// ENTER_TRY @catch	#identifier	// pushes catch address, identifier (as constant, can be void for no catch) for catch variable, current call stack pointer and value stack pointer to catch stack
	// LEAVE_TRY					// discards first entry on catch stack
	// POP_FRAME					// pops frame pointer from call stack (disregards ip)
	// JSR @offset					// calls a local function, i.e. push a copy of the current context and adjust ip
	// THROW						// pops first entry from catch stack and pushes current frame pointer on call stack, creates a new virtual frame with thrown value assigned to identifier (if string type)

	try { } catch (x) { } finally { }
 
	ENTER_TRY @c #x
	{ try block }
	VOID			// necessary because if finally aborts it will pop
	LEAVE_TRY
	JSR @f
	POP
	JMP @a
c:	{ catch block }
	VOID
	POP_FRAME
	JSR @f
	POP
	JMP @a
f:	{ finally block }
	RETURN
a:	...


	try { } catch (x) { }
 
	ENTER_TRY @c #x
	{ try block }
	VOID
	LEAVE_TRY
	JSR @f
	POP
	JMP @a
c:	{ catch block }
	VOID
	POP_FRAME
	JSR @f
	POP
	JMP @a
f:	RETURN
a:	...



	try { } finally { }
 
	ENTER_TRY @c
	{ try block }
	VOID
	LEAVE_TRY
	JSR @f
	POP
	JMP @a
c:	JSR @f
	THROW
f:	{ finally block }
	RETURN
a:	...


	try { } finally { break }
 
	ENTER_TRY @c #<void>
	{ try block }
	VOID
	LEAVE_TRY
	JSR @f
	POP
	JMP @a
c:	JSR @f
	THROW
f:	POP
	POP_FRAME
	JMP <break>
	RETURN
a:	...



	try { throw 1 } catch (x) { throw x } finally { return 2 }
 
	ENTER_TRY @c #x
	CONST #1
	LEAVE_TRY
	JSR @f
	THROW
	VOID			// necessary because if finally aborts it will pop
	LEAVE_TRY
	JSR @f
	POP
	JMP @a
c:	POP_FRAME
	READ_NAMED #x
	JSR @f
	THROW
	POP_FRAME
	VOID
	JSR @f
	POP
	JMP @a
f:	POP
	POP_FRAME		// drop local return from finally
	CONST #2
	RETURN
	RETURN
a:	...



	finalizers:
	
		try { }	
			
			LEAVE_TRY
			JSR @finally
			
		catch (x) { }
		
			POP_FRAME	// drop temp frame
			JSR @finally
			
		finally { }
		
			POP_FRAME	// drop local return
			POP			// pop pushed

	abruptors:
	
		continue	// do all finalizers up until label, then jump
		break		// do all finalizers up until label, then jump
		throw		// do current finalizer only, then throw
		return
		
OOPS, DIDN'T COVER THE CASE WHERE SOMETHING IS THROWN FROM A CALL WITHIN CATCH


			ENTER_TRY @catch
			LEAVE_TRY
@catch		LEAVE_CATCH
@finally	RETURN

-------------------------------------------------------------------

	// TRY @catch					// pushes catch address, identifier (as constant, can be void for no catch) for catch variable, current call stack pointer and value stack pointer to catch stack
	// TRIED						// discards first entry on catch stack
	// CATCH_FRAME #identifier
	// POP_FRAME					// pops frame pointer from call stack (disregards ip)
	// JSR @offset					// calls a local function, i.e. push a copy of the current context and adjust ip
	// THROW						// pops first entry from catch stack and pushes current frame pointer on call stack, creates a new virtual frame with thrown value assigned to identifier (if string type)

	try { } catch (x) { } finally { }

	TRY @c
	<try block>
	on exit:
		<exit expression>
		JSR @f
		<exit instruction>
c:	TRY @d
	CATCH_FRAME #x
	<catch block>
	on exit:
		<exit expression>
		POP_FRAME
		JSR @f
		<exit instruction>
d:	JSR @g
	THROW
f:	TRIED
g:	<finally block>
	on exit:
		POP
		<exit expression>
		POP_FRAME
		<exit instruction>
	RETURN


	try { } catch (x) { }

	TRY @c
	<try block>
	on exit:
		<exit expression>
		TRIED
		<exit instruction>
c:	CATCH_FRAME #x
	<catch block>
	on exit:
		<exit expression>
		POP_FRAME
		<exit instruction>



	try { } finally { }

	TRY @d
	<try block>
	on exit:
		<exit expression>
		JSR @f
		<exit instruction>
d:	JSR @g
	THROW
f:	TRIED
g:	<finally block>
	on exit:
		<exit expression>
		POP_2ND
		POP_FRAME
		<exit instruction>
	RETURN


	finalizers:
	
		try { }	
			
			TRIED
			JSR @finally
			
		catch (x) { }
		
			POP_FRAME	// drop temp frame
			TRIED
			JSR @finally
			
		finally { }
		
			POP_2ND			// pop pushed
			POP_FRAME	// drop local return

		continue	// do all finalizers up until label, then pop and jump
		break		// do all finalizers up until label, then pop and jump
		return		// do all finalizers





------------------ table solution -------------------


	try { } catch (x) { } finally { }

0			<try block>
1			on exit:
2				<exit expression>
3				JSR @f
4				<exit instruction>
5		c:	CATCH_FRAME #x
6			<catch block>
7			on exit:
8				<exit expression>
9				POP_FRAME
10				JSR @f
11				<exit instruction>
12		d:	JSR @f
13			THROW
14		f:	<finally block>
15			on exit:
16				<exit expression>
17				POP_2ND
18				POP_FRAME
19				<exit instruction>
20			RETURN

Table:
	0..5	@c
	5..12	@d
	
	
		blahblah; try { blahblah; try { bluhbluh } finally { blohbloh } blahblah; } catch (x) { blahblah }; blehbleh
		
0		blahblah
1		blahblah // try
2		bluhbluh
3		JSR @f
4		JMP @a
5	f:	blohbloh
6		RETURN
7	a:	blahblah
8		JMP @b
9	c:	ENTER_CATCH #x
10		blahblah
11		LEAVE_CATCH
12	b:	blehbleh

Table.
	1..9 @c
	
	
Disadvantage with table solution: catch blocks can never ever require a different "vsp level" than on function entry,
and we need to store vsp pointer in each frame

Advantage is speed, less code, automatically 100% tight to "asynchronous throws" (i.e. throwing at any instruction)

