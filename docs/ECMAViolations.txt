Violations
----------

*) \0 is interpreted as null char even if followed by decimals (octals are not supported)

*) Doesn't consider unicode Line separator <LS> (\u2028) or Paragraph separator <PS> (\u2029) to be linefeeds. Only LF
	or CR. Also <NBSP> (\u00A0) and <ZWNBSP> ZERO WIDTH NO-BREAK SPACE (\uFEFF) are not considered white space. FIX :
	yes it does now, except \uFEFF

	Also: no other "<USP>" ("space separator") is considered white space (not in RegExps either!)

*) Unicode in identifiers are not allowed
	FIX : why not?

	Follow up: they are now

*) Although based mainly on ECMAScript 5, custom properties are not supported (getters, setters etc)

	Nah, I redefine that. It is based on ECMAScript 3, feature-wise etc, but where ECMAScript 3 is incompatible with 5,
	compatibility with 5 is preferred.

	Again, I redefine that. It's strictly ES3 now.

*) No RegExp support. Including literals etc.
	
	It's there now after all.

*) implicit valueOf and toString conversions are done earlier than in ECMA standard and not necessarily in the same
order or number of times. E.g. v[o]++ in Ecmascript means two calls to toString() but one in NuXJScript.

*) does not support octal (0o) or binary (0b) in string->value conversion

*) arguments object mapping follow ES3 rules only, changing element attributes (read-only etc) doesn't follow ES5 rules
100%

*) function 'name' property is set for all created function which seems to be a commonly found feature although not
standardized until ES6. In ES6 the name property is not writable, not enumerable, but configurable. In NuXJScript it has
standard attributes (equivalent to writable, enumerable, configurable).

*) The following point:

		11.2.3: Edition 5 reverses the order of steps 2 and 3 of the algorithm. The original order as specified in
		Editions 1 through 3 was incorrectly specified such that side-effects of evaluating Arguments could affect the
		result of evaluating MemberExpression.

	is not respected (but it *is* a 5.1 point after all)... evaluation order is object and arguments first, then finally
	getting the member

*) The following point:
		
		12.4: In Edition 3, an object is created, as if by new Object() to serve as the scope for resolving the name of
		the exception parameter passed to a catch clause of a try statement. If the actual exception object is a
		function and it is called from within the catch clause, the scope object will be passed as the this value of the
		call. The body of the function can then define new properties on its this value and those property names become
		visible identifiers bindings within the scope of the catch clause after the function returns. In Edition 5, when
		an exception parameter is called as a function, undefined is passed as the this value.

	*is* respected (sort of), although it is a 5.1 change... this will be the global object as a regular function call
	(which is the same in effect as undefined because it is converted to the global object).

*) Does not evaluate left-hand side of an assignment to a reference before evaluating right-hand side. E.g. provided `x`
is a global, `x = (eval("var x;"), 1)` (from within a function) will assign to the local x that is declared by the eval,
not to the global x. On the other hand, most engines do the same (incl V8 at the time of writing).

*) Doesn't respect the exact evaluation order specified here: 11.2.1 Property Accessors. Expression is evaluated and
possibly converted to string before base is converted to object as exemplified with this test:

	var invalidBase = null;
	var objectPropertyName = { toString: function() { print("to string called!"); return 'x' } };
	try { invalidBase[objectPropertyName] } catch (e) { print(e.name) }

	This will output "to string called!" in NuXJScript, although it really shouldn't

	Rationale: performance. Object conversion is done directly by the GET_PROPERTY opcode. Conversion to primitive value
	must happen before this (via OBJ_TO_STRING) as it may require running script code.

*) In regular expressions: lookahead operators ?= and ?! are not atoms with optional quantifier as in Ecmascript 3, but
assertions *without* quantifier as in ES5. E.g. `(?=x)*` is invalid syntax.

*) In regular expressions: not 100% certain that the following two features complies perfectly:

		. Case-insensitive matches of character class ranges: is complicated because the standard seem to assume that
		you do these through lookup tables, but we don't, so matching range 'A-f' for example is done by matching either
		uppercase or lowercase character to 'A-f' range. Now exactly how this works with complicated unicode
		translations I'm not sure. See 15.10.2.16 in the ES3 spec.

		. Zero-length captures inside repeats, e.g. '^(a*)*$'. I'm interpreting the ES specs differently from the
		browser engines that I've tried, but similar to (at least older versions of) PCRE. The capture will be empty
		because the empty string is the last successful match to (a*), after which we are not progressing on the input
		so we break out of the two '*' loops. I believe my interpretation is correct, but I am not 100%. See 15.10.2.5
		in the ES3 spec.

*) ';' is required after do-while. In reality, no engine seems to have bothered with this, although it is part of ES3->5
(in ES6 they made ';' optional). Even the old Sputnik tests are wrong. So this is not a violation, but actually a
stricter conformance to the standard).

*) Not really unconforming to Ecmascript 3, but would be a problem if we fully supported defineProperty as in ES 5:

		// In NuXJ it is allowed to create a property with a numeric name even if a read-only property higher up in the
		// prototype-chain has the same name. This is a side-effect of a q&d fix for a performance problem concerning
		// adding elements to arrays. Since creating your own read-only properties isn't a part of Ecmascript 3 standard
		// (and no built-in object has read-only numerical properties), I'm going to let this pass.

*) Also see all tests/unconforming

*) You cannot assign an object to an array's "length" property even if it has a valueOf() method. This is because of the
asynchronous design of this engine. It would require a complicated interrupt mechanism (think "property setter") and it
simply isn't worth the effort for this alone.

*) Not a violation but we impose a quite hard restriction on recursive grammar constructs such as deep object literals
(64 levels only) and functions in functions etc. This is to avoid the risk of C++ stack overflow.

Following later specs
---------------------

*) Implements the following ES5 methods:

	15.4.3.2 Array.isArray ( arg )
	15.2.4.5 Object.prototype.hasOwnProperty (V)
	15.2.4.6 Object.prototype.isPrototypeOf (V)
	15.2.3.2 Object.getPrototypeOf ( O )
	15.2.3.6 Object.defineProperty ( O, P, Attributes )
	15.12.2 JSON.parse ( text [ , reviver ] )
	15.12.3 JSON.stringify ( value [ , replacer [ , space ] ] )

*) Implements the following feature from Ecmascript 5:

		15.5.5.2: In Edition 5, the individual characters of a String objectâ€˜s [[PrimitiveValue] may be accessed as
		array indexed properties of the String object. These properties are non-writable and non-configurable and shadow
		any inherited properties with the same names. In Edition 3, these properties did not exist and ECMAScript code
		could dynamically add and remove writable properties with such names and could access inherited properties with
		such names.
	
	Rationale: performance and code compatibility. This seems to be something even older JS implementations had. Without
	it, many "native" library functions would be uglier to write or horribly slow.

*) eval() conforms to the ES5 rules concerning direct vs non-direct call to eval(). In ES3 only behavior of direct calls
are specified.

*) For String.prototype.match the Ecmascript 3 specification doesn't state that null should be returned for global
regular expression patterns when no match is found, but it seems like this has always been the de-facto behavior. It was
documented first in Ecmascript 5 but NuXJScript conforms to this rule anyhow. Also, the ES3 spec doesn't say that the
*standard* built-in function RegExp.prototype.exec should be used, so a strict interpretation would allow the user to
change the function used by reassigning RegExp.prototype.exec. We follow the ES5 spec here and will disregard any custom
RegExp.prototype.exec function. See 15.5.4.10.

*) Array.prototype.splice follows the ES6 rule when called with a single argument only (deletes the rest of the array).
This seems to have been de-facto standard since forever although ES3 and ES5 specified that no elements should be
deleted.

*) A lot of Date Object features from ES5 has been implemented.

*) RegExp flags cannot contain a unicode escape sequence. This is not specified until 11.8.5.1 in ES6.

*) From ES5: 7.1: Unicode format control characters are no longer stripped from ECMAScript source text before processing.
